<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::D3D11StagingBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_d3_d11_staging_buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_d3_d11_staging_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::D3D11StagingBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NOTE FOR D3D12 PORTING: The GL3Plus implementation should be used as reference, since it is much lower level than this implementation for D3D11.  
 <a href="class_ogre_1_1_d3_d11_staging_buffer.html#details">More...</a></p>

<p><code>#include &lt;OgreD3D11StagingBuffer.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::D3D11StagingBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_d3_d11_staging_buffer__inherit__graph.svg" width="190" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae90c8303a85284ef6801919bfc4fdfd0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a></td></tr>
<tr class="separator:ae90c8303a85284ef6801919bfc4fdfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac79f3f3bf9ef8600dfa361f0456db25f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#ac79f3f3bf9ef8600dfa361f0456db25f">D3D11StagingBuffer</a> (size_t sizeBytes, <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, bool uploadOnly, ID3D11Buffer *stagingBuffer, <a class="el" href="class_ogre_1_1_d3_d11_device.html">D3D11Device</a> &amp;device)</td></tr>
<tr class="separator:ac79f3f3bf9ef8600dfa361f0456db25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d68f22a81bde0dfb9bc17752052078"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#a05d68f22a81bde0dfb9bc17752052078">~D3D11StagingBuffer</a> ()</td></tr>
<tr class="separator:a05d68f22a81bde0dfb9bc17752052078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240f4261cb238ed9b1325856f6f5d772"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#a240f4261cb238ed9b1325856f6f5d772">_asyncDownload</a> (<a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *source, size_t srcOffset, size_t srcLength)</td></tr>
<tr class="memdesc:a240f4261cb238ed9b1325856f6f5d772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the GPU data in <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> so that it can be later read by the CPU using an <a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous. ">AsyncTicket</a>.  <a href="#a240f4261cb238ed9b1325856f6f5d772">More...</a><br /></td></tr>
<tr class="separator:a240f4261cb238ed9b1325856f6f5d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9db4541715b29e151043a09a24a527a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ad9db4541715b29e151043a09a24a527a">_cancelDownload</a> (size_t offset, size_t sizeBytes)</td></tr>
<tr class="memdesc:ad9db4541715b29e151043a09a24a527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory assigned to a download that hasn't been mapped yet, to make space for another _asyncDownload call.  <a href="#ad9db4541715b29e151043a09a24a527a">More...</a><br /></td></tr>
<tr class="separator:ad9db4541715b29e151043a09a24a527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6789c54909d4f248cb69a3a8a04f3e"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#abf6789c54909d4f248cb69a3a8a04f3e">_mapForRead</a> (size_t offset, size_t sizeBytes)</td></tr>
<tr class="memdesc:abf6789c54909d4f248cb69a3a8a04f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the buffer for read acces for the CPU.  <a href="#abf6789c54909d4f248cb69a3a8a04f3e">More...</a><br /></td></tr>
<tr class="separator:abf6789c54909d4f248cb69a3a8a04f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b28de5293c036bf7f23e87bef00de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a10b28de5293c036bf7f23e87bef00de6">addReferenceCount</a> (void)</td></tr>
<tr class="memdesc:a10b28de5293c036bf7f23e87bef00de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reference count to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a>.  removeReferenceCount.  <a href="#a10b28de5293c036bf7f23e87bef00de6">More...</a><br /></td></tr>
<tr class="separator:a10b28de5293c036bf7f23e87bef00de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351c50d59942c9b54b1cb5f20bd85699"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a351c50d59942c9b54b1cb5f20bd85699">canDownload</a> (size_t length) const </td></tr>
<tr class="memdesc:a351c50d59942c9b54b1cb5f20bd85699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this staging buffer has enough free space to use _asyncDownload.  <a href="#a351c50d59942c9b54b1cb5f20bd85699">More...</a><br /></td></tr>
<tr class="separator:a351c50d59942c9b54b1cb5f20bd85699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3064be7272d09777d7e993dd2629d"><td class="memItemLeft" align="right" valign="top">ID3D11Buffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#aecc3064be7272d09777d7e993dd2629d">getBufferName</a> (void) const </td></tr>
<tr class="separator:aecc3064be7272d09777d7e993dd2629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af759c6fc5dda6a21bc6971191490fcbd"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#af759c6fc5dda6a21bc6971191490fcbd">getLastUsedTimestamp</a> (void)</td></tr>
<tr class="memdesc:af759c6fc5dda6a21bc6971191490fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in millisecond when the ref. count became 0.  <a href="#af759c6fc5dda6a21bc6971191490fcbd">More...</a><br /></td></tr>
<tr class="separator:af759c6fc5dda6a21bc6971191490fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcbfa8246a6ecf5653c5c50d62a3c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#aefcbfa8246a6ecf5653c5c50d62a3c6d">getLifetimeThreshold</a> (void) const </td></tr>
<tr class="memdesc:aefcbfa8246a6ecf5653c5c50d62a3c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should live with a reference count of 0 before being deleted.  <a href="#aefcbfa8246a6ecf5653c5c50d62a3c6d">More...</a><br /></td></tr>
<tr class="separator:aefcbfa8246a6ecf5653c5c50d62a3c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc65d5c3a611f6f1df74757cd086580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a6dc65d5c3a611f6f1df74757cd086580">getMappingState</a> (void) const </td></tr>
<tr class="separator:a6dc65d5c3a611f6f1df74757cd086580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765f26f80115c9341308fc86330ec9c2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a765f26f80115c9341308fc86330ec9c2">getMaxSize</a> (void)</td></tr>
<tr class="separator:a765f26f80115c9341308fc86330ec9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd9cdf78b807e17fe1039c2e7093663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a5bd9cdf78b807e17fe1039c2e7093663">getReferenceCount</a> (void) const </td></tr>
<tr class="separator:a5bd9cdf78b807e17fe1039c2e7093663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602261c997945e599b85b05ea227b5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a602261c997945e599b85b05ea227b5a3">getUnfencedTimeThreshold</a> (void) const </td></tr>
<tr class="memdesc:a602261c997945e599b85b05ea227b5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should hazards unfenced while with a reference count of 0.  <a href="#a602261c997945e599b85b05ea227b5a3">More...</a><br /></td></tr>
<tr class="separator:a602261c997945e599b85b05ea227b5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98bd80302dc56a26ca8ba227bab11c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a3a98bd80302dc56a26ca8ba227bab11c">getUploadOnly</a> (void) const </td></tr>
<tr class="memdesc:a3a98bd80302dc56a26ca8ba227bab11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true, this buffer can only be used for uploading to GPU.  <a href="#a3a98bd80302dc56a26ca8ba227bab11c">More...</a><br /></td></tr>
<tr class="separator:a3a98bd80302dc56a26ca8ba227bab11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#ab58661498c6fd0e054a0c261ebb3bbcf">map</a> (size_t sizeBytes)</td></tr>
<tr class="memdesc:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the given amount of bytes.  <a href="#ab58661498c6fd0e054a0c261ebb3bbcf">More...</a><br /></td></tr>
<tr class="separator:ab58661498c6fd0e054a0c261ebb3bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29313389dacd812a8d238df458f9e979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a29313389dacd812a8d238df458f9e979">removeReferenceCount</a> (void)</td></tr>
<tr class="memdesc:a29313389dacd812a8d238df458f9e979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count by one.  <a href="#a29313389dacd812a8d238df458f9e979">More...</a><br /></td></tr>
<tr class="separator:a29313389dacd812a8d238df458f9e979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e2853c21a7418218605a0b9cdf461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a9c8e2853c21a7418218605a0b9cdf461">unmap</a> (const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> *destinations, size_t numDestinations)</td></tr>
<tr class="separator:a9c8e2853c21a7418218605a0b9cdf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438d82f09b5f657be30c30d7d1c0801d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">unmap</a> (const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &amp;destination)</td></tr>
<tr class="memdesc:a438d82f09b5f657be30c30d7d1c0801d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the mapped region and copies the data to the given region.  <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a>.  <a href="#a438d82f09b5f657be30c30d7d1c0801d">More...</a><br /></td></tr>
<tr class="separator:a438d82f09b5f657be30c30d7d1c0801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe091313c974edab09f0f9daabf8034d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_staging_buffer.html#afe091313c974edab09f0f9daabf8034d">unmap</a> (const <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a> &amp;destinations)</td></tr>
<tr class="memdesc:afe091313c974edab09f0f9daabf8034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the mapped region and copies the data to multiple buffers.  <a href="#afe091313c974edab09f0f9daabf8034d">More...</a><br /></td></tr>
<tr class="separator:afe091313c974edab09f0f9daabf8034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cd3b649225c35a756a88070fd88e86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#af48b48d39914b067541a62b674b80935">StagingStallType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html#a73cd3b649225c35a756a88070fd88e86">uploadWillStall</a> (size_t sizeBytes)</td></tr>
<tr class="memdesc:a73cd3b649225c35a756a88070fd88e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if our next call to () with the same parameters will stall.  <a href="#a73cd3b649225c35a756a88070fd88e86">More...</a><br /></td></tr>
<tr class="separator:a73cd3b649225c35a756a88070fd88e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NOTE FOR D3D12 PORTING: The GL3Plus implementation should be used as reference, since it is much lower level than this implementation for D3D11. </p>
<p>A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However the access in both cases is limited. GPUs can only copy (i.e. memcpy) to another real buffer (can't be used directly as i.e. texture or vertex buffer) and CPUs can only map it. In other words, a staging buffer is an intermediate buffer to transfer data between CPU &amp; GPU </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae90c8303a85284ef6801919bfc4fdfd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a>&gt;::type <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">Ogre::StagingBuffer::DestinationVec</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac79f3f3bf9ef8600dfa361f0456db25f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::D3D11StagingBuffer::D3D11StagingBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uploadOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D11Buffer *&#160;</td>
          <td class="paramname"><em>stagingBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_d3_d11_device.html">D3D11Device</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a05d68f22a81bde0dfb9bc17752052078"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::D3D11StagingBuffer::~D3D11StagingBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a240f4261cb238ed9b1325856f6f5d772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::D3D11StagingBuffer::_asyncDownload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the GPU data in <a class="el" href="class_ogre_1_1_buffer_packed.html">BufferPacked</a> to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> so that it can be later read by the CPU using an <a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous. ">AsyncTicket</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_async_ticket.html" title="In Ogre 2.0 data structures, reading data from GPU back to CPU is asynchronous. ">AsyncTicket</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For internal use. May throw if it can't handle the request (i.e. requested size is too big, or too many _asyncDownload operations are pending until calling _mapForRead) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#a351c50d59942c9b54b1cb5f20bd85699" title="Checks if this staging buffer has enough free space to use _asyncDownload. ">canDownload</a> mUploadOnly must be true. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The buffer to copy from. </td></tr>
    <tr><td class="paramname">srcOffset</td><td>The offset, in bytes, of the buffer to copy from. </td></tr>
    <tr><td class="paramname">srcLength</td><td>The size in bytes, of the data to transfer to this staging buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in bytes that will be used by </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#abf6789c54909d4f248cb69a3a8a04f3e" title="Maps the buffer for read acces for the CPU. ">_mapForRead</a> </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_staging_buffer.html#a3fed0b896633e63d9cb112c0ae026bd3">Ogre::StagingBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad9db4541715b29e151043a09a24a527a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StagingBuffer::_cancelDownload </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases memory assigned to a download that hasn't been mapped yet, to make space for another _asyncDownload call. </p>
<p>Useful when you suddenly don't intend to call _mapForRead. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#ab4ad5fe671c29396b3e44f500e4e1a6a">Ogre::MetalStagingBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="abf6789c54909d4f248cb69a3a8a04f3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* Ogre::StagingBuffer::_mapForRead </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the buffer for read acces for the CPU. </p>
<dl class="section remark"><dt>Remarks</dt><dd>For internal use. mUploadOnly must be true. Attempting to const cast the returned pointer and write to it is undefined behavior. Call unmap( 0, 0 ) to unmap. Once mapped and unmapped, the same region shouldn't be remapped. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The returned value from _asyncDownload. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>The size in bytes of the data to map. Should be parameter 'srcLength' passed to _asyncDownload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer with the data read from the GPU. Read only. </dd></dl>

</div>
</div>
<a class="anchor" id="a10b28de5293c036bf7f23e87bef00de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::addReferenceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a reference count to the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a>.  removeReferenceCount. </p>

</div>
</div>
<a class="anchor" id="a351c50d59942c9b54b1cb5f20bd85699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StagingBuffer::canDownload </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this staging buffer has enough free space to use _asyncDownload. </p>
<p>Otherwise such function would raise an exception. </p><dl class="section remark"><dt>Remarks</dt><dd>mUploadOnly must be true. It is the counter side of </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465" title="Returns true if our next call to () with the same parameters will stall. ">uploadWillStall</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The size in bytes that need to be downloaded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_staging_buffer.html#a929ba6856b32633fe37c3c6bfd1bc7f6">Ogre::MetalStagingBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aecc3064be7272d09777d7e993dd2629d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ID3D11Buffer* Ogre::D3D11StagingBuffer::getBufferName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af759c6fc5dda6a21bc6971191490fcbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ogre::StagingBuffer::getLastUsedTimestamp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in millisecond when the ref. count became 0. </p>

</div>
</div>
<a class="anchor" id="aefcbfa8246a6ecf5653c5c50d62a3c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::StagingBuffer::getLifetimeThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should live with a reference count of 0 before being deleted. </p>

</div>
</div>
<a class="anchor" id="a6dc65d5c3a611f6f1df74757cd086580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a447e51d7625af79716667cebcfa6da57">MappingState</a> Ogre::StagingBuffer::getMappingState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a765f26f80115c9341308fc86330ec9c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::StagingBuffer::getMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bd9cdf78b807e17fe1039c2e7093663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> Ogre::StagingBuffer::getReferenceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a602261c997945e599b85b05ea227b5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::StagingBuffer::getUnfencedTimeThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time in milliseconds in which a <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> should hazards unfenced while with a reference count of 0. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#aefcbfa8246a6ecf5653c5c50d62a3c6d" title="Returns the time in milliseconds in which a StagingBuffer should live with a reference count of 0 bef...">getLifetimeThreshold</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a98bd80302dc56a26ca8ba227bab11c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::StagingBuffer::getUploadOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When true, this buffer can only be used for uploading to GPU. </p>
<p>When false, can only be used for downloading from GPU </p>

</div>
</div>
<a class="anchor" id="ab58661498c6fd0e054a0c261ebb3bbcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Ogre::StagingBuffer::map </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the given amount of bytes. </p>
<p>May block if not ready.  uploadWillStall if you wish to know. </p><dl class="section remark"><dt>Remarks</dt><dd>Will throw if sizeBytes &gt; this-&gt;<a class="el" href="class_ogre_1_1_staging_buffer.html#a765f26f80115c9341308fc86330ec9c2">getMaxSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29313389dacd812a8d238df458f9e979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::removeReferenceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the reference count by one. </p>
<p>StagingBuffers are manually reference counted. The first reason is performance. The second main reason is that the pointer doesn't get immediately deleted when the reference hits 0. </p><dl class="section user"><dt></dt><dd>Instead, a reference count of 0 means the Vao manager will monitor its lifetime. If it has been 0 for too long (past certain time threshold) the Vao manager will destroy this staging buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>Meanwhile, the Staging Buffer will live in a pool until it's requested again or the time threshold is met. This prevents unwanted hiccups due to buffers getting recreated and destroyed all the time. Keep a non-zero ref. count to ensure the <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> won't be deleted due to timeouts (i.e. you know this buffer will get used at long regular intervals, like once every 15 minutes) </dd></dl>
<dl class="section user"><dt></dt><dd>Having a non-zero reference count doesn't mean the pointer will live forever though, as the memory is owned by the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a>: if the <a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> is shutdown, this <a class="el" href="class_ogre_1_1_staging_buffer.html" title="A staging buffer is a buffer that resides on the GPU and be written to/from both CPU &amp; GPU However th...">StagingBuffer</a> will be freed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c8e2853c21a7418218605a0b9cdf461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numDestinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a438d82f09b5f657be30c30d7d1c0801d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps the mapped region and copies the data to the given region.  <a class="el" href="struct_ogre_1_1_staging_buffer_1_1_destination.html">Destination</a>. </p>

<p>References <a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">Ogre::StagingBuffer::unmap()</a>.</p>

<p>Referenced by <a class="el" href="class_ogre_1_1_staging_buffer.html#a438d82f09b5f657be30c30d7d1c0801d">Ogre::StagingBuffer::unmap()</a>.</p>

</div>
</div>
<a class="anchor" id="afe091313c974edab09f0f9daabf8034d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StagingBuffer::unmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_staging_buffer.html#ae90c8303a85284ef6801919bfc4fdfd0">DestinationVec</a> &amp;&#160;</td>
          <td class="paramname"><em>destinations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps the mapped region and copies the data to multiple buffers. </p>
<p>Useful when loading many meshes or textures at once (i.e. from multiple threads) </p>

</div>
</div>
<a class="anchor" id="a73cd3b649225c35a756a88070fd88e86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#af48b48d39914b067541a62b674b80935">StagingStallType</a> Ogre::D3D11StagingBuffer::uploadWillStall </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if our next call to () with the same parameters will stall. </p>
<p>StagingStallType </p><dl class="section remark"><dt>Remarks</dt><dd>Not all RenderSystems can accurately give this information and will always return STALL_PARTIAL (i.e. GLES2) The chances of getting a STALL_FULL get higher as sizeBytes gets closer to this-&gt;<a class="el" href="class_ogre_1_1_staging_buffer.html#a765f26f80115c9341308fc86330ec9c2">getMaxSize()</a> mUploadOnly must be false. It is the counter side of </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_staging_buffer.html#a351c50d59942c9b54b1cb5f20bd85699" title="Checks if this staging buffer has enough free space to use _asyncDownload. ">canDownload</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_staging_buffer.html#ababb860ddfb4ecdf054766f145848465">Ogre::StagingBuffer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_d3_d11_staging_buffer_8h.html">OgreD3D11StagingBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_d3_d11_staging_buffer.html">D3D11StagingBuffer</a></li>
    <li class="footer">Generated on Thu May 4 2017 22:21:38 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
