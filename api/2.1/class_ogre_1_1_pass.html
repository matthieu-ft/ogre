<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::Pass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_pass.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_pass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::Pass Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___materials.html">Materials</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class defining a single pass of a <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a> (of a <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a>), i.e.  
 <a href="class_ogre_1_1_pass.html#details">More...</a></p>

<p><code>#include &lt;OgrePass.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Pass:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_pass__inherit__graph.svg" width="99" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a98b42a4f4304f3f2d08fb9394cbefe83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; TextureUnitStates &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a></td></tr>
<tr class="separator:a98b42a4f4304f3f2d08fb9394cbefe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bc2b00e42ad2699a1e2a1de340d3b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; TextureUnitStates &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a></td></tr>
<tr class="separator:ac7bc2b00e42ad2699a1e2a1de340d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7f36f2c48b62fd29b2abdee4425d6a2c">Pass</a> (<a class="el" href="class_ogre_1_1_technique.html">Technique</a> *parent, unsigned short index)</td></tr>
<tr class="memdesc:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7f36f2c48b62fd29b2abdee4425d6a2c">More...</a><br /></td></tr>
<tr class="separator:a7f36f2c48b62fd29b2abdee4425d6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af67ca21bb1a91d6c228db8207384fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2af67ca21bb1a91d6c228db8207384fc">Pass</a> (<a class="el" href="class_ogre_1_1_technique.html">Technique</a> *parent, unsigned short index, const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;oth)</td></tr>
<tr class="memdesc:a2af67ca21bb1a91d6c228db8207384fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a2af67ca21bb1a91d6c228db8207384fc">More...</a><br /></td></tr>
<tr class="separator:a2af67ca21bb1a91d6c228db8207384fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73276f829c68266eca0c0fd700e13638"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a73276f829c68266eca0c0fd700e13638">~Pass</a> ()</td></tr>
<tr class="separator:a73276f829c68266eca0c0fd700e13638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae147dfdf1c89089b1a8fadaaa2a59672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae147dfdf1c89089b1a8fadaaa2a59672">_getDatablock</a> (void) const </td></tr>
<tr class="memdesc:ae147dfdf1c89089b1a8fadaaa2a59672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the internal datablock that acts as proxy for us.  <a href="#ae147dfdf1c89089b1a8fadaaa2a59672">More...</a><br /></td></tr>
<tr class="separator:ae147dfdf1c89089b1a8fadaaa2a59672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a266864da9539e07de89c3fc454710"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad2a266864da9539e07de89c3fc454710">_getTextureUnitWithContentTypeIndex</a> (<a class="el" href="class_ogre_1_1_texture_unit_state.html#a35a108a68c71c8267af4af8c1a819030">TextureUnitState::ContentType</a> contentType, size_t index) const </td></tr>
<tr class="memdesc:ad2a266864da9539e07de89c3fc454710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'nth' texture which references the given content type.  <a href="#ad2a266864da9539e07de89c3fc454710">More...</a><br /></td></tr>
<tr class="separator:ad2a266864da9539e07de89c3fc454710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46">_load</a> (void)</td></tr>
<tr class="memdesc:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for loading this pass.  <a href="#ac1e07d3bccdb7f6c437c107c92e4ae46">More...</a><br /></td></tr>
<tr class="separator:ac1e07d3bccdb7f6c437c107c92e4ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa52a3826a08569b8263834f043a83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afaa52a3826a08569b8263834f043a83f">_notifyIndex</a> (unsigned short index)</td></tr>
<tr class="memdesc:afaa52a3826a08569b8263834f043a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to adjust pass index.  <a href="#afaa52a3826a08569b8263834f043a83f">More...</a><br /></td></tr>
<tr class="separator:afaa52a3826a08569b8263834f043a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cf60f49c52c53671d5bb5105231e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab85cf60f49c52c53671d5bb5105231e8">_prepare</a> (void)</td></tr>
<tr class="memdesc:ab85cf60f49c52c53671d5bb5105231e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for preparing to load this pass.  <a href="#ab85cf60f49c52c53671d5bb5105231e8">More...</a><br /></td></tr>
<tr class="separator:ab85cf60f49c52c53671d5bb5105231e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5766787845b1be6dfbf45cac068fc825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5766787845b1be6dfbf45cac068fc825">_unload</a> (void)</td></tr>
<tr class="memdesc:a5766787845b1be6dfbf45cac068fc825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for unloading this pass.  <a href="#a5766787845b1be6dfbf45cac068fc825">More...</a><br /></td></tr>
<tr class="separator:a5766787845b1be6dfbf45cac068fc825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928061c8f56d923808add7e8ba9cdee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a928061c8f56d923808add7e8ba9cdee8">_unprepare</a> (void)</td></tr>
<tr class="memdesc:a928061c8f56d923808add7e8ba9cdee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for undoing the load preparartion for this pass.  <a href="#a928061c8f56d923808add7e8ba9cdee8">More...</a><br /></td></tr>
<tr class="separator:a928061c8f56d923808add7e8ba9cdee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eaf1d7ed3327c29733595fc4142dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a54eaf1d7ed3327c29733595fc4142dac">_updateAutoParams</a> (const <a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *source, <a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> variabilityMask) const </td></tr>
<tr class="memdesc:a54eaf1d7ed3327c29733595fc4142dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update automatic parameters.  <a href="#a54eaf1d7ed3327c29733595fc4142dac">More...</a><br /></td></tr>
<tr class="separator:a54eaf1d7ed3327c29733595fc4142dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a4036c87d4778c20d19412e9530ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a00a4036c87d4778c20d19412e9530ff2">addTextureUnitState</a> (<a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *state)</td></tr>
<tr class="memdesc:a00a4036c87d4778c20d19412e9530ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the passed in <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a>, to the existing <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>.  <a href="#a00a4036c87d4778c20d19412e9530ff2">More...</a><br /></td></tr>
<tr class="separator:a00a4036c87d4778c20d19412e9530ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c2721a68454b17942c5fd6d25f45de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab2c2721a68454b17942c5fd6d25f45de">applyTextureAliases</a> (const <a class="el" href="group___general.html#ga20898062bd79359acd1137276d9b0e37">AliasTextureNamePairList</a> &amp;aliasList, const bool apply=true) const </td></tr>
<tr class="memdesc:ab2c2721a68454b17942c5fd6d25f45de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies texture names to <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State with matching texture name aliases.  <a href="#ab2c2721a68454b17942c5fd6d25f45de">More...</a><br /></td></tr>
<tr class="separator:ab2c2721a68454b17942c5fd6d25f45de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c8d03e581a06d067295faaaf3b99cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a05c8d03e581a06d067295faaaf3b99cc">calculateSize</a> (void) const </td></tr>
<tr class="separator:a05c8d03e581a06d067295faaaf3b99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b37124088b574d2cbb2652c0ee4272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af8b37124088b574d2cbb2652c0ee4272">createTextureUnitState</a> (void)</td></tr>
<tr class="memdesc:af8b37124088b574d2cbb2652c0ee4272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>.  <a href="#af8b37124088b574d2cbb2652c0ee4272">More...</a><br /></td></tr>
<tr class="separator:af8b37124088b574d2cbb2652c0ee4272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee1e1da3564408697f6b1227102c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adfee1e1da3564408697f6b1227102c63">createTextureUnitState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;textureName, unsigned short texCoordSet=0)</td></tr>
<tr class="memdesc:adfee1e1da3564408697f6b1227102c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>.  <a href="#adfee1e1da3564408697f6b1227102c63">More...</a><br /></td></tr>
<tr class="separator:adfee1e1da3564408697f6b1227102c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a026a1aec91f8661c96b79d41c54d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab0a026a1aec91f8661c96b79d41c54d2">getAlphaRejectFunction</a> (void) const </td></tr>
<tr class="memdesc:ab0a026a1aec91f8661c96b79d41c54d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject function.  <a href="#ab0a026a1aec91f8661c96b79d41c54d2">More...</a><br /></td></tr>
<tr class="separator:ab0a026a1aec91f8661c96b79d41c54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97da177e624bb0abe329272081ef7bd"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac97da177e624bb0abe329272081ef7bd">getAlphaRejectValue</a> (void) const </td></tr>
<tr class="memdesc:ac97da177e624bb0abe329272081ef7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject value.  <a href="#ac97da177e624bb0abe329272081ef7bd">More...</a><br /></td></tr>
<tr class="separator:ac97da177e624bb0abe329272081ef7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4bacffdf08bc93794a66ce0a33df4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2de4bacffdf08bc93794a66ce0a33df4">getAmbient</a> (void) const </td></tr>
<tr class="memdesc:a2de4bacffdf08bc93794a66ce0a33df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ambient colour reflectance of the pass.  <a href="#a2de4bacffdf08bc93794a66ce0a33df4">More...</a><br /></td></tr>
<tr class="separator:a2de4bacffdf08bc93794a66ce0a33df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fad6b84d0e2453b0cef04b92dea911"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a85fad6b84d0e2453b0cef04b92dea911">getBlendblock</a> (void) const </td></tr>
<tr class="memdesc:a85fad6b84d0e2453b0cef04b92dea911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves current blendblock.  <a href="#a85fad6b84d0e2453b0cef04b92dea911">More...</a><br /></td></tr>
<tr class="separator:a85fad6b84d0e2453b0cef04b92dea911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5e2cd0176a5e1e57efb5515c95b80a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8f5e2cd0176a5e1e57efb5515c95b80a">getColourWriteEnabled</a> (void) const </td></tr>
<tr class="memdesc:a8f5e2cd0176a5e1e57efb5515c95b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if colour buffer writing is enabled for this pass.  <a href="#a8f5e2cd0176a5e1e57efb5515c95b80a">More...</a><br /></td></tr>
<tr class="separator:a8f5e2cd0176a5e1e57efb5515c95b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c10574084df798b4e67c8c3e544f1fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4c10574084df798b4e67c8c3e544f1fd">getComputeProgram</a> (void) const </td></tr>
<tr class="memdesc:a4c10574084df798b4e67c8c3e544f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation EHull program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#a4c10574084df798b4e67c8c3e544f1fd">More...</a><br /></td></tr>
<tr class="separator:a4c10574084df798b4e67c8c3e544f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30510adef0f4588f2475009b65a1943f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a30510adef0f4588f2475009b65a1943f">getComputeProgramName</a> (void) const </td></tr>
<tr class="memdesc:a30510adef0f4588f2475009b65a1943f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the Tessellation Hull program used by this pass.  <a href="#a30510adef0f4588f2475009b65a1943f">More...</a><br /></td></tr>
<tr class="separator:a30510adef0f4588f2475009b65a1943f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60735245e290061f117118253ebd648f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a60735245e290061f117118253ebd648f">getComputeProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:a60735245e290061f117118253ebd648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation Hull program parameters used by this pass.  <a href="#a60735245e290061f117118253ebd648f">More...</a><br /></td></tr>
<tr class="separator:a60735245e290061f117118253ebd648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61406c45d5607d5daa520201fc68017"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac61406c45d5607d5daa520201fc68017">getDiffuse</a> (void) const </td></tr>
<tr class="memdesc:ac61406c45d5607d5daa520201fc68017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the diffuse colour reflectance of the pass.  <a href="#ac61406c45d5607d5daa520201fc68017">More...</a><br /></td></tr>
<tr class="separator:ac61406c45d5607d5daa520201fc68017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da275ce705622f8de8aa9d7dda478a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a78da275ce705622f8de8aa9d7dda478a">getEmissive</a> (void) const </td></tr>
<tr class="memdesc:a78da275ce705622f8de8aa9d7dda478a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the self illumination colour of the pass.  <a href="#a78da275ce705622f8de8aa9d7dda478a">More...</a><br /></td></tr>
<tr class="separator:a78da275ce705622f8de8aa9d7dda478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6da762323ae84db14a8d9f1822258d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5f6da762323ae84db14a8d9f1822258d">getFogColour</a> (void) const </td></tr>
<tr class="memdesc:a5f6da762323ae84db14a8d9f1822258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog colour for the scene.  <a href="#a5f6da762323ae84db14a8d9f1822258d">More...</a><br /></td></tr>
<tr class="separator:a5f6da762323ae84db14a8d9f1822258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868dd63ed8c6686380ed980b6e7e3e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a868dd63ed8c6686380ed980b6e7e3e09">getFogDensity</a> (void) const </td></tr>
<tr class="memdesc:a868dd63ed8c6686380ed980b6e7e3e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog density for this pass.  <a href="#a868dd63ed8c6686380ed980b6e7e3e09">More...</a><br /></td></tr>
<tr class="separator:a868dd63ed8c6686380ed980b6e7e3e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d67be7f381d514050e1867e6908dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac8d67be7f381d514050e1867e6908dc9">getFogEnd</a> (void) const </td></tr>
<tr class="memdesc:ac8d67be7f381d514050e1867e6908dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog end distance for this pass.  <a href="#ac8d67be7f381d514050e1867e6908dc9">More...</a><br /></td></tr>
<tr class="separator:ac8d67be7f381d514050e1867e6908dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0410b3dda0527e550862253ebf8a6dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0410b3dda0527e550862253ebf8a6dac">getFogMode</a> (void) const </td></tr>
<tr class="memdesc:a0410b3dda0527e550862253ebf8a6dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog mode for this pass.  <a href="#a0410b3dda0527e550862253ebf8a6dac">More...</a><br /></td></tr>
<tr class="separator:a0410b3dda0527e550862253ebf8a6dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a60fca163ceff1ef34cf08d6a3f50c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad4a60fca163ceff1ef34cf08d6a3f50c">getFogOverride</a> (void) const </td></tr>
<tr class="memdesc:ad4a60fca163ceff1ef34cf08d6a3f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass is to override the scene fog settings.  <a href="#ad4a60fca163ceff1ef34cf08d6a3f50c">More...</a><br /></td></tr>
<tr class="separator:ad4a60fca163ceff1ef34cf08d6a3f50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e996bfaad96bda9db001b9e5fe352b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4e996bfaad96bda9db001b9e5fe352b1">getFogStart</a> (void) const </td></tr>
<tr class="memdesc:a4e996bfaad96bda9db001b9e5fe352b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fog start distance for this pass.  <a href="#a4e996bfaad96bda9db001b9e5fe352b1">More...</a><br /></td></tr>
<tr class="separator:a4e996bfaad96bda9db001b9e5fe352b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413bb7b107190cdd6b69c141d3c10160"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a413bb7b107190cdd6b69c141d3c10160">getFragmentProgram</a> (void) const </td></tr>
<tr class="memdesc:a413bb7b107190cdd6b69c141d3c10160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fragment program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#a413bb7b107190cdd6b69c141d3c10160">More...</a><br /></td></tr>
<tr class="separator:a413bb7b107190cdd6b69c141d3c10160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a7fe0395b6d5224b83db0f764ced19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af8a7fe0395b6d5224b83db0f764ced19">getFragmentProgramName</a> (void) const </td></tr>
<tr class="memdesc:af8a7fe0395b6d5224b83db0f764ced19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the fragment program used by this pass.  <a href="#af8a7fe0395b6d5224b83db0f764ced19">More...</a><br /></td></tr>
<tr class="separator:af8a7fe0395b6d5224b83db0f764ced19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625a7d756b38b5da1d92b292e3fd1aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a625a7d756b38b5da1d92b292e3fd1aee">getFragmentProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:a625a7d756b38b5da1d92b292e3fd1aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fragment program parameters used by this pass.  <a href="#a625a7d756b38b5da1d92b292e3fd1aee">More...</a><br /></td></tr>
<tr class="separator:a625a7d756b38b5da1d92b292e3fd1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a29d0d100a0ee69b8e9d441f4d73b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#add6a29d0d100a0ee69b8e9d441f4d73b">getGeometryProgram</a> (void) const </td></tr>
<tr class="memdesc:add6a29d0d100a0ee69b8e9d441f4d73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the geometry program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#add6a29d0d100a0ee69b8e9d441f4d73b">More...</a><br /></td></tr>
<tr class="separator:add6a29d0d100a0ee69b8e9d441f4d73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86406f92d7137ca097fb1dd777810dfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a86406f92d7137ca097fb1dd777810dfd">getGeometryProgramName</a> (void) const </td></tr>
<tr class="memdesc:a86406f92d7137ca097fb1dd777810dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the geometry program used by this pass.  <a href="#a86406f92d7137ca097fb1dd777810dfd">More...</a><br /></td></tr>
<tr class="separator:a86406f92d7137ca097fb1dd777810dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43cbc80e2cfa8f2d20aff9fc7c5655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aec43cbc80e2cfa8f2d20aff9fc7c5655">getGeometryProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:aec43cbc80e2cfa8f2d20aff9fc7c5655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the geometry program parameters used by this pass.  <a href="#aec43cbc80e2cfa8f2d20aff9fc7c5655">More...</a><br /></td></tr>
<tr class="separator:aec43cbc80e2cfa8f2d20aff9fc7c5655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71369c583a07daba7cd8dd1d0bc9a281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a71369c583a07daba7cd8dd1d0bc9a281">getId</a> (void) const </td></tr>
<tr class="separator:a71369c583a07daba7cd8dd1d0bc9a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ad34ba288321b9f7d9031ccf6fc3a8"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab6ad34ba288321b9f7d9031ccf6fc3a8">getIndex</a> (void) const </td></tr>
<tr class="memdesc:ab6ad34ba288321b9f7d9031ccf6fc3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> in the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a>.  <a href="#ab6ad34ba288321b9f7d9031ccf6fc3a8">More...</a><br /></td></tr>
<tr class="separator:ab6ad34ba288321b9f7d9031ccf6fc3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06e90ff9a42071983e2cec06783774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acb06e90ff9a42071983e2cec06783774">getIteratePerLight</a> (void) const </td></tr>
<tr class="memdesc:acb06e90ff9a42071983e2cec06783774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this pass run once for every light in range?  <a href="#acb06e90ff9a42071983e2cec06783774">More...</a><br /></td></tr>
<tr class="separator:acb06e90ff9a42071983e2cec06783774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd4b083effc0511e550955f53659aef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#affd4b083effc0511e550955f53659aef">getLightClipPlanesEnabled</a> () const </td></tr>
<tr class="memdesc:affd4b083effc0511e550955f53659aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light.  <a href="#affd4b083effc0511e550955f53659aef">More...</a><br /></td></tr>
<tr class="separator:affd4b083effc0511e550955f53659aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789fe5bdf561ccabea75fc9d0a1dbd63"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a789fe5bdf561ccabea75fc9d0a1dbd63">getLightCountPerIteration</a> (void) const </td></tr>
<tr class="memdesc:a789fe5bdf561ccabea75fc9d0a1dbd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">If light iteration is enabled, determine the number of lights per iteration.  <a href="#a789fe5bdf561ccabea75fc9d0a1dbd63">More...</a><br /></td></tr>
<tr class="separator:a789fe5bdf561ccabea75fc9d0a1dbd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea03fb8b8fad8504346f6e9c4a30f9ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aea03fb8b8fad8504346f6e9c4a30f9ff">getLightMask</a> () const </td></tr>
<tr class="memdesc:aea03fb8b8fad8504346f6e9c4a30f9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the light mask controlling which lights are used for this pass.  <a href="#aea03fb8b8fad8504346f6e9c4a30f9ff">More...</a><br /></td></tr>
<tr class="separator:aea03fb8b8fad8504346f6e9c4a30f9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0252ab0ac2998ba0f8fa18028d4d6db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad0252ab0ac2998ba0f8fa18028d4d6db">getLightScissoringEnabled</a> () const </td></tr>
<tr class="memdesc:ad0252ab0ac2998ba0f8fa18028d4d6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it.  <a href="#ad0252ab0ac2998ba0f8fa18028d4d6db">More...</a><br /></td></tr>
<tr class="separator:ad0252ab0ac2998ba0f8fa18028d4d6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4e8693b6e574a536786753a140bac9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4c4e8693b6e574a536786753a140bac9">getMacroblock</a> (void) const </td></tr>
<tr class="memdesc:a4c4e8693b6e574a536786753a140bac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves current macroblock.  <a href="#a4c4e8693b6e574a536786753a140bac9">More...</a><br /></td></tr>
<tr class="separator:a4c4e8693b6e574a536786753a140bac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c90a998e60c3d1eaed4a9523cb11adf"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7c90a998e60c3d1eaed4a9523cb11adf">getMaxSimultaneousLights</a> (void) const </td></tr>
<tr class="memdesc:a7c90a998e60c3d1eaed4a9523cb11adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of lights to be used by this pass.  <a href="#a7c90a998e60c3d1eaed4a9523cb11adf">More...</a><br /></td></tr>
<tr class="separator:a7c90a998e60c3d1eaed4a9523cb11adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1bab83b1dcd5a269cac346a2d8c994"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4c1bab83b1dcd5a269cac346a2d8c994">getName</a> (void) const </td></tr>
<tr class="memdesc:a4c1bab83b1dcd5a269cac346a2d8c994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the pass.  <a href="#a4c1bab83b1dcd5a269cac346a2d8c994">More...</a><br /></td></tr>
<tr class="separator:a4c1bab83b1dcd5a269cac346a2d8c994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d66752be7a7c539bd885ca212e096"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a873d66752be7a7c539bd885ca212e096">getNumShadowContentTextures</a> (void) const </td></tr>
<tr class="separator:a873d66752be7a7c539bd885ca212e096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89e46903cc53d61ca5b9e8188ff686"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7e89e46903cc53d61ca5b9e8188ff686">getNumTextureUnitStates</a> (void) const </td></tr>
<tr class="memdesc:a7e89e46903cc53d61ca5b9e8188ff686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of texture unit settings.  <a href="#a7e89e46903cc53d61ca5b9e8188ff686">More...</a><br /></td></tr>
<tr class="separator:a7e89e46903cc53d61ca5b9e8188ff686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9fa78852454ce5c6a5f643500b09b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acf9fa78852454ce5c6a5f643500b09b3">getOnlyLightType</a> () const </td></tr>
<tr class="memdesc:acf9fa78852454ce5c6a5f643500b09b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true.  <a href="#acf9fa78852454ce5c6a5f643500b09b3">More...</a><br /></td></tr>
<tr class="separator:acf9fa78852454ce5c6a5f643500b09b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b545806ee7b84dffb51a3ffb565c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a46b545806ee7b84dffb51a3ffb565c08">getParent</a> (void) const </td></tr>
<tr class="memdesc:a46b545806ee7b84dffb51a3ffb565c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a>.  <a href="#a46b545806ee7b84dffb51a3ffb565c08">More...</a><br /></td></tr>
<tr class="separator:a46b545806ee7b84dffb51a3ffb565c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74b47051c90b6773e5b011a675ca996"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad74b47051c90b6773e5b011a675ca996">getPassIterationCount</a> (void) const </td></tr>
<tr class="memdesc:ad74b47051c90b6773e5b011a675ca996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pass iteration count value.  <a href="#ad74b47051c90b6773e5b011a675ca996">More...</a><br /></td></tr>
<tr class="separator:ad74b47051c90b6773e5b011a675ca996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35805ebc35dfc915729d442d1d70442b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a35805ebc35dfc915729d442d1d70442b">getPointAttenuationConstant</a> (void) const </td></tr>
<tr class="memdesc:a35805ebc35dfc915729d442d1d70442b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant coefficient of point attenuation.  <a href="#a35805ebc35dfc915729d442d1d70442b">More...</a><br /></td></tr>
<tr class="separator:a35805ebc35dfc915729d442d1d70442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e91fc3b2024b5e0b025179f7711c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae5e91fc3b2024b5e0b025179f7711c6c">getPointAttenuationLinear</a> (void) const </td></tr>
<tr class="memdesc:ae5e91fc3b2024b5e0b025179f7711c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linear coefficient of point attenuation.  <a href="#ae5e91fc3b2024b5e0b025179f7711c6c">More...</a><br /></td></tr>
<tr class="separator:ae5e91fc3b2024b5e0b025179f7711c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b1c78d6e3553aa27590076389b347a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a10b1c78d6e3553aa27590076389b347a">getPointAttenuationQuadratic</a> (void) const </td></tr>
<tr class="memdesc:a10b1c78d6e3553aa27590076389b347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quadratic coefficient of point attenuation.  <a href="#a10b1c78d6e3553aa27590076389b347a">More...</a><br /></td></tr>
<tr class="separator:a10b1c78d6e3553aa27590076389b347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb506f7545bcd3715885571645807e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aceb506f7545bcd3715885571645807e7">getPointMaxSize</a> (void) const </td></tr>
<tr class="memdesc:aceb506f7545bcd3715885571645807e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum point size, when point attenuation is in use.  <a href="#aceb506f7545bcd3715885571645807e7">More...</a><br /></td></tr>
<tr class="separator:aceb506f7545bcd3715885571645807e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168c2016fbaebb4bccd6dfe28f77367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae168c2016fbaebb4bccd6dfe28f77367">getPointMinSize</a> (void) const </td></tr>
<tr class="memdesc:ae168c2016fbaebb4bccd6dfe28f77367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum point size, when point attenuation is in use.  <a href="#ae168c2016fbaebb4bccd6dfe28f77367">More...</a><br /></td></tr>
<tr class="separator:ae168c2016fbaebb4bccd6dfe28f77367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7832e2916a8c7ebc9d20a273bafdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acc7832e2916a8c7ebc9d20a273bafdbc">getPointSize</a> (void) const </td></tr>
<tr class="memdesc:acc7832e2916a8c7ebc9d20a273bafdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the point size of the pass.  <a href="#acc7832e2916a8c7ebc9d20a273bafdbc">More...</a><br /></td></tr>
<tr class="separator:acc7832e2916a8c7ebc9d20a273bafdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a53a2302b81e9b5cd5a6d9e1c52d908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7a53a2302b81e9b5cd5a6d9e1c52d908">getPointSpritesEnabled</a> (void) const </td></tr>
<tr class="memdesc:a7a53a2302b81e9b5cd5a6d9e1c52d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether point sprites are enabled when rendering a point list.  <a href="#a7a53a2302b81e9b5cd5a6d9e1c52d908">More...</a><br /></td></tr>
<tr class="separator:a7a53a2302b81e9b5cd5a6d9e1c52d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c184b1908a08f07969d5caf6859945c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9c184b1908a08f07969d5caf6859945c">getPolygonModeOverrideable</a> (void) const </td></tr>
<tr class="memdesc:a9c184b1908a08f07969d5caf6859945c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting.  <a href="#a9c184b1908a08f07969d5caf6859945c">More...</a><br /></td></tr>
<tr class="separator:a9c184b1908a08f07969d5caf6859945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3373fad544ff5f6840c2337f4812e0d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad3373fad544ff5f6840c2337f4812e0d">getResourceGroup</a> (void) const </td></tr>
<tr class="memdesc:ad3373fad544ff5f6840c2337f4812e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a>.  <a href="#ad3373fad544ff5f6840c2337f4812e0d">More...</a><br /></td></tr>
<tr class="separator:ad3373fad544ff5f6840c2337f4812e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7ca18b8282a1551d5be1ed3d34f349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4b7ca18b8282a1551d5be1ed3d34f349">getRunOnlyForOneLightType</a> (void) const </td></tr>
<tr class="memdesc:a4b7ca18b8282a1551d5be1ed3d34f349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this pass run only for a single light type (if getIteratePerLight is true).  <a href="#a4b7ca18b8282a1551d5be1ed3d34f349">More...</a><br /></td></tr>
<tr class="separator:a4b7ca18b8282a1551d5be1ed3d34f349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1036ac655e74599a66239c16e69c84ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1036ac655e74599a66239c16e69c84ab">getSelfIllumination</a> (void) const </td></tr>
<tr class="memdesc:a1036ac655e74599a66239c16e69c84ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the self illumination colour of the pass.  <a href="#a1036ac655e74599a66239c16e69c84ab">More...</a><br /></td></tr>
<tr class="separator:a1036ac655e74599a66239c16e69c84ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6a77e4c0a208484a9fb7e81654d514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9c6a77e4c0a208484a9fb7e81654d514">getShadingMode</a> (void) const </td></tr>
<tr class="memdesc:a9c6a77e4c0a208484a9fb7e81654d514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of light shading to be used.  <a href="#a9c6a77e4c0a208484a9fb7e81654d514">More...</a><br /></td></tr>
<tr class="separator:a9c6a77e4c0a208484a9fb7e81654d514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b44393b5211966e8f1f2f3c9188a185"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4b44393b5211966e8f1f2f3c9188a185">getShadowCasterFragmentProgram</a> (void) const </td></tr>
<tr class="memdesc:a4b44393b5211966e8f1f2f3c9188a185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fragment program used by this pass when rendering shadow casters, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#a4b44393b5211966e8f1f2f3c9188a185">More...</a><br /></td></tr>
<tr class="separator:a4b44393b5211966e8f1f2f3c9188a185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d57144e465a6584ae1e4f72e6ded39d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2d57144e465a6584ae1e4f72e6ded39d">getShadowCasterFragmentProgramName</a> (void) const </td></tr>
<tr class="memdesc:a2d57144e465a6584ae1e4f72e6ded39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the fragment program used by this pass when rendering shadow casters.  <a href="#a2d57144e465a6584ae1e4f72e6ded39d">More...</a><br /></td></tr>
<tr class="separator:a2d57144e465a6584ae1e4f72e6ded39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0549cfe83a4d6f76187b9beeb5f97760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0549cfe83a4d6f76187b9beeb5f97760">getShadowCasterFragmentProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:a0549cfe83a4d6f76187b9beeb5f97760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fragment program parameters used by this pass when rendering shadow casters.  <a href="#a0549cfe83a4d6f76187b9beeb5f97760">More...</a><br /></td></tr>
<tr class="separator:a0549cfe83a4d6f76187b9beeb5f97760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2dd8f2c2957da4013eb6fc0b6e2e0d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0e2dd8f2c2957da4013eb6fc0b6e2e0d">getShadowCasterVertexProgram</a> (void) const </td></tr>
<tr class="memdesc:a0e2dd8f2c2957da4013eb6fc0b6e2e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex program used by this pass when rendering shadow casters, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#a0e2dd8f2c2957da4013eb6fc0b6e2e0d">More...</a><br /></td></tr>
<tr class="separator:a0e2dd8f2c2957da4013eb6fc0b6e2e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ae6dab78e22950a3fbf59774187c26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a12ae6dab78e22950a3fbf59774187c26">getShadowCasterVertexProgramName</a> (void) const </td></tr>
<tr class="memdesc:a12ae6dab78e22950a3fbf59774187c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the vertex program used by this pass when rendering shadow casters.  <a href="#a12ae6dab78e22950a3fbf59774187c26">More...</a><br /></td></tr>
<tr class="separator:a12ae6dab78e22950a3fbf59774187c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c93f7897b4a5f72ec007c0fa98587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aaa7c93f7897b4a5f72ec007c0fa98587">getShadowCasterVertexProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:aaa7c93f7897b4a5f72ec007c0fa98587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex program parameters used by this pass when rendering shadow casters.  <a href="#aaa7c93f7897b4a5f72ec007c0fa98587">More...</a><br /></td></tr>
<tr class="separator:aaa7c93f7897b4a5f72ec007c0fa98587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7891bdca3a4f1e1c73a1d40c0ec7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8be7891bdca3a4f1e1c73a1d40c0ec7a">getShininess</a> (void) const </td></tr>
<tr class="memdesc:a8be7891bdca3a4f1e1c73a1d40c0ec7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'shininess' property of the pass (affects specular highlights).  <a href="#a8be7891bdca3a4f1e1c73a1d40c0ec7a">More...</a><br /></td></tr>
<tr class="separator:a8be7891bdca3a4f1e1c73a1d40c0ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814c79f09b87acee854dae6fb63e8fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a7814c79f09b87acee854dae6fb63e8fb">getSpecular</a> (void) const </td></tr>
<tr class="memdesc:a7814c79f09b87acee854dae6fb63e8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specular colour reflectance of the pass.  <a href="#a7814c79f09b87acee854dae6fb63e8fb">More...</a><br /></td></tr>
<tr class="separator:a7814c79f09b87acee854dae6fb63e8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484603c72ec5a3e8c7d5a1b50e3c05ca"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a484603c72ec5a3e8c7d5a1b50e3c05ca">getStartLight</a> (void) const </td></tr>
<tr class="memdesc:a484603c72ec5a3e8c7d5a1b50e3c05ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the light index that this pass will start at in the light list.  <a href="#a484603c72ec5a3e8c7d5a1b50e3c05ca">More...</a><br /></td></tr>
<tr class="separator:a484603c72ec5a3e8c7d5a1b50e3c05ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ecb09c015f59aeccbde4cfd0c103b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af05ecb09c015f59aeccbde4cfd0c103b">getTessellationDomainProgram</a> (void) const </td></tr>
<tr class="memdesc:af05ecb09c015f59aeccbde4cfd0c103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation Domain program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#af05ecb09c015f59aeccbde4cfd0c103b">More...</a><br /></td></tr>
<tr class="separator:af05ecb09c015f59aeccbde4cfd0c103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db533f22819aa01b4ff103bf43602f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5db533f22819aa01b4ff103bf43602f0">getTessellationDomainProgramName</a> (void) const </td></tr>
<tr class="memdesc:a5db533f22819aa01b4ff103bf43602f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the Domain Evaluation program used by this pass.  <a href="#a5db533f22819aa01b4ff103bf43602f0">More...</a><br /></td></tr>
<tr class="separator:a5db533f22819aa01b4ff103bf43602f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f9468178cfd643fe3292318a4d416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1e5f9468178cfd643fe3292318a4d416">getTessellationDomainProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:a1e5f9468178cfd643fe3292318a4d416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation Domain program parameters used by this pass.  <a href="#a1e5f9468178cfd643fe3292318a4d416">More...</a><br /></td></tr>
<tr class="separator:a1e5f9468178cfd643fe3292318a4d416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd57734bb36ee508d4e1c6ea71a1f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab5fd57734bb36ee508d4e1c6ea71a1f4">getTessellationHullProgram</a> (void) const </td></tr>
<tr class="memdesc:ab5fd57734bb36ee508d4e1c6ea71a1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation Hull program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#ab5fd57734bb36ee508d4e1c6ea71a1f4">More...</a><br /></td></tr>
<tr class="separator:ab5fd57734bb36ee508d4e1c6ea71a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789d5674ef33d77dadac65e0103c2437"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a789d5674ef33d77dadac65e0103c2437">getTessellationHullProgramName</a> (void) const </td></tr>
<tr class="memdesc:a789d5674ef33d77dadac65e0103c2437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the Tessellation Hull program used by this pass.  <a href="#a789d5674ef33d77dadac65e0103c2437">More...</a><br /></td></tr>
<tr class="separator:a789d5674ef33d77dadac65e0103c2437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f35a1ef70651fbf82be2fb8b4147d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa8f35a1ef70651fbf82be2fb8b4147d7">getTessellationHullProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:aa8f35a1ef70651fbf82be2fb8b4147d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tessellation Hull program parameters used by this pass.  <a href="#aa8f35a1ef70651fbf82be2fb8b4147d7">More...</a><br /></td></tr>
<tr class="separator:aa8f35a1ef70651fbf82be2fb8b4147d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52268fc31d523258f3edc90a3d17cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac52268fc31d523258f3edc90a3d17cb1">getTextureUnitState</a> (size_t index)</td></tr>
<tr class="memdesc:ac52268fc31d523258f3edc90a3d17cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to a texture unit state so it may be modified.  <a href="#ac52268fc31d523258f3edc90a3d17cb1">More...</a><br /></td></tr>
<tr class="separator:ac52268fc31d523258f3edc90a3d17cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b1b021da5a9e64fa4923845663eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae27b1b021da5a9e64fa4923845663eb1">getTextureUnitState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:ae27b1b021da5a9e64fa4923845663eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State matching name.  <a href="#ae27b1b021da5a9e64fa4923845663eb1">More...</a><br /></td></tr>
<tr class="separator:ae27b1b021da5a9e64fa4923845663eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88dcdf45a83617610bd7697101c04cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac88dcdf45a83617610bd7697101c04cc">getTextureUnitState</a> (size_t index) const </td></tr>
<tr class="memdesc:ac88dcdf45a83617610bd7697101c04cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a const pointer to a texture unit state.  <a href="#ac88dcdf45a83617610bd7697101c04cc">More...</a><br /></td></tr>
<tr class="separator:ac88dcdf45a83617610bd7697101c04cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b054578bb23bcbb9a8bd9c2de8c718"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af6b054578bb23bcbb9a8bd9c2de8c718">getTextureUnitState</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>
<tr class="memdesc:af6b054578bb23bcbb9a8bd9c2de8c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State matching name.  <a href="#af6b054578bb23bcbb9a8bd9c2de8c718">More...</a><br /></td></tr>
<tr class="separator:af6b054578bb23bcbb9a8bd9c2de8c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac1aab7513931a4a30ed8eed33ca79"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a08ac1aab7513931a4a30ed8eed33ca79">getTextureUnitStateIndex</a> (const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *state) const </td></tr>
<tr class="memdesc:a08ac1aab7513931a4a30ed8eed33ca79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State in the pass.  <a href="#a08ac1aab7513931a4a30ed8eed33ca79">More...</a><br /></td></tr>
<tr class="separator:a08ac1aab7513931a4a30ed8eed33ca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1513f6d3e1acb9037225d826ec99856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ac1513f6d3e1acb9037225d826ec99856">getTextureUnitStateIterator</a> (void)</td></tr>
<tr class="memdesc:ac1513f6d3e1acb9037225d826ec99856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>.  <a href="#ac1513f6d3e1acb9037225d826ec99856">More...</a><br /></td></tr>
<tr class="separator:ac1513f6d3e1acb9037225d826ec99856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fe292a1acabbc73420e9d26af51f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a93fe292a1acabbc73420e9d26af51f81">getTextureUnitStateIterator</a> (void) const </td></tr>
<tr class="memdesc:a93fe292a1acabbc73420e9d26af51f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>.  <a href="#a93fe292a1acabbc73420e9d26af51f81">More...</a><br /></td></tr>
<tr class="separator:a93fe292a1acabbc73420e9d26af51f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adc70de42e8b22b4d8ccedf6868bbbfc0">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#adc70de42e8b22b4d8ccedf6868bbbfc0">More...</a><br /></td></tr>
<tr class="separator:adc70de42e8b22b4d8ccedf6868bbbfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e0bc742536372c9eb21ba6a3e0f0a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a78e0bc742536372c9eb21ba6a3e0f0a8">getUserObjectBindings</a> () const </td></tr>
<tr class="memdesc:a78e0bc742536372c9eb21ba6a3e0f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#a78e0bc742536372c9eb21ba6a3e0f0a8">More...</a><br /></td></tr>
<tr class="separator:a78e0bc742536372c9eb21ba6a3e0f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad375f519587608ca2f0f5fa8d6801182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad375f519587608ca2f0f5fa8d6801182">getVertexColourTracking</a> (void) const </td></tr>
<tr class="memdesc:ad375f519587608ca2f0f5fa8d6801182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which material properties follow the vertex colour.  <a href="#ad375f519587608ca2f0f5fa8d6801182">More...</a><br /></td></tr>
<tr class="separator:ad375f519587608ca2f0f5fa8d6801182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dff1afc5d9b683bbac058e1c5cdfe3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa2dff1afc5d9b683bbac058e1c5cdfe3">getVertexProgram</a> (void) const </td></tr>
<tr class="memdesc:aa2dff1afc5d9b683bbac058e1c5cdfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>.  <a href="#aa2dff1afc5d9b683bbac058e1c5cdfe3">More...</a><br /></td></tr>
<tr class="separator:aa2dff1afc5d9b683bbac058e1c5cdfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cff7e78e08931da9135a42983dafcb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a49cff7e78e08931da9135a42983dafcb">getVertexProgramName</a> (void) const </td></tr>
<tr class="memdesc:a49cff7e78e08931da9135a42983dafcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the vertex program used by this pass.  <a href="#a49cff7e78e08931da9135a42983dafcb">More...</a><br /></td></tr>
<tr class="separator:a49cff7e78e08931da9135a42983dafcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51690f7442dcbf4882331226f75967bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a51690f7442dcbf4882331226f75967bc">getVertexProgramParameters</a> (void) const </td></tr>
<tr class="memdesc:a51690f7442dcbf4882331226f75967bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex program parameters used by this pass.  <a href="#a51690f7442dcbf4882331226f75967bc">More...</a><br /></td></tr>
<tr class="separator:a51690f7442dcbf4882331226f75967bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617cec627a54e8b14ad3d610a373448a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a617cec627a54e8b14ad3d610a373448a">hasComputeProgram</a> (void) const </td></tr>
<tr class="memdesc:a617cec627a54e8b14ad3d610a373448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable compute pipeline.  <a href="#a617cec627a54e8b14ad3d610a373448a">More...</a><br /></td></tr>
<tr class="separator:a617cec627a54e8b14ad3d610a373448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf37cc807e158f8aaf15acfb84806627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#acf37cc807e158f8aaf15acfb84806627">hasFragmentProgram</a> (void) const </td></tr>
<tr class="memdesc:acf37cc807e158f8aaf15acfb84806627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable fragment pipeline.  <a href="#acf37cc807e158f8aaf15acfb84806627">More...</a><br /></td></tr>
<tr class="separator:acf37cc807e158f8aaf15acfb84806627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f21234060f157c80a2f862bd90662"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4f8f21234060f157c80a2f862bd90662">hasGeometryProgram</a> (void) const </td></tr>
<tr class="memdesc:a4f8f21234060f157c80a2f862bd90662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable geometry pipeline.  <a href="#a4f8f21234060f157c80a2f862bd90662">More...</a><br /></td></tr>
<tr class="separator:a4f8f21234060f157c80a2f862bd90662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaac78cbe658094a058179781268a4b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#adaac78cbe658094a058179781268a4b5">hasShadowCasterFragmentProgram</a> (void) const </td></tr>
<tr class="memdesc:adaac78cbe658094a058179781268a4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a shadow caster fragment program.  <a href="#adaac78cbe658094a058179781268a4b5">More...</a><br /></td></tr>
<tr class="separator:adaac78cbe658094a058179781268a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748683e8b6877b9b958ccf094cff69f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a748683e8b6877b9b958ccf094cff69f6">hasShadowCasterVertexProgram</a> (void) const </td></tr>
<tr class="memdesc:a748683e8b6877b9b958ccf094cff69f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a shadow caster vertex program.  <a href="#a748683e8b6877b9b958ccf094cff69f6">More...</a><br /></td></tr>
<tr class="separator:a748683e8b6877b9b958ccf094cff69f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dea10bb1286bbe47d94a24b2eacd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a672dea10bb1286bbe47d94a24b2eacd9">hasTessellationDomainProgram</a> (void) const </td></tr>
<tr class="memdesc:a672dea10bb1286bbe47d94a24b2eacd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable tessellation control pipeline.  <a href="#a672dea10bb1286bbe47d94a24b2eacd9">More...</a><br /></td></tr>
<tr class="separator:a672dea10bb1286bbe47d94a24b2eacd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1820feccdfd3bbb4866ac7a3a915d70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a1820feccdfd3bbb4866ac7a3a915d70d">hasTessellationHullProgram</a> (void) const </td></tr>
<tr class="memdesc:a1820feccdfd3bbb4866ac7a3a915d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable tessellation control pipeline.  <a href="#a1820feccdfd3bbb4866ac7a3a915d70d">More...</a><br /></td></tr>
<tr class="separator:a1820feccdfd3bbb4866ac7a3a915d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643c9431fa2abe9ceb406804e26ad0d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a643c9431fa2abe9ceb406804e26ad0d7">hasVertexProgram</a> (void) const </td></tr>
<tr class="memdesc:a643c9431fa2abe9ceb406804e26ad0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass uses a programmable vertex pipeline.  <a href="#a643c9431fa2abe9ceb406804e26ad0d7">More...</a><br /></td></tr>
<tr class="separator:a643c9431fa2abe9ceb406804e26ad0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abd637e95e2aeaea9a984151b082e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4abd637e95e2aeaea9a984151b082e3e">insertShadowContentTypeLookup</a> (size_t textureUnitIndex)</td></tr>
<tr class="memdesc:a4abd637e95e2aeaea9a984151b082e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when a texture unit changed to type CONTENT_SHADOW.  <a href="#a4abd637e95e2aeaea9a984151b082e3e">More...</a><br /></td></tr>
<tr class="separator:a4abd637e95e2aeaea9a984151b082e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee9a442132cdf8e5c7a5f3216008a4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4ee9a442132cdf8e5c7a5f3216008a4d">isAmbientOnly</a> (void) const </td></tr>
<tr class="memdesc:a4ee9a442132cdf8e5c7a5f3216008a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this pass is ambient only.  <a href="#a4ee9a442132cdf8e5c7a5f3216008a4d">More...</a><br /></td></tr>
<tr class="separator:a4ee9a442132cdf8e5c7a5f3216008a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb68ecae89e2a7e903f764247c1f929"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5cb68ecae89e2a7e903f764247c1f929">isLoaded</a> (void) const </td></tr>
<tr class="memdesc:a5cb68ecae89e2a7e903f764247c1f929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this loaded?  <a href="#a5cb68ecae89e2a7e903f764247c1f929">More...</a><br /></td></tr>
<tr class="separator:a5cb68ecae89e2a7e903f764247c1f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ca66e7e3579369aa3f90c3059aea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a426ca66e7e3579369aa3f90c3059aea2">isPointAttenuationEnabled</a> (void) const </td></tr>
<tr class="memdesc:a426ca66e7e3579369aa3f90c3059aea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether points are attenuated with distance.  <a href="#a426ca66e7e3579369aa3f90c3059aea2">More...</a><br /></td></tr>
<tr class="separator:a426ca66e7e3579369aa3f90c3059aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9108164d08798980dc27282431357ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae9108164d08798980dc27282431357ff">isProgrammable</a> (void) const </td></tr>
<tr class="memdesc:ae9108164d08798980dc27282431357ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass is programmable i.e. includes either a vertex or fragment program.  <a href="#ae9108164d08798980dc27282431357ff">More...</a><br /></td></tr>
<tr class="separator:ae9108164d08798980dc27282431357ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88f92f66f97921515270a98421e9969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab88f92f66f97921515270a98421e9969">isTransparent</a> (void) const </td></tr>
<tr class="memdesc:ab88f92f66f97921515270a98421e9969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pass has some element of transparency.  <a href="#ab88f92f66f97921515270a98421e9969">More...</a><br /></td></tr>
<tr class="separator:ab88f92f66f97921515270a98421e9969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23f6b1ae56f9acdcb05f8cbcf0e9153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af23f6b1ae56f9acdcb05f8cbcf0e9153">OGRE_MUTEX</a> (mTexUnitChangeMutex)</td></tr>
<tr class="separator:af23f6b1ae56f9acdcb05f8cbcf0e9153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af180b9759ea13e557003abc84e594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab3af180b9759ea13e557003abc84e594">OGRE_MUTEX</a> (mGpuProgramChangeMutex)</td></tr>
<tr class="separator:ab3af180b9759ea13e557003abc84e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afa648bf34693a7b6c377e126da20f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a10afa648bf34693a7b6c377e126da20f">OGRE_STATIC_MUTEX</a> (msDirtyHashListMutex)</td></tr>
<tr class="separator:a10afa648bf34693a7b6c377e126da20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25733e77cd0b2f558d62e5a7ab7592e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab25733e77cd0b2f558d62e5a7ab7592e">OGRE_STATIC_MUTEX</a> (msPassGraveyardMutex)</td></tr>
<tr class="separator:ab25733e77cd0b2f558d62e5a7ab7592e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a15bb76abae180b60dfcf9a6e1fdcd8fe">operator=</a> (const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;oth)</td></tr>
<tr class="memdesc:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator = overload.  <a href="#a15bb76abae180b60dfcf9a6e1fdcd8fe">More...</a><br /></td></tr>
<tr class="separator:a15bb76abae180b60dfcf9a6e1fdcd8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7858343bd4fe24f8dadcf51eb6a601b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ab7858343bd4fe24f8dadcf51eb6a601b">recreateShadowContentTypeLookup</a> (void)</td></tr>
<tr class="memdesc:ab7858343bd4fe24f8dadcf51eb6a601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreates the contents of mShadowContentTypeLookup from scratch.  <a href="#ab7858343bd4fe24f8dadcf51eb6a601b">More...</a><br /></td></tr>
<tr class="separator:ab7858343bd4fe24f8dadcf51eb6a601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de1842654eb89c6f48785d02f07688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a86de1842654eb89c6f48785d02f07688">removeAllTextureUnitStates</a> (void)</td></tr>
<tr class="memdesc:a86de1842654eb89c6f48785d02f07688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all texture unit settings.  <a href="#a86de1842654eb89c6f48785d02f07688">More...</a><br /></td></tr>
<tr class="separator:a86de1842654eb89c6f48785d02f07688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157feb20eee8d56cf504a0fce9064f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a157feb20eee8d56cf504a0fce9064f68">removeShadowContentTypeLookup</a> (size_t textureUnitIndex)</td></tr>
<tr class="memdesc:a157feb20eee8d56cf504a0fce9064f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when a texture unit is removed (any type), or when a tex unit that used to be of type CONTENT_SHADOW, no longer is.  <a href="#a157feb20eee8d56cf504a0fce9064f68">More...</a><br /></td></tr>
<tr class="separator:a157feb20eee8d56cf504a0fce9064f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66085d80b0caa39850216b603cec40b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a66085d80b0caa39850216b603cec40b1">removeTextureUnitState</a> (unsigned short index)</td></tr>
<tr class="memdesc:a66085d80b0caa39850216b603cec40b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the indexed texture unit state from this pass.  <a href="#a66085d80b0caa39850216b603cec40b1">More...</a><br /></td></tr>
<tr class="separator:a66085d80b0caa39850216b603cec40b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23af59e5f991f22a224f8e6b336af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4f23af59e5f991f22a224f8e6b336af3">setAlphaRejectFunction</a> (<a class="el" href="group___general.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func)</td></tr>
<tr class="memdesc:a4f23af59e5f991f22a224f8e6b336af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the alpha reject function.  <a href="#a4f23af59e5f991f22a224f8e6b336af3">More...</a><br /></td></tr>
<tr class="separator:a4f23af59e5f991f22a224f8e6b336af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c5f69be78ddd80cbb202f66649fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6e5c5f69be78ddd80cbb202f66649fef">setAlphaRejectValue</a> (unsigned char val)</td></tr>
<tr class="memdesc:a6e5c5f69be78ddd80cbb202f66649fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the alpha reject value.  <a href="#a6e5c5f69be78ddd80cbb202f66649fef">More...</a><br /></td></tr>
<tr class="separator:a6e5c5f69be78ddd80cbb202f66649fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606695927fbf85ee64c361abf66ac10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a606695927fbf85ee64c361abf66ac10e">setAmbient</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>
<tr class="memdesc:a606695927fbf85ee64c361abf66ac10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient colour reflectance properties of this pass.  <a href="#a606695927fbf85ee64c361abf66ac10e">More...</a><br /></td></tr>
<tr class="separator:a606695927fbf85ee64c361abf66ac10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#abdcffe5cb7cee6c8c5a5fd4c2f75164d">setAmbient</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;ambient)</td></tr>
<tr class="memdesc:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient colour reflectance properties of this pass.  <a href="#abdcffe5cb7cee6c8c5a5fd4c2f75164d">More...</a><br /></td></tr>
<tr class="separator:abdcffe5cb7cee6c8c5a5fd4c2f75164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4beb20133aa0aa27cbb6877e42fa094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad4beb20133aa0aa27cbb6877e42fa094">setBlendblock</a> (const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;blendblock)</td></tr>
<tr class="memdesc:ad4beb20133aa0aa27cbb6877e42fa094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current blendblock for a new one. Pointer can't be null.  <a href="#ad4beb20133aa0aa27cbb6877e42fa094">More...</a><br /></td></tr>
<tr class="separator:ad4beb20133aa0aa27cbb6877e42fa094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97deab966da4653d248875782b45a3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a97deab966da4653d248875782b45a3f1">setComputeProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a97deab966da4653d248875782b45a3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the compute program to use.  <a href="#a97deab966da4653d248875782b45a3f1">More...</a><br /></td></tr>
<tr class="separator:a97deab966da4653d248875782b45a3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58bed2ac47d40e65750c61c0ca36af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad58bed2ac47d40e65750c61c0ca36af3">setComputeProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ad58bed2ac47d40e65750c61c0ca36af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Tessellation Evaluation program parameters.  <a href="#ad58bed2ac47d40e65750c61c0ca36af3">More...</a><br /></td></tr>
<tr class="separator:ad58bed2ac47d40e65750c61c0ca36af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae371bb189752872dfa2e02694f6841f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae371bb189752872dfa2e02694f6841f1">setDiffuse</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>
<tr class="memdesc:ae371bb189752872dfa2e02694f6841f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of this pass.  <a href="#ae371bb189752872dfa2e02694f6841f1">More...</a><br /></td></tr>
<tr class="separator:ae371bb189752872dfa2e02694f6841f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a67e3cb12113b4fc56b8d3d4cee03068a">setDiffuse</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;diffuse)</td></tr>
<tr class="memdesc:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of this pass.  <a href="#a67e3cb12113b4fc56b8d3d4cee03068a">More...</a><br /></td></tr>
<tr class="separator:a67e3cb12113b4fc56b8d3d4cee03068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e78b3e2c676ea2efc5de73826c980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aa23e78b3e2c676ea2efc5de73826c980">setEmissive</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>
<tr class="memdesc:aa23e78b3e2c676ea2efc5de73826c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="#aa23e78b3e2c676ea2efc5de73826c980">More...</a><br /></td></tr>
<tr class="separator:aa23e78b3e2c676ea2efc5de73826c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5653eb7430051fc4a81aa577c031186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae5653eb7430051fc4a81aa577c031186">setEmissive</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;emissive)</td></tr>
<tr class="memdesc:ae5653eb7430051fc4a81aa577c031186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="#ae5653eb7430051fc4a81aa577c031186">More...</a><br /></td></tr>
<tr class="separator:ae5653eb7430051fc4a81aa577c031186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b0cabffa642b0f3743ac5d82392a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a32b0cabffa642b0f3743ac5d82392a1d">setFog</a> (bool overrideScene, <a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=<a class="el" href="group___general.html#gga83edeb2e5d33a3ca8f15834ba40020baab7793a21880052c0214d4cc040992310">FOG_NONE</a>, const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour=<a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)</td></tr>
<tr class="memdesc:a32b0cabffa642b0f3743ac5d82392a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fogging mode applied to this pass.  <a href="#a32b0cabffa642b0f3743ac5d82392a1d">More...</a><br /></td></tr>
<tr class="separator:a32b0cabffa642b0f3743ac5d82392a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3019e308b0759cc150ac0f45308d69b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3019e308b0759cc150ac0f45308d69b3">setFragmentProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a3019e308b0759cc150ac0f45308d69b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the fragment program to use.  <a href="#a3019e308b0759cc150ac0f45308d69b3">More...</a><br /></td></tr>
<tr class="separator:a3019e308b0759cc150ac0f45308d69b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae8c6cd9d16220e8ef358f8b3e072d261">setFragmentProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fragment program parameters.  <a href="#ae8c6cd9d16220e8ef358f8b3e072d261">More...</a><br /></td></tr>
<tr class="separator:ae8c6cd9d16220e8ef358f8b3e072d261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2aab96fb146a8e92043c7dc771de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#af6b2aab96fb146a8e92043c7dc771de4">setGeometryProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:af6b2aab96fb146a8e92043c7dc771de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the geometry program to use.  <a href="#af6b2aab96fb146a8e92043c7dc771de4">More...</a><br /></td></tr>
<tr class="separator:af6b2aab96fb146a8e92043c7dc771de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd45b897ebc29d3ee40a2ee307682f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afd45b897ebc29d3ee40a2ee307682f35">setGeometryProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:afd45b897ebc29d3ee40a2ee307682f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the geometry program parameters.  <a href="#afd45b897ebc29d3ee40a2ee307682f35">More...</a><br /></td></tr>
<tr class="separator:afd45b897ebc29d3ee40a2ee307682f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aec98c9346a22a4a98acdaf5b8849a5c1">setIteratePerLight</a> (bool enabled, bool onlyForOneLightType=true, <a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> lightType=<a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f">Light::LT_POINT</a>)</td></tr>
<tr class="memdesc:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered.  <a href="#aec98c9346a22a4a98acdaf5b8849a5c1">More...</a><br /></td></tr>
<tr class="separator:aec98c9346a22a4a98acdaf5b8849a5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d94474787abfd9eb9b07d5185ded0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a20d94474787abfd9eb9b07d5185ded0c">setLightClipPlanesEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a20d94474787abfd9eb9b07d5185ded0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light.  <a href="#a20d94474787abfd9eb9b07d5185ded0c">More...</a><br /></td></tr>
<tr class="separator:a20d94474787abfd9eb9b07d5185ded0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0e40ca39a238f0afe5e2d3a0db0661ce">setLightCountPerIteration</a> (unsigned short c)</td></tr>
<tr class="memdesc:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">If light iteration is enabled, determine the number of lights per iteration.  <a href="#a0e40ca39a238f0afe5e2d3a0db0661ce">More...</a><br /></td></tr>
<tr class="separator:a0e40ca39a238f0afe5e2d3a0db0661ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f14ed26740158970994057e48e562e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9f14ed26740158970994057e48e562e9">setLightMask</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask)</td></tr>
<tr class="memdesc:a9f14ed26740158970994057e48e562e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the light mask which can be matched to specific light flags to be handled by this pass.  <a href="#a9f14ed26740158970994057e48e562e9">More...</a><br /></td></tr>
<tr class="separator:a9f14ed26740158970994057e48e562e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fe99447102afb8e2002f7f1339dd8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a26fe99447102afb8e2002f7f1339dd8c">setLightScissoringEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a26fe99447102afb8e2002f7f1339dd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it.  <a href="#a26fe99447102afb8e2002f7f1339dd8c">More...</a><br /></td></tr>
<tr class="separator:a26fe99447102afb8e2002f7f1339dd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed271a1cdee4c4f5c0f0404464f7e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a3ed271a1cdee4c4f5c0f0404464f7e69">setMacroblock</a> (const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;macroblock)</td></tr>
<tr class="memdesc:a3ed271a1cdee4c4f5c0f0404464f7e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current macroblock for a new one. Pointer can't be null.  <a href="#a3ed271a1cdee4c4f5c0f0404464f7e69">More...</a><br /></td></tr>
<tr class="separator:a3ed271a1cdee4c4f5c0f0404464f7e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a95a7a4006f26528ef4f6ce42ae56b09b">setMaxSimultaneousLights</a> (unsigned short maxLights)</td></tr>
<tr class="memdesc:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of lights to be used by this pass.  <a href="#a95a7a4006f26528ef4f6ce42ae56b09b">More...</a><br /></td></tr>
<tr class="separator:a95a7a4006f26528ef4f6ce42ae56b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03306f735122ec4e7d4c391f1528cf50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a03306f735122ec4e7d4c391f1528cf50">setName</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="separator:a03306f735122ec4e7d4c391f1528cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff8c16ee57201651da61e649ea216b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a28ff8c16ee57201651da61e649ea216b">setPassIterationCount</a> (const size_t count)</td></tr>
<tr class="memdesc:a28ff8c16ee57201651da61e649ea216b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the number of iterations that this pass should perform when doing fast multi pass operation.  <a href="#a28ff8c16ee57201651da61e649ea216b">More...</a><br /></td></tr>
<tr class="separator:a28ff8c16ee57201651da61e649ea216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d44f9c4a2e69fd31a4687ffe2b8335d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a0d44f9c4a2e69fd31a4687ffe2b8335d">setPointAttenuation</a> (bool enabled, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> constant=0.0f, Real linear=1.0f, Real quadratic=0.0f)</td></tr>
<tr class="memdesc:a0d44f9c4a2e69fd31a4687ffe2b8335d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how points are attenuated with distance.  <a href="#a0d44f9c4a2e69fd31a4687ffe2b8335d">More...</a><br /></td></tr>
<tr class="separator:a0d44f9c4a2e69fd31a4687ffe2b8335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463b59eaa324934370441a98b8b619b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a463b59eaa324934370441a98b8b619b3">setPointMaxSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="namespace_ogre.html#afd8858313711c803931b69d331be3d7b">max</a>)</td></tr>
<tr class="memdesc:a463b59eaa324934370441a98b8b619b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum point size, when point attenuation is in use.  <a href="#a463b59eaa324934370441a98b8b619b3">More...</a><br /></td></tr>
<tr class="separator:a463b59eaa324934370441a98b8b619b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a75a3e18e0d2c3e7f51a47cedcec0246c">setPointMinSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="namespace_ogre.html#af2b452038adc68d49db1236ddeca3b82">min</a>)</td></tr>
<tr class="memdesc:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum point size, when point attenuation is in use.  <a href="#a75a3e18e0d2c3e7f51a47cedcec0246c">More...</a><br /></td></tr>
<tr class="separator:a75a3e18e0d2c3e7f51a47cedcec0246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0cfe1d55b1c03e59c4e3f546d2ec78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a2b0cfe1d55b1c03e59c4e3f546d2ec78">setPointSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> ps)</td></tr>
<tr class="memdesc:a2b0cfe1d55b1c03e59c4e3f546d2ec78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the point size of this pass.  <a href="#a2b0cfe1d55b1c03e59c4e3f546d2ec78">More...</a><br /></td></tr>
<tr class="separator:a2b0cfe1d55b1c03e59c4e3f546d2ec78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9683c2f40ed7c96b708eb2db5e02c842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a9683c2f40ed7c96b708eb2db5e02c842">setPointSpritesEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a9683c2f40ed7c96b708eb2db5e02c842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points (dots).  <a href="#a9683c2f40ed7c96b708eb2db5e02c842">More...</a><br /></td></tr>
<tr class="separator:a9683c2f40ed7c96b708eb2db5e02c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c8a7be6225b12025fcd677f0d7140f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae4c8a7be6225b12025fcd677f0d7140f">setPolygonModeOverrideable</a> (bool override)</td></tr>
<tr class="memdesc:ae4c8a7be6225b12025fcd677f0d7140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this pass's chosen detail level can be overridden (downgraded) by the camera setting.  <a href="#ae4c8a7be6225b12025fcd677f0d7140f">More...</a><br /></td></tr>
<tr class="separator:ae4c8a7be6225b12025fcd677f0d7140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad244f29bea09511840ecd8494f132096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ad244f29bea09511840ecd8494f132096">setSamplerblock</a> (const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;samplerblock)</td></tr>
<tr class="memdesc:ad244f29bea09511840ecd8494f132096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set samplerblock for every texture unit.  <a href="#ad244f29bea09511840ecd8494f132096">More...</a><br /></td></tr>
<tr class="separator:ad244f29bea09511840ecd8494f132096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511812da930186cb3fe15e286bc2d244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a511812da930186cb3fe15e286bc2d244">setSelfIllumination</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>
<tr class="memdesc:a511812da930186cb3fe15e286bc2d244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="#a511812da930186cb3fe15e286bc2d244">More...</a><br /></td></tr>
<tr class="separator:a511812da930186cb3fe15e286bc2d244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed49cbeb67725747cb25376ca67c2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4ed49cbeb67725747cb25376ca67c2bb">setSelfIllumination</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;selfIllum)</td></tr>
<tr class="memdesc:a4ed49cbeb67725747cb25376ca67c2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination an object has.  <a href="#a4ed49cbeb67725747cb25376ca67c2bb">More...</a><br /></td></tr>
<tr class="separator:a4ed49cbeb67725747cb25376ca67c2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c00297cd5d46bb365d981cd1764a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ade6c00297cd5d46bb365d981cd1764a6">setShadingMode</a> (<a class="el" href="group___general.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a> mode)</td></tr>
<tr class="memdesc:ade6c00297cd5d46bb365d981cd1764a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of light shading required.  <a href="#ade6c00297cd5d46bb365d981cd1764a6">More...</a><br /></td></tr>
<tr class="separator:ade6c00297cd5d46bb365d981cd1764a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae19f94be0da24a4b813e5849ecc4fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aae19f94be0da24a4b813e5849ecc4fc2">setShadowCasterFragmentProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:aae19f94be0da24a4b813e5849ecc4fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the fragment program to use when rendering as a shadow caster.  <a href="#aae19f94be0da24a4b813e5849ecc4fc2">More...</a><br /></td></tr>
<tr class="separator:aae19f94be0da24a4b813e5849ecc4fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfd71fa6c43cdf5c6f3613fdee1a17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a4dfd71fa6c43cdf5c6f3613fdee1a17d">setShadowCasterFragmentProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:a4dfd71fa6c43cdf5c6f3613fdee1a17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fragment program parameters for rendering as a shadow caster.  <a href="#a4dfd71fa6c43cdf5c6f3613fdee1a17d">More...</a><br /></td></tr>
<tr class="separator:a4dfd71fa6c43cdf5c6f3613fdee1a17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d208f945dbfc60cac0cc4502a8eb3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6d208f945dbfc60cac0cc4502a8eb3dc">setShadowCasterVertexProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a6d208f945dbfc60cac0cc4502a8eb3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the vertex program to use when rendering as a shadow caster.  <a href="#a6d208f945dbfc60cac0cc4502a8eb3dc">More...</a><br /></td></tr>
<tr class="separator:a6d208f945dbfc60cac0cc4502a8eb3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585dc96fdf025aaef00dce27bbf1328b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a585dc96fdf025aaef00dce27bbf1328b">setShadowCasterVertexProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:a585dc96fdf025aaef00dce27bbf1328b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex program parameters for rendering as a shadow caster.  <a href="#a585dc96fdf025aaef00dce27bbf1328b">More...</a><br /></td></tr>
<tr class="separator:a585dc96fdf025aaef00dce27bbf1328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8202cf155d20602fd9c0ec53273a442f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8202cf155d20602fd9c0ec53273a442f">setShininess</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> val)</td></tr>
<tr class="memdesc:a8202cf155d20602fd9c0ec53273a442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shininess of the pass, affecting the size of specular highlights.  <a href="#a8202cf155d20602fd9c0ec53273a442f">More...</a><br /></td></tr>
<tr class="separator:a8202cf155d20602fd9c0ec53273a442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c079dd718b5839e1be10ee077a620b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8c079dd718b5839e1be10ee077a620b7">setSpecular</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>
<tr class="memdesc:a8c079dd718b5839e1be10ee077a620b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specular colour reflectance properties of this pass.  <a href="#a8c079dd718b5839e1be10ee077a620b7">More...</a><br /></td></tr>
<tr class="separator:a8c079dd718b5839e1be10ee077a620b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66770883c6420a761996a29b9d5f57bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a66770883c6420a761996a29b9d5f57bc">setSpecular</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;specular)</td></tr>
<tr class="memdesc:a66770883c6420a761996a29b9d5f57bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specular colour reflectance properties of this pass.  <a href="#a66770883c6420a761996a29b9d5f57bc">More...</a><br /></td></tr>
<tr class="separator:a66770883c6420a761996a29b9d5f57bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd">setStartLight</a> (unsigned short startLight)</td></tr>
<tr class="memdesc:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the light index that this pass will start at in the light list.  <a href="#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd">More...</a><br /></td></tr>
<tr class="separator:a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adb72e47427f59f672e43b709c68038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a5adb72e47427f59f672e43b709c68038">setTessellationDomainProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a5adb72e47427f59f672e43b709c68038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the Tessellation domain program to use.  <a href="#a5adb72e47427f59f672e43b709c68038">More...</a><br /></td></tr>
<tr class="separator:a5adb72e47427f59f672e43b709c68038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f6e70258ca9a870e3b0867792000e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#ae4f6e70258ca9a870e3b0867792000e6">setTessellationDomainProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:ae4f6e70258ca9a870e3b0867792000e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Tessellation Domain program parameters.  <a href="#ae4f6e70258ca9a870e3b0867792000e6">More...</a><br /></td></tr>
<tr class="separator:ae4f6e70258ca9a870e3b0867792000e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6821e86c7c287fabcd28344117f772d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a6821e86c7c287fabcd28344117f772d0">setTessellationHullProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:a6821e86c7c287fabcd28344117f772d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for shader model 5.0, hull and domain shaders.  <a href="#a6821e86c7c287fabcd28344117f772d0">More...</a><br /></td></tr>
<tr class="separator:a6821e86c7c287fabcd28344117f772d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e6148122bd80d646f75364bbc3cbe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a11e6148122bd80d646f75364bbc3cbe0">setTessellationHullProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:a11e6148122bd80d646f75364bbc3cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Tessellation Hull program parameters.  <a href="#a11e6148122bd80d646f75364bbc3cbe0">More...</a><br /></td></tr>
<tr class="separator:a11e6148122bd80d646f75364bbc3cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b32d92dd9d316ff9650affd08d16a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a30b32d92dd9d316ff9650affd08d16a2">setVertexColourTracking</a> (<a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a> tracking)</td></tr>
<tr class="memdesc:a30b32d92dd9d316ff9650affd08d16a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets which material properties follow the vertex colour.  <a href="#a30b32d92dd9d316ff9650affd08d16a2">More...</a><br /></td></tr>
<tr class="separator:a30b32d92dd9d316ff9650affd08d16a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0003996c1c200db9fb6466a2253a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#aba0003996c1c200db9fb6466a2253a54">setVertexProgram</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool resetParams=true)</td></tr>
<tr class="memdesc:aba0003996c1c200db9fb6466a2253a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the vertex program to use.  <a href="#aba0003996c1c200db9fb6466a2253a54">More...</a><br /></td></tr>
<tr class="separator:aba0003996c1c200db9fb6466a2253a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc41cb1fe9251448002a2405405b8bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#afc41cb1fe9251448002a2405405b8bd9">setVertexProgramParameters</a> (<a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> params)</td></tr>
<tr class="memdesc:afc41cb1fe9251448002a2405405b8bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex program parameters.  <a href="#afc41cb1fe9251448002a2405405b8bd9">More...</a><br /></td></tr>
<tr class="separator:afc41cb1fe9251448002a2405405b8bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81f938c4c2c58c71b488216a5a6521ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pass.html#a81f938c4c2c58c71b488216a5a6521ce">_getBlendFlags</a> (<a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> type, <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> &amp;source, <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> &amp;dest)</td></tr>
<tr class="memdesc:a81f938c4c2c58c71b488216a5a6521ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to get scene blending flags from a blending type.  <a href="#a81f938c4c2c58c71b488216a5a6521ce">More...</a><br /></td></tr>
<tr class="separator:a81f938c4c2c58c71b488216a5a6521ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class defining a single pass of a <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a> (of a <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a>), i.e. </p>
<p>a single rendering call. </p><dl class="section remark"><dt>Remarks</dt><dd>Rendering can be repeated with many passes for more complex effects. Each pass is either a fixed-function pass (meaning it does not use a vertex or fragment program) or a programmable pass (meaning it does use either a vertex and fragment program, or both). </dd></dl>
<dl class="section user"><dt></dt><dd>Programmable passes are complex to define, because they require custom programs and you have to set all constant inputs to the programs (like the position of lights, any base material colours you wish to use etc), but they do give you much total flexibility over the algorithms used to render your pass, and you can create some effects which are impossible with a fixed-function pass. On the other hand, you can define a fixed-function pass in very little time, and you can use a range of fixed-function effects like environment mapping very easily, plus your pass will be more likely to be compatible with older hardware. There are pros and cons to both, just remember that if you use a programmable pass to create some great effects, allow more time for definition and testing. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a98b42a4f4304f3f2d08fb9394cbefe83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;TextureUnitStates&gt; <a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">Ogre::Pass::ConstTextureUnitStateIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7bc2b00e42ad2699a1e2a1de340d3b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;TextureUnitStates&gt; <a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">Ogre::Pass::TextureUnitStateIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7f36f2c48b62fd29b2abdee4425d6a2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::Pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a2af67ca21bb1a91d6c228db8207384fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::Pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td>
          <td class="paramname"><em>oth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a73276f829c68266eca0c0fd700e13638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::Pass::~Pass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a81f938c4c2c58c71b488216a5a6521ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::Pass::_getBlendFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to get scene blending flags from a blending type. </p>

</div>
</div>
<a class="anchor" id="ae147dfdf1c89089b1a8fadaaa2a59672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_datablock.html">HlmsDatablock</a>* Ogre::Pass::_getDatablock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the internal datablock that acts as proxy for us. </p>

</div>
</div>
<a class="anchor" id="ad2a266864da9539e07de89c3fc454710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::_getTextureUnitWithContentTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_unit_state.html#a35a108a68c71c8267af4af8c1a819030">TextureUnitState::ContentType</a>&#160;</td>
          <td class="paramname"><em>contentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the 'nth' texture which references the given content type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the 'nth' texture unit which references the content type doesn't exist, then this method returns an arbitrary high-value outside the valid range to index texture units. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1e07d3bccdb7f6c437c107c92e4ae46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_load </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for loading this pass. </p>

</div>
</div>
<a class="anchor" id="afaa52a3826a08569b8263834f043a83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_notifyIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method to adjust pass index. </p>

</div>
</div>
<a class="anchor" id="ab85cf60f49c52c53671d5bb5105231e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_prepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for preparing to load this pass. </p>

</div>
</div>
<a class="anchor" id="a5766787845b1be6dfbf45cac068fc825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_unload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for unloading this pass. </p>

</div>
</div>
<a class="anchor" id="a928061c8f56d923808add7e8ba9cdee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_unprepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for undoing the load preparartion for this pass. </p>

</div>
</div>
<a class="anchor" id="a54eaf1d7ed3327c29733595fc4142dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::_updateAutoParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>variabilityMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update automatic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of the parameters </td></tr>
    <tr><td class="paramname">variabilityMask</td><td>A mask of GpuParamVariability which identifies which autos will need updating </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00a4036c87d4778c20d19412e9530ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::addTextureUnitState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the passed in <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a>, to the existing <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State to be attached to this pass. It must not be attached to another pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> is attached to another <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c2721a68454b17942c5fd6d25f45de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::applyTextureAliases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga20898062bd79359acd1137276d9b0e37">AliasTextureNamePairList</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>apply</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies texture names to <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State with matching texture name aliases. </p>
<p>All <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit States within the pass are checked. If matching texture aliases are found then true is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aliasList</td><td>is a map container of texture alias, texture name pairs </td></tr>
    <tr><td class="paramname">apply</td><td>set true to apply the texture aliases else just test to see if texture alias matches are found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if matching texture aliases were found in the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a05c8d03e581a06d067295faaaf3b99cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::calculateSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8b37124088b574d2cbb2652c0ee4272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::createTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This unit is is added on top of all previous units. </dd></dl>

</div>
</div>
<a class="anchor" id="adfee1e1da3564408697f6b1227102c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::createTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>texCoordSet</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> object into the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This unit is is added on top of all previous units. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The basic name of the texture e.g. brickwall.jpg, stonefloor.png </td></tr>
    <tr><td class="paramname">texCoordSet</td><td>The index of the texture coordinate set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applies to both fixed-function and programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a026a1aec91f8661c96b79d41c54d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> Ogre::Pass::getAlphaRejectFunction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the alpha reject function. </p>
<p>See setAlphaRejectSettings for more information. </p>

</div>
</div>
<a class="anchor" id="ac97da177e624bb0abe329272081ef7bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Ogre::Pass::getAlphaRejectValue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the alpha reject value. </p>
<p>See setAlphaRejectSettings for more information. </p>

<p>References <a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f">Ogre::Light::LT_POINT</a>.</p>

</div>
</div>
<a class="anchor" id="a2de4bacffdf08bc93794a66ce0a33df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getAmbient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ambient colour reflectance of the pass. </p>

</div>
</div>
<a class="anchor" id="a85fad6b84d0e2453b0cef04b92dea911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a>* Ogre::Pass::getBlendblock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves current blendblock. </p>
<p>Don't const_cast the return value to modify it.  <a class="el" href="class_ogre_1_1_hlms_datablock.html" title="An hlms datablock contains individual information about a specific material. ">HlmsDatablock</a> remarks. </p>

</div>
</div>
<a class="anchor" id="a8f5e2cd0176a5e1e57efb5515c95b80a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if colour buffer writing is enabled for this pass. </p>

</div>
</div>
<a class="anchor" id="a4c10574084df798b4e67c8c3e544f1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getComputeProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation EHull program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a30510adef0f4588f2475009b65a1943f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getComputeProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the Tessellation Hull program used by this pass. </p>

</div>
</div>
<a class="anchor" id="a60735245e290061f117118253ebd648f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getComputeProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation Hull program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="ac61406c45d5607d5daa520201fc68017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getDiffuse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the diffuse colour reflectance of the pass. </p>

</div>
</div>
<a class="anchor" id="a78da275ce705622f8de8aa9d7dda478a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getEmissive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the self illumination colour of the pass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a1036ac655e74599a66239c16e69c84ab" title="Gets the self illumination colour of the pass. ">getSelfIllumination</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f6da762323ae84db14a8d9f1822258d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getFogColour </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fog colour for the scene. </p>

</div>
</div>
<a class="anchor" id="a868dd63ed8c6686380ed980b6e7e3e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getFogDensity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fog density for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d67be7f381d514050e1867e6908dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getFogEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fog end distance for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a0410b3dda0527e550862253ebf8a6dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> Ogre::Pass::getFogMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fog mode for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4a60fca163ceff1ef34cf08d6a3f50c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getFogOverride </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this pass is to override the scene fog settings. </p>

</div>
</div>
<a class="anchor" id="a4e996bfaad96bda9db001b9e5fe352b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getFogStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fog start distance for this pass. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid if getFogOverride is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a413bb7b107190cdd6b69c141d3c10160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fragment program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="af8a7fe0395b6d5224b83db0f764ced19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getFragmentProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the fragment program used by this pass. </p>

</div>
</div>
<a class="anchor" id="a625a7d756b38b5da1d92b292e3fd1aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fragment program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="add6a29d0d100a0ee69b8e9d441f4d73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the geometry program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a86406f92d7137ca097fb1dd777810dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getGeometryProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the geometry program used by this pass. </p>

</div>
</div>
<a class="anchor" id="aec43cbc80e2cfa8f2d20aff9fc7c5655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getGeometryProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the geometry program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="a71369c583a07daba7cd8dd1d0bc9a281"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Pass::getId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6ad34ba288321b9f7d9031ccf6fc3a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> in the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a>. </p>

</div>
</div>
<a class="anchor" id="acb06e90ff9a42071983e2cec06783774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getIteratePerLight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this pass run once for every light in range? </p>

</div>
</div>
<a class="anchor" id="affd4b083effc0511e550955f53659aef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getLightClipPlanesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. </p>

</div>
</div>
<a class="anchor" id="a789fe5bdf561ccabea75fc9d0a1dbd63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getLightCountPerIteration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If light iteration is enabled, determine the number of lights per iteration. </p>

</div>
</div>
<a class="anchor" id="aea03fb8b8fad8504346f6e9c4a30f9ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::Pass::getLightMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the light mask controlling which lights are used for this pass. </p>

</div>
</div>
<a class="anchor" id="ad0252ab0ac2998ba0f8fa18028d4d6db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getLightScissoringEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. </p>

</div>
</div>
<a class="anchor" id="a4c4e8693b6e574a536786753a140bac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a>* Ogre::Pass::getMacroblock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves current macroblock. </p>
<p>Don't const_cast the return value to modify it.  <a class="el" href="class_ogre_1_1_hlms_datablock.html" title="An hlms datablock contains individual information about a specific material. ">HlmsDatablock</a> remarks. </p>

</div>
</div>
<a class="anchor" id="a7c90a998e60c3d1eaed4a9523cb11adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getMaxSimultaneousLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum number of lights to be used by this pass. </p>

</div>
</div>
<a class="anchor" id="a4c1bab83b1dcd5a269cac346a2d8c994"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the pass. </p>

</div>
</div>
<a class="anchor" id="a873d66752be7a7c539bd885ca212e096"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::getNumShadowContentTextures </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e89e46903cc53d61ca5b9e8188ff686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getNumTextureUnitStates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of texture unit settings. </p>

</div>
</div>
<a class="anchor" id="acf9fa78852454ce5c6a5f643500b09b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> Ogre::Pass::getOnlyLightType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true. </p>

</div>
</div>
<a class="anchor" id="a46b545806ee7b84dffb51a3ffb565c08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_technique.html">Technique</a>* Ogre::Pass::getParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material. ">Technique</a>. </p>

</div>
</div>
<a class="anchor" id="ad74b47051c90b6773e5b011a675ca996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Pass::getPassIterationCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pass iteration count value. </p>

</div>
</div>
<a class="anchor" id="a35805ebc35dfc915729d442d1d70442b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointAttenuationConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant coefficient of point attenuation. </p>

</div>
</div>
<a class="anchor" id="ae5e91fc3b2024b5e0b025179f7711c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointAttenuationLinear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the linear coefficient of point attenuation. </p>

</div>
</div>
<a class="anchor" id="a10b1c78d6e3553aa27590076389b347a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointAttenuationQuadratic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quadratic coefficient of point attenuation. </p>

</div>
</div>
<a class="anchor" id="aceb506f7545bcd3715885571645807e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointMaxSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum point size, when point attenuation is in use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>0 indicates the max size supported by the card. </dd></dl>

</div>
</div>
<a class="anchor" id="ae168c2016fbaebb4bccd6dfe28f77367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointMinSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum point size, when point attenuation is in use. </p>

</div>
</div>
<a class="anchor" id="acc7832e2916a8c7ebc9d20a273bafdbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getPointSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the point size of the pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This property determines what point size is used to render a point list. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a53a2302b81e9b5cd5a6d9e1c52d908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getPointSpritesEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether point sprites are enabled when rendering a point list. </p>

</div>
</div>
<a class="anchor" id="a9c184b1908a08f07969d5caf6859945c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::Pass::getPolygonModeOverrideable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. </p>

<p>References <a class="el" href="group___general.html#gga83edeb2e5d33a3ca8f15834ba40020baab7793a21880052c0214d4cc040992310">Ogre::FOG_NONE</a>, and <a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">Ogre::ColourValue::White</a>.</p>

</div>
</div>
<a class="anchor" id="ad3373fad544ff5f6840c2337f4812e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getResourceGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a>. </p>

</div>
</div>
<a class="anchor" id="a4b7ca18b8282a1551d5be1ed3d34f349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::getRunOnlyForOneLightType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this pass run only for a single light type (if getIteratePerLight is true). </p>

</div>
</div>
<a class="anchor" id="a1036ac655e74599a66239c16e69c84ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the self illumination colour of the pass. </p>

</div>
</div>
<a class="anchor" id="a9c6a77e4c0a208484a9fb7e81654d514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a> Ogre::Pass::getShadingMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of light shading to be used. </p>

</div>
</div>
<a class="anchor" id="a4b44393b5211966e8f1f2f3c9188a185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getShadowCasterFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fragment program used by this pass when rendering shadow casters, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a2d57144e465a6584ae1e4f72e6ded39d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getShadowCasterFragmentProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the fragment program used by this pass when rendering shadow casters. </p>

</div>
</div>
<a class="anchor" id="a0549cfe83a4d6f76187b9beeb5f97760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getShadowCasterFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the fragment program parameters used by this pass when rendering shadow casters. </p>

</div>
</div>
<a class="anchor" id="a0e2dd8f2c2957da4013eb6fc0b6e2e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getShadowCasterVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex program used by this pass when rendering shadow casters, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a12ae6dab78e22950a3fbf59774187c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getShadowCasterVertexProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the vertex program used by this pass when rendering shadow casters. </p>

</div>
</div>
<a class="anchor" id="aaa7c93f7897b4a5f72ec007c0fa98587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getShadowCasterVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex program parameters used by this pass when rendering shadow casters. </p>

</div>
</div>
<a class="anchor" id="a8be7891bdca3a4f1e1c73a1d40c0ec7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::Pass::getShininess </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the 'shininess' property of the pass (affects specular highlights). </p>

</div>
</div>
<a class="anchor" id="a7814c79f09b87acee854dae6fb63e8fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a>&amp; Ogre::Pass::getSpecular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the specular colour reflectance of the pass. </p>

</div>
</div>
<a class="anchor" id="a484603c72ec5a3e8c7d5a1b50e3c05ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getStartLight </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the light index that this pass will start at in the light list. </p>

</div>
</div>
<a class="anchor" id="af05ecb09c015f59aeccbde4cfd0c103b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation Domain program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a5db533f22819aa01b4ff103bf43602f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getTessellationDomainProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the Domain Evaluation program used by this pass. </p>

</div>
</div>
<a class="anchor" id="a1e5f9468178cfd643fe3292318a4d416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getTessellationDomainProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation Domain program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="ab5fd57734bb36ee508d4e1c6ea71a1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation Hull program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a789d5674ef33d77dadac65e0103c2437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getTessellationHullProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the Tessellation Hull program used by this pass. </p>

</div>
</div>
<a class="anchor" id="aa8f35a1ef70651fbf82be2fb8b4147d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getTessellationHullProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tessellation Hull program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="ac52268fc31d523258f3edc90a3d17cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pointer to a texture unit state so it may be modified. </p>

</div>
</div>
<a class="anchor" id="ae27b1b021da5a9e64fa4923845663eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State matching name. </p>
<p>Returns 0 if name match is not found. </p>

</div>
</div>
<a class="anchor" id="ac88dcdf45a83617610bd7697101c04cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a const pointer to a texture unit state. </p>

</div>
</div>
<a class="anchor" id="af6b054578bb23bcbb9a8bd9c2de8c718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a>* Ogre::Pass::getTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State matching name. </p>
<p>Returns 0 if name match is not found. </p>

</div>
</div>
<a class="anchor" id="a08ac1aab7513931a4a30ed8eed33ca79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Pass::getTextureUnitStateIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_unit_state.html">TextureUnitState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the index of the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State in the pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit State this is attached to this pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Throws an exception if the state is not attached to the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1513f6d3e1acb9037225d826ec99856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html#ac7bc2b00e42ad2699a1e2a1de340d3b4">TextureUnitStateIterator</a> Ogre::Pass::getTextureUnitStateIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </p>

</div>
</div>
<a class="anchor" id="a93fe292a1acabbc73420e9d26af51f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html#a98b42a4f4304f3f2d08fb9394cbefe83">ConstTextureUnitStateIterator</a> Ogre::Pass::getTextureUnitStateIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over the TextureUnitStates contained in this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a>. </p>

</div>
</div>
<a class="anchor" id="adc70de42e8b22b4d8ccedf6868bbbfc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Pass::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a78e0bc742536372c9eb21ba6a3e0f0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Pass::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad375f519587608ca2f0f5fa8d6801182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a> Ogre::Pass::getVertexColourTracking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets which material properties follow the vertex colour. </p>

</div>
</div>
<a class="anchor" id="aa2dff1afc5d9b683bbac058e1c5cdfe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2c452533979dfdf73a296288e94d920b">GpuProgramPtr</a>&amp; Ogre::Pass::getVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex program used by this pass, only available after <a class="el" href="class_ogre_1_1_pass.html#ac1e07d3bccdb7f6c437c107c92e4ae46" title="Internal method for loading this pass. ">_load()</a>. </p>

</div>
</div>
<a class="anchor" id="a49cff7e78e08931da9135a42983dafcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Pass::getVertexProgramName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the vertex program used by this pass. </p>

</div>
</div>
<a class="anchor" id="a51690f7442dcbf4882331226f75967bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a> Ogre::Pass::getVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the vertex program parameters used by this pass. </p>

</div>
</div>
<a class="anchor" id="a617cec627a54e8b14ad3d610a373448a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasComputeProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable compute pipeline. </p>

</div>
</div>
<a class="anchor" id="acf37cc807e158f8aaf15acfb84806627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable fragment pipeline. </p>

</div>
</div>
<a class="anchor" id="a4f8f21234060f157c80a2f862bd90662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable geometry pipeline. </p>

</div>
</div>
<a class="anchor" id="adaac78cbe658094a058179781268a4b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasShadowCasterFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a shadow caster fragment program. </p>

</div>
</div>
<a class="anchor" id="a748683e8b6877b9b958ccf094cff69f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasShadowCasterVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a shadow caster vertex program. </p>

</div>
</div>
<a class="anchor" id="a672dea10bb1286bbe47d94a24b2eacd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable tessellation control pipeline. </p>

</div>
</div>
<a class="anchor" id="a1820feccdfd3bbb4866ac7a3a915d70d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable tessellation control pipeline. </p>

</div>
</div>
<a class="anchor" id="a643c9431fa2abe9ceb406804e26ad0d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::hasVertexProgram </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass uses a programmable vertex pipeline. </p>

</div>
</div>
<a class="anchor" id="a4abd637e95e2aeaea9a984151b082e3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::insertShadowContentTypeLookup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>textureUnitIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when a texture unit changed to type CONTENT_SHADOW. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureUnitIndex</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Unit index of the TU being changed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ee9a442132cdf8e5c7a5f3216008a4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isAmbientOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this pass is ambient only. </p>

</div>
</div>
<a class="anchor" id="a5cb68ecae89e2a7e903f764247c1f929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isLoaded </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this loaded? </p>

</div>
</div>
<a class="anchor" id="a426ca66e7e3579369aa3f90c3059aea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isPointAttenuationEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether points are attenuated with distance. </p>

</div>
</div>
<a class="anchor" id="ae9108164d08798980dc27282431357ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isProgrammable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this pass is programmable i.e. includes either a vertex or fragment program. </p>

</div>
</div>
<a class="anchor" id="ab88f92f66f97921515270a98421e9969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Pass::isTransparent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this pass has some element of transparency. </p>

</div>
</div>
<a class="anchor" id="af23f6b1ae56f9acdcb05f8cbcf0e9153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_MUTEX </td>
          <td>(</td>
          <td class="paramtype">mTexUnitChangeMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3af180b9759ea13e557003abc84e594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_MUTEX </td>
          <td>(</td>
          <td class="paramtype">mGpuProgramChangeMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a10afa648bf34693a7b6c377e126da20f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_STATIC_MUTEX </td>
          <td>(</td>
          <td class="paramtype">msDirtyHashListMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab25733e77cd0b2f558d62e5a7ab7592e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Pass::OGRE_STATIC_MUTEX </td>
          <td>(</td>
          <td class="paramtype">msPassGraveyardMutex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15bb76abae180b60dfcf9a6e1fdcd8fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>&amp; Ogre::Pass::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> &amp;&#160;</td>
          <td class="paramname"><em>oth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator = overload. </p>

</div>
</div>
<a class="anchor" id="ab7858343bd4fe24f8dadcf51eb6a601b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::recreateShadowContentTypeLookup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recreates the contents of mShadowContentTypeLookup from scratch. </p>

</div>
</div>
<a class="anchor" id="a86de1842654eb89c6f48785d02f07688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::removeAllTextureUnitStates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all texture unit settings. </p>

</div>
</div>
<a class="anchor" id="a157feb20eee8d56cf504a0fce9064f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::removeShadowContentTypeLookup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>textureUnitIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when a texture unit is removed (any type), or when a tex unit that used to be of type CONTENT_SHADOW, no longer is. </p>

</div>
</div>
<a class="anchor" id="a66085d80b0caa39850216b603cec40b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::removeTextureUnitState </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the indexed texture unit state from this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that removing a texture which is not the topmost will have a larger performance impact. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f23af59e5f991f22a224f8e6b336af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaRejectFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the alpha reject function. </p>
<p>See setAlphaRejectSettings for more information. </p>

</div>
</div>
<a class="anchor" id="a6e5c5f69be78ddd80cbb202f66649fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAlphaRejectValue </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the alpha reject value. </p>
<p>See setAlphaRejectSettings for more information. </p>

</div>
</div>
<a class="anchor" id="a606695927fbf85ee64c361abf66ac10e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAmbient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much ambient light (directionless global light) is reflected. The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="abdcffe5cb7cee6c8c5a5fd4c2f75164d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setAmbient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>ambient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much ambient light (directionless global light) is reflected. The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4beb20133aa0aa27cbb6877e42fa094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setBlendblock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_blendblock.html">HlmsBlendblock</a> &amp;&#160;</td>
          <td class="paramname"><em>blendblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the current blendblock for a new one. Pointer can't be null. </p>

</div>
</div>
<a class="anchor" id="a97deab966da4653d248875782b45a3f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setComputeProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the compute program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the compute program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any compute program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad58bed2ac47d40e65750c61c0ca36af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setComputeProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Tessellation Evaluation program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="ae371bb189752872dfa2e02694f6841f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDiffuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the diffuse colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much diffuse light (light from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> class in the scene) is reflected. The default is full white, meaning objects reflect the maximum white light they can from <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> objects. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a67e3cb12113b4fc56b8d3d4cee03068a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>diffuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the diffuse colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much diffuse light (light from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> class in the scene) is reflected. The default is full white, meaning objects reflect the maximum white light they can from <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> objects. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="aa23e78b3e2c676ea2efc5de73826c980"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setEmissive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has. ">setSelfIllumination</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5653eb7430051fc4a81aa577c031186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setEmissive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>emissive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has. ">setSelfIllumination</a> </dd></dl>

<p>References <a class="el" href="namespace_ogre.html#afd8858313711c803931b69d331be3d7b">Ogre::max()</a>, and <a class="el" href="namespace_ogre.html#af2b452038adc68d49db1236ddeca3b82">Ogre::min()</a>.</p>

</div>
</div>
<a class="anchor" id="a32b0cabffa642b0f3743ac5d82392a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFog </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overrideScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___general.html#gga83edeb2e5d33a3ca8f15834ba40020baab7793a21880052c0214d4cc040992310">FOG_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em> = <code><a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>expDensity</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearEnd</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fogging mode applied to this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. </dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overrideScene</td><td>If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </td></tr>
    <tr><td class="paramname">mode</td><td>Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </td></tr>
    <tr><td class="paramname">expDensity</td><td>The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </td></tr>
    <tr><td class="paramname">linearStart</td><td>Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </td></tr>
    <tr><td class="paramname">linearEnd</td><td>Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3019e308b0759cc150ac0f45308d69b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the fragment program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the fragment program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any fragment program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8c6cd9d16220e8ef358f8b3e072d261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fragment program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="af6b2aab96fb146a8e92043c7dc771de4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGeometryProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the geometry program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the geometry program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any geometry program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd45b897ebc29d3ee40a2ee307682f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setGeometryProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the geometry program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="aec98c9346a22a4a98acdaf5b8849a5c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setIteratePerLight </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyForOneLightType</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&#160;</td>
          <td class="paramname"><em>lightType</em> = <code><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f">Light::LT_POINT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The default behaviour for a pass (when this option is 'false'), is for a pass to be rendered only once (or the number of times set in setPassIterationCount), with all the lights which could affect this object set at the same time (up to the maximum lights allowed in the render system, which is typically 8). </dd></dl>
<dl class="section user"><dt></dt><dd>Setting this option to 'true' changes this behaviour, such that instead of trying to issue render this pass once per object, it is run <b>per light</b>, or for a group of 'n' lights each time which can affect this object, the number of times set in setPassIterationCount (default is once). In this case, only light index 0 is ever used, and is a different light every time the pass is issued, up to the total number of lights which is affecting this object. This has 2 advantages: <ul>
<li>
There is no limit on the number of lights which can be supported </li>
<li>
It's easier to write vertex / fragment programs for this because a single program can be used for any number of lights </li>
</ul>
However, this technique is more expensive, and typically you will want an additional ambient pass, because if no lights are affecting the object it will not be rendered at all, which will look odd even if ambient light is zero (imagine if there are lit objects behind it - the objects silhouette would not show up). Therefore, use this option with care, and you would be well advised to provide a less expensive fallback technique for use in the distance. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of times this pass runs is still limited by the maximum number of lights allowed as set in setMaxSimultaneousLights, so you will never get more passes than this. Also, the iteration is started from the 'start light' as set in <a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd" title="Sets the light index that this pass will start at in the light list. ">Pass::setStartLight</a>, and the number of passes is the number of lights to iterate over divided by the number of lights per iteration (default 1, set by setLightCountPerIteration). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether this feature is enabled </td></tr>
    <tr><td class="paramname">onlyForOneLightType</td><td>If true, the pass will only be run for a single type of light, other light types will be ignored. </td></tr>
    <tr><td class="paramname">lightType</td><td>The single light type which will be considered for this pass </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20d94474787abfd9eb9b07d5185ded0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightClipPlanesEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to cut down on the geometry set up to render this pass when you have a single fixed-range light being rendered through it, you can enable this option to request that during triangle setup, clip planes are defined to bound the range of the light. In the case of a point light these planes form a cube, and in the case of a spotlight they form a pyramid. Directional lights are never clipped. </dd></dl>
<dl class="section user"><dt></dt><dd>This option is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas. In addition, it will only be honoured if there is exactly one non-directional light being used in this pass. Also, these clip planes override any user clip planes set on <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE, this option is automatically used for all per-light passes if you enable SceneManager::setShadowUseLightClipPlanes and does not need to be specified. It is disabled by default since clip planes have a cost of their own which may not always exceed the benefits they give you. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e40ca39a238f0afe5e2d3a0db0661ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightCountPerIteration </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If light iteration is enabled, determine the number of lights per iteration. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The default for this setting is 1, so if you enable light iteration (<a class="el" href="class_ogre_1_1_pass.html#aec98c9346a22a4a98acdaf5b8849a5c1" title="Sets whether or not this pass should iterate per light or number of lights which can affect the objec...">Pass::setIteratePerLight</a>), the pass is rendered once per light. If you set this value higher, the passes will occur once per 'n' lights. The start of the iteration is set by <a class="el" href="class_ogre_1_1_pass.html#a8b816cdd2b5b5fcc5cbe6744b6bb2dbd" title="Sets the light index that this pass will start at in the light list. ">Pass::setStartLight</a> and the end by <a class="el" href="class_ogre_1_1_pass.html#a95a7a4006f26528ef4f6ce42ae56b09b" title="Sets the maximum number of lights to be used by this pass. ">Pass::setMaxSimultaneousLights</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f14ed26740158970994057e48e562e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the light mask which can be matched to specific light flags to be handled by this pass. </p>

</div>
</div>
<a class="anchor" id="a26fe99447102afb8e2002f7f1339dd8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setLightScissoringEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In order to cut down on fillrate when you have a number of fixed-range lights in the scene, you can enable this option to request that during rendering, only the region of the screen which is covered by the lights is rendered. This region is the screen-space rectangle covering the union of the spheres making up the light ranges. Directional lights are ignored for this. </dd></dl>
<dl class="section user"><dt></dt><dd>This is only likely to be useful for multipass additive lighting algorithms, where the scene has already been 'seeded' with an ambient pass and this pass is just adding light in affected areas. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE, this option is implicitly used for all per-light passes and does not need to be specified. If you are not using shadows or are using a modulative or an integrated shadow technique then this could be useful. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ed271a1cdee4c4f5c0f0404464f7e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setMacroblock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_macroblock.html">HlmsMacroblock</a> &amp;&#160;</td>
          <td class="paramname"><em>macroblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the current macroblock for a new one. Pointer can't be null. </p>

</div>
</div>
<a class="anchor" id="a95a7a4006f26528ef4f6ce42ae56b09b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setMaxSimultaneousLights </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>maxLights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of lights to be used by this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>During rendering, if lighting is enabled (or if the pass uses an automatic program parameter based on a light) the engine will request the nearest lights to the object being rendered in order to work out which ones to use. This parameter sets the limit on the number of lights which should apply to objects rendered with this pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a03306f735122ec4e7d4c391f1528cf50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28ff8c16ee57201651da61e649ea216b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPassIterationCount </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the number of iterations that this pass should perform when doing fast multi pass operation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable for programmable passes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of iterations to perform fast multi pass operations. A value greater than 1 will cause the pass to be executed count number of times without changing the render state. This is very useful for passes that use programmable shaders that have to iterate more than once but don't need a render state change. Using multi pass can dramatically speed up rendering for materials that do things like fur, blur. A value of 1 turns off multi pass operation and the pass does the normal pass operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d44f9c4a2e69fd31a4687ffe2b8335d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointAttenuation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>constant</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linear</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>quadratic</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets how points are attenuated with distance. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2). </dd></dl>
<dl class="section user"><dt></dt><dd>For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The resulting size is clamped to the minimum and maximum point size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether point attenuation is enabled </td></tr>
    <tr><td class="paramname">constant,linear,quadratic</td><td>Parameters to the attenuation function defined above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a463b59eaa324934370441a98b8b619b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointMaxSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum point size, when point attenuation is in use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Setting this to 0 indicates the max size supported by the card. </dd></dl>

</div>
</div>
<a class="anchor" id="a75a3e18e0d2c3e7f51a47cedcec0246c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointMinSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum point size, when point attenuation is in use. </p>

</div>
</div>
<a class="anchor" id="a2b0cfe1d55b1c03e59c4e3f546d2ec78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the point size of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This setting allows you to change the size of points when rendering a point list, or a list of point sprites. The interpretation of this command depends on the Pass::setPointSizeAttenuation option - if it is off (the default), the point size is in screen pixels, if it is on, it expressed as normalised screen coordinates (1.0 is the height of the screen) when the point is at the origin. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some drivers have an upper limit on the size of points they support<ul>
<li>this can even vary between APIs on the same card! Don't rely on point sizes that cause the point sprites to get very large on screen, since they may get clamped on some cards. Upper sizes can range from 64 to 256 pixels. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9683c2f40ed7c96b708eb2db5e02c842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setPointSpritesEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points (dots). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True enables point sprites, false returns to normal point rendering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4c8a7be6225b12025fcd677f0d7140f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::Pass::setPolygonModeOverrideable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether this pass's chosen detail level can be overridden (downgraded) by the camera setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override</td><td>true means that a lower camera detail will override this pass's detail level, false means it won't (default true). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad244f29bea09511840ecd8494f132096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSamplerblock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;&#160;</td>
          <td class="paramname"><em>samplerblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set samplerblock for every texture unit. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique, of a Material. ">TextureUnitState</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_unit_state.html#acda3795a41ccbf4c08de2fa04b90df1a" title="Changes the current samplerblock for a new one. ">TextureUnitState::setSamplerblock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a511812da930186cb3fe15e286bc2d244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed49cbeb67725747cb25376ca67c2bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>selfIllum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination an object has. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ade6c00297cd5d46bb365d981cd1764a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of light shading required. </p>
<dl class="section note"><dt>Note</dt><dd>The default shading method is Gouraud shading. </dd></dl>

</div>
</div>
<a class="anchor" id="aae19f94be0da24a4b813e5849ecc4fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadowCasterFragmentProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the fragment program to use when rendering as a shadow caster. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Texture-based shadows require that the caster is rendered to a texture in a solid colour (the shadow colour in the case of modulative texture shadows). Whilst <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can arrange this for the fixed function pipeline, passes which use vertex programs might need the vertex programs still to run in order to preserve any deformation etc that it does. However, lighting calculations must be a lot simpler, with only the ambient colour being used (which the engine will ensure is bound to the shadow colour). </dd></dl>
<dl class="section user"><dt></dt><dd>Therefore, it is up to implementors of vertex programs to provide an alternative vertex program which can be used to render the object to a shadow texture. Do all the same vertex transforms, but set the colour of the vertex to the ambient colour, as bound using the standard auto parameter binding mechanism. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some vertex programs will work without doing this, because <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> ensures that all lights except for ambient are set black. However, the chances are that your vertex program is doing a lot of unnecessary work in this case, since the other lights are having no effect, and it is good practice to supply an alternative. </dd>
<dd>
This is only applicable to programmable passes. </dd></dl>
<dl class="section user"><dt></dt><dd>The default behaviour is for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to switch to fixed-function rendering if an explicit fragment program alternative is not set. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dfd71fa6c43cdf5c6f3613fdee1a17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadowCasterFragmentProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fragment program parameters for rendering as a shadow caster. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d208f945dbfc60cac0cc4502a8eb3dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadowCasterVertexProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the vertex program to use when rendering as a shadow caster. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Texture-based shadows require that the caster is rendered to a texture in a solid colour (the shadow colour in the case of modulative texture shadows). Whilst <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can arrange this for the fixed function pipeline, passes which use vertex programs might need the vertex programs still to run in order to preserve any deformation etc that it does. However, lighting calculations must be a lot simpler, with only the ambient colour being used (which the engine will ensure is bound to the shadow colour). </dd></dl>
<dl class="section user"><dt></dt><dd>Therefore, it is up to implementors of vertex programs to provide an alternative vertex program which can be used to render the object to a shadow texture. Do all the same vertex transforms, but set the colour of the vertex to the ambient colour, as bound using the standard auto parameter binding mechanism. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some vertex programs will work without doing this, because <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> ensures that all lights except for ambient are set black. However, the chances are that your vertex program is doing a lot of unnecessary work in this case, since the other lights are having no effect, and it is good practice to supply an alternative. </dd>
<dd>
This is only applicable to programmable passes. </dd></dl>
<dl class="section user"><dt></dt><dd>The default behaviour is for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to switch to fixed-function rendering if an explicit vertex program alternative is not set. </dd></dl>

</div>
</div>
<a class="anchor" id="a585dc96fdf025aaef00dce27bbf1328b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShadowCasterVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex program parameters for rendering as a shadow caster. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a8202cf155d20602fd9c0ec53273a442f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setShininess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the shininess of the pass, affecting the size of specular highlights. </p>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c079dd718b5839e1be10ee077a620b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSpecular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specular colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much specular light (highlights from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> class in the scene) is reflected. The default is to reflect no specular light. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The size of the specular highlights is determined by the separate 'shininess' property. </dd>
<dd>
This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a66770883c6420a761996a29b9d5f57bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setSpecular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>specular</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specular colour reflectance properties of this pass. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much specular light (highlights from instances of the <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> class in the scene) is reflected. The default is to reflect no specular light. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The size of the specular highlights is determined by the separate 'shininess' property. </dd>
<dd>
This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b816cdd2b5b5fcc5cbe6744b6bb2dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setStartLight </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>startLight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the light index that this pass will start at in the light list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Normally the lights passed to a pass will start from the beginning of the light list for this object. This option allows you to make this pass start from a higher light index, for example if one of your earlier passes could deal with lights 0-3, and this pass dealt with lights 4+. This option also has an interaction with pass iteration, in that if you choose to iterate this pass per light too, the iteration will only begin from light 4. </dd></dl>

</div>
</div>
<a class="anchor" id="a5adb72e47427f59f672e43b709c68038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationDomainProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the Tessellation domain program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the Tessellation domain program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any Tessellation domain program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4f6e70258ca9a870e3b0867792000e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationDomainProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Tessellation Domain program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6821e86c7c287fabcd28344117f772d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationHullProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support for shader model 5.0, hull and domain shaders. </p>
<p>Sets the details of the Tessellation control program to use. </p><dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the Tessellation Hull program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any Tessellation Hull program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11e6148122bd80d646f75364bbc3cbe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setTessellationHullProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Tessellation Hull program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes. </dd></dl>

</div>
</div>
<a class="anchor" id="a30b32d92dd9d316ff9650affd08d16a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexColourTracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#gaf3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a>&#160;</td>
          <td class="paramname"><em>tracking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets which material properties follow the vertex colour. </p>

</div>
</div>
<a class="anchor" id="aba0003996c1c200db9fb6466a2253a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetParams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the vertex program to use. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, this sets the details of the vertex program to use in this pass. The program will not be loaded until the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> is loaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the program - this must have been created using <a class="el" href="class_ogre_1_1_gpu_program_manager.html">GpuProgramManager</a> by the time that this <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Pass</a> is loaded. If this parameter is blank, any vertex program in this pass is disabled. </td></tr>
    <tr><td class="paramname">resetParams</td><td>If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc41cb1fe9251448002a2405405b8bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Pass::setVertexProgramParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aebab7cecf3f3ae81a1fbfa08ab36f2b5">GpuProgramParametersSharedPtr</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vertex program parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_pass_8h.html">OgrePass.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_pass.html">Pass</a></li>
    <li class="footer">Generated on Thu May 4 2017 22:21:42 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
