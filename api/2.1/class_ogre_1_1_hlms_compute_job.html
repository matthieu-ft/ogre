<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::HlmsComputeJob Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_hlms_compute_job.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ogre_1_1_hlms_compute_job-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::HlmsComputeJob Class Reference<div class="ingroups"><a class="el" href="group___component.html">Component</a> &raquo; <a class="el" href="group___material.html">Material</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreHlmsComputeJob.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::HlmsComputeJob:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hlms_compute_job__inherit__graph.svg" width="174" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a297b925576b81843bd963d67ec561fbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> { <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf">ThreadGroupsBasedOnNothing</a>, 
<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee">ThreadGroupsBasedOnTexture</a>, 
<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee">ThreadGroupsBasedOnUav</a>
 }</td></tr>
<tr class="separator:a297b925576b81843bd963d67ec561fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa2f584f8a3a801d850b6e16533bb14c5">HlmsComputeJob</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *creator, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;sourceFilename, const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;includedPieceFiles)</td></tr>
<tr class="separator:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824bf5717b6d72f11ad9772873044bcc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a824bf5717b6d72f11ad9772873044bcc">~HlmsComputeJob</a> ()</td></tr>
<tr class="separator:a824bf5717b6d72f11ad9772873044bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f01509a37d8699f43f520833053a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae1f01509a37d8699f43f520833053a3a">_calculateNumThreadGroupsBasedOnSetting</a> ()</td></tr>
<tr class="memdesc:ae1f01509a37d8699f43f520833053a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL USE.  <a href="#ae1f01509a37d8699f43f520833053a3a">More...</a><br /></td></tr>
<tr class="separator:ae1f01509a37d8699f43f520833053a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea49e86dfbc11d0e64f803823bb10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a94ea49e86dfbc11d0e64f803823bb10b">_getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:a94ea49e86dfbc11d0e64f803823bb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="#a94ea49e86dfbc11d0e64f803823bb10b">More...</a><br /></td></tr>
<tr class="separator:a94ea49e86dfbc11d0e64f803823bb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e207a03438ec6db03d518cf32a3f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a43e207a03438ec6db03d518cf32a3f73">_setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams)</td></tr>
<tr class="memdesc:a43e207a03438ec6db03d518cf32a3f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock directly.  <a href="#a43e207a03438ec6db03d518cf32a3f73">More...</a><br /></td></tr>
<tr class="separator:a43e207a03438ec6db03d518cf32a3f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523ca862e2ccf507953fa18ce79879d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a523ca862e2ccf507953fa18ce79879d8">_setUavBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *uavBuffer, <a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a> access, size_t offset=0, size_t sizeBytes=0)</td></tr>
<tr class="memdesc:a523ca862e2ccf507953fa18ce79879d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV buffer at the given slot ID.  <a href="#a523ca862e2ccf507953fa18ce79879d8">More...</a><br /></td></tr>
<tr class="separator:a523ca862e2ccf507953fa18ce79879d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479de119004a6825886c4114fbe9beb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a479de119004a6825886c4114fbe9beb1">_setUavTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;texture, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> textureArrayIndex, <a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a> access, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> mipmapLevel, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pixelFormat)</td></tr>
<tr class="memdesc:a479de119004a6825886c4114fbe9beb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV texture.  <a href="#a479de119004a6825886c4114fbe9beb1">More...</a><br /></td></tr>
<tr class="separator:a479de119004a6825886c4114fbe9beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8791e7cc76517dc3199245dc708875b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ad8791e7cc76517dc3199245dc708875b">_updateAutoProperties</a> (void)</td></tr>
<tr class="separator:ad8791e7cc76517dc3199245dc708875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1889df9a4e3d48946dcbe9d2db4d1ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab1889df9a4e3d48946dcbe9d2db4d1ba">clone</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;cloneName)</td></tr>
<tr class="separator:ab1889df9a4e3d48946dcbe9d2db4d1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a38b43354ffa974bb834c3a156bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab63a38b43354ffa974bb834c3a156bc9">cloneTo</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *dstJob)</td></tr>
<tr class="separator:ab63a38b43354ffa974bb834c3a156bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aeb470bf33ca307f270a4d10bc07a4f61">createShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:aeb470bf33ca307f270a4d10bc07a4f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set of shader paramters with a given key, e.g.  <a href="#aeb470bf33ca307f270a4d10bc07a4f61">More...</a><br /></td></tr>
<tr class="separator:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3e2b12b540fd71c6a06372c6489d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#acc3e2b12b540fd71c6a06372c6489d09">getCreator</a> (void) const </td></tr>
<tr class="separator:acc3e2b12b540fd71c6a06372c6489d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276dab97239bc244f5c12a3f9dd5a96f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a276dab97239bc244f5c12a3f9dd5a96f">getName</a> (void) const </td></tr>
<tr class="separator:a276dab97239bc244f5c12a3f9dd5a96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a2e768f2ee4f5b17dd4599f076d2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a9e8a2e768f2ee4f5b17dd4599f076d2f">getNumTexUnits</a> (void) const </td></tr>
<tr class="separator:a9e8a2e768f2ee4f5b17dd4599f076d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e3b890df6a127d1283f9591567af4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a759e3b890df6a127d1283f9591567af4">getNumThreadGroups</a> (void) const </td></tr>
<tr class="separator:a759e3b890df6a127d1283f9591567af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614b02ca298f89e3eea22425cde3e5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a614b02ca298f89e3eea22425cde3e5ef">getNumThreadGroupsX</a> (void) const </td></tr>
<tr class="separator:a614b02ca298f89e3eea22425cde3e5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20becd6f7490d74721165a4979ac773e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a20becd6f7490d74721165a4979ac773e">getNumThreadGroupsY</a> (void) const </td></tr>
<tr class="separator:a20becd6f7490d74721165a4979ac773e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da17bef6a5a294a728df1ec0b965079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8da17bef6a5a294a728df1ec0b965079">getNumThreadGroupsZ</a> (void) const </td></tr>
<tr class="separator:a8da17bef6a5a294a728df1ec0b965079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d56d6071ffd74f39bce13dcbc1a0249"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a5d56d6071ffd74f39bce13dcbc1a0249">getNumUavUnits</a> (void) const </td></tr>
<tr class="separator:a5d56d6071ffd74f39bce13dcbc1a0249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d1f056fb8e5d9b380feb0cc50693bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a67d1f056fb8e5d9b380feb0cc50693bd">getProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> defaultVal=0) const </td></tr>
<tr class="separator:a67d1f056fb8e5d9b380feb0cc50693bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa16d873ee37f1e1c5df313205665a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#afa16d873ee37f1e1c5df313205665a49">getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:afa16d873ee37f1e1c5df313205665a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="#afa16d873ee37f1e1c5df313205665a49">More...</a><br /></td></tr>
<tr class="separator:afa16d873ee37f1e1c5df313205665a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b812c67d51f62dacdbe9aaba9fb3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a392b812c67d51f62dacdbe9aaba9fb3a">getTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const </td></tr>
<tr class="separator:a392b812c67d51f62dacdbe9aaba9fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472d6ed769eaf5fbf592d2a69327901a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a472d6ed769eaf5fbf592d2a69327901a">getThreadsPerGroup</a> (void) const </td></tr>
<tr class="separator:a472d6ed769eaf5fbf592d2a69327901a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861208dd3fa53624b7b091e601242fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0861208dd3fa53624b7b091e601242fd">getThreadsPerGroupX</a> (void) const </td></tr>
<tr class="separator:a0861208dd3fa53624b7b091e601242fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a54ce87e944e0070fcb9180aedf910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab8a54ce87e944e0070fcb9180aedf910">getThreadsPerGroupY</a> (void) const </td></tr>
<tr class="separator:ab8a54ce87e944e0070fcb9180aedf910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c2ce2b2aa1407336edfb51b9163a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ac4c2ce2b2aa1407336edfb51b9163a30">getThreadsPerGroupZ</a> (void) const </td></tr>
<tr class="separator:ac4c2ce2b2aa1407336edfb51b9163a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394a0f270f938cd19d670f13d2da751c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a394a0f270f938cd19d670f13d2da751c">getUavBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const </td></tr>
<tr class="separator:a394a0f270f938cd19d670f13d2da751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72c7311776fa9457d2f1e55ddadb6d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa72c7311776fa9457d2f1e55ddadb6d1">getUavTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx) const </td></tr>
<tr class="separator:aa72c7311776fa9457d2f1e55ddadb6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21babd61f9615f4ccd589278437e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#abb21babd61f9615f4ccd589278437e95">removePiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName)</td></tr>
<tr class="memdesc:abb21babd61f9615f4ccd589278437e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing piece.  <a href="#abb21babd61f9615f4ccd589278437e95">More...</a><br /></td></tr>
<tr class="separator:abb21babd61f9615f4ccd589278437e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8057044899733d9a73ce7ddfd24d2bbe">removeTexUnit</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a8057044899733d9a73ce7ddfd24d2bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="#a8057044899733d9a73ce7ddfd24d2bbe">More...</a><br /></td></tr>
<tr class="separator:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086ffb8324b45010f16fcc6f5314dedd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a086ffb8324b45010f16fcc6f5314dedd">removeUavUnit</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a086ffb8324b45010f16fcc6f5314dedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="#a086ffb8324b45010f16fcc6f5314dedd">More...</a><br /></td></tr>
<tr class="separator:a086ffb8324b45010f16fcc6f5314dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a27bc9875aa0f3a2f23d7a8c8e3a6e469">setConstBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *constBuffer)</td></tr>
<tr class="memdesc:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a const/uniform bufferat the given slot ID.  <a href="#a27bc9875aa0f3a2f23d7a8c8e3a6e469">More...</a><br /></td></tr>
<tr class="separator:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84">setInformHlmsOfTextureData</a> (bool bInformHlms)</td></tr>
<tr class="memdesc:aea1aec87cba9ef66ee4b82267de4fb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values.  <a href="#aea1aec87cba9ef66ee4b82267de4fb84">More...</a><br /></td></tr>
<tr class="separator:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998857be120bb37963c7cb593f9bfdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc">setNumTexUnits</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a0998857be120bb37963c7cb593f9bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="#a0998857be120bb37963c7cb593f9bfdc">More...</a><br /></td></tr>
<tr class="separator:a0998857be120bb37963c7cb593f9bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62">setNumThreadGroups</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsX, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsY, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> numThreadGroupsZ)</td></tr>
<tr class="memdesc:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of groups of threads to dispatch.  <a href="#a80c6b47d60cba7f70ba182d1fc8d9d62">More...</a><br /></td></tr>
<tr class="separator:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8078ce6528c5604e2a61bb516c000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000">setNumThreadGroupsBasedOn</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> source, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> texSlot, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorX, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorY, <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> divisorZ)</td></tr>
<tr class="memdesc:a7ad8078ce6528c5604e2a61bb516c000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> resolution and the threads per group.  <a href="#a7ad8078ce6528c5604e2a61bb516c000">More...</a><br /></td></tr>
<tr class="separator:a7ad8078ce6528c5604e2a61bb516c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8697f4897980adba72a42619fe6a463b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b">setNumUavUnits</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a8697f4897980adba72a42619fe6a463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="#a8697f4897980adba72a42619fe6a463b">More...</a><br /></td></tr>
<tr class="separator:a8697f4897980adba72a42619fe6a463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#adcbb0de211ce8fd2ff8e0d9c869ecf90">setPiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;pieceContent)</td></tr>
<tr class="memdesc:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a piece, i.e.  <a href="#adcbb0de211ce8fd2ff8e0d9c869ecf90">More...</a><br /></td></tr>
<tr class="separator:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b558bb23efecb99c9976312caff06c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7b558bb23efecb99c9976312caff06c2">setProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> value)</td></tr>
<tr class="memdesc:a7b558bb23efecb99c9976312caff06c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary property to pass to the shader.  <a href="#a7b558bb23efecb99c9976312caff06c2">More...</a><br /></td></tr>
<tr class="separator:a7b558bb23efecb99c9976312caff06c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b1694992ac7ea73e3310fbb9b478b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a708b1694992ac7ea73e3310fbb9b478b">setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;refParams)</td></tr>
<tr class="memdesc:a708b1694992ac7ea73e3310fbb9b478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock based on reference parameters.  <a href="#a708b1694992ac7ea73e3310fbb9b478b">More...</a><br /></td></tr>
<tr class="separator:a708b1694992ac7ea73e3310fbb9b478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86096d96501a364e040064a70143d763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a86096d96501a364e040064a70143d763">setTexBuffer</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *texBuffer, size_t offset=0, size_t sizeBytes=0)</td></tr>
<tr class="memdesc:a86096d96501a364e040064a70143d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="#a86096d96501a364e040064a70143d763">More...</a><br /></td></tr>
<tr class="separator:a86096d96501a364e040064a70143d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03270d403b5f24b482c46184a4d7c89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a03270d403b5f24b482c46184a4d7c89a">setTexture</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> slotIdx, <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;texture, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams=0)</td></tr>
<tr class="memdesc:a03270d403b5f24b482c46184a4d7c89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="#a03270d403b5f24b482c46184a4d7c89a">More...</a><br /></td></tr>
<tr class="separator:a03270d403b5f24b482c46184a4d7c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6c36a6b27927381afeea6965b148b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1b6c36a6b27927381afeea6965b148b4">setThreadsPerGroup</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupX, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupY, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> threadsPerGroupZ)</td></tr>
<tr class="memdesc:a1b6c36a6b27927381afeea6965b148b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads per group.  <a href="#a1b6c36a6b27927381afeea6965b148b4">More...</a><br /></td></tr>
<tr class="separator:a1b6c36a6b27927381afeea6965b148b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae0a13b48d89c085d90419e793aa9c8b9">HlmsCompute</a></td></tr>
<tr class="separator:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a297b925576b81843bd963d67ec561fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">Ogre::HlmsComputeJob::ThreadGroupsBasedOn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf"></a>ThreadGroupsBasedOnNothing&#160;</td><td class="fielddoc">
<p>Disabled. (obey. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62" title="Sets the number of groups of threads to dispatch. ">setNumThreadGroups</a>) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee"></a>ThreadGroupsBasedOnTexture&#160;</td><td class="fielddoc">
<p>Based the number of thread groups on a texture. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000" title="Instead of calling setNumThreadGroups, Ogre can automatically deduce them based on the Texture resolu...">setNumThreadGroupsBasedOn</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee"></a>ThreadGroupsBasedOnUav&#160;</td><td class="fielddoc">
<p>Based the number of thread groups on a UAV. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000" title="Instead of calling setNumThreadGroups, Ogre can automatically deduce them based on the Texture resolu...">setNumThreadGroupsBasedOn</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa2f584f8a3a801d850b6e16533bb14c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::HlmsComputeJob::HlmsComputeJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>includedPieceFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a824bf5717b6d72f11ad9772873044bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::HlmsComputeJob::~HlmsComputeJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae1f01509a37d8699f43f520833053a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_calculateNumThreadGroupsBasedOnSetting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INTERNAL USE. </p>
<p>Calculates the number of thread groups as specified in </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000" title="Instead of calling setNumThreadGroups, Ogre can automatically deduce them based on the Texture resolu...">setNumThreadGroupsBasedOn</a>, overriding <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62" title="Sets the number of groups of threads to dispatch. ">setNumThreadGroups</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a94ea49e86dfbc11d0e64f803823bb10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a>* Ogre::HlmsComputeJob::_getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p>e.g. "default" "glsl" "hlsl". Returns null if doesn't exist. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aeb470bf33ca307f270a4d10bc07a4f61" title="Creates a set of shader paramters with a given key, e.g. ">createShaderParams</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43e207a03438ec6db03d518cf32a3f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock directly. </p>
<p>For internal use / advanced users. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumTexUnits</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refParams</td><td>Direct samplerblock. Reference count is assumed to already have been increased. We won't increase it ourselves. </td></tr>
    <tr><td class="paramname">params</td><td>The sampler block to use as reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a523ca862e2ccf507953fa18ce79879d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>uavBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV slots are shared with setUavTexture. Calling this function will remove the settings from previous setUavTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84" title="The Hlms has the ability to pass data to the shader source code via its syntax system to add hardcode...">setInformHlmsOfTextureData</a> is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumUavUnits</a>. The slot index to bind this UAV buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">access</td><td>Access. Should match what the shader expects. Needed by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to resolve memory barrier dependencies. </td></tr>
    <tr><td class="paramname">uavBuffer</td><td>UAV buffer to bind. </td></tr>
    <tr><td class="paramname">offset</td><td>0-based offset. It is possible to bind a region of the buffer. Offset needs to be aligned. You can query the RS capabilities for the alignment, however 256 bytes is the maximum allowed alignment per the OpenGL specification, making it a safe bet to hardcode. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>Size in bytes to bind the tex buffer. When zero, binds from offset until the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a479de119004a6825886c4114fbe9beb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>textureArrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_access.html#a732c0b8774d76d325e0749d09ce70aad">ResourceAccess::ResourceAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>mipmapLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV texture. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV buffer slots are shared with setUavTexture's. Calling this function will remove the settings from previous setUavBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84" title="The Hlms has the ability to pass data to the shader source code via its syntax system to add hardcode...">setInformHlmsOfTextureData</a> is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumUavUnits</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td></td></tr>
    <tr><td class="paramname">textureArrayIndex</td><td></td></tr>
    <tr><td class="paramname">access</td><td></td></tr>
    <tr><td class="paramname">mipmapLevel</td><td></td></tr>
    <tr><td class="paramname">pixelFormat</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8791e7cc76517dc3199245dc708875b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_updateAutoProperties </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1889df9a4e3d48946dcbe9d2db4d1ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a>* Ogre::HlmsComputeJob::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab63a38b43354ffa974bb834c3a156bc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::cloneTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td>
          <td class="paramname"><em>dstJob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb470bf33ca307f270a4d10bc07a4f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::createShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a set of shader paramters with a given key, e.g. </p>
<p>"default" "glsl" "hlsl". Does nothing if parameters already exist. </p>

</div>
</div>
<a class="anchor" id="acc3e2b12b540fd71c6a06372c6489d09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a>* Ogre::HlmsComputeJob::getCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a276dab97239bc244f5c12a3f9dd5a96f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::HlmsComputeJob::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e8a2e768f2ee4f5b17dd4599f076d2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumTexUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a759e3b890df6a127d1283f9591567af4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>* Ogre::HlmsComputeJob::getNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a614b02ca298f89e3eea22425cde3e5ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20becd6f7490d74721165a4979ac773e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da17bef6a5a294a728df1ec0b965079"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d56d6071ffd74f39bce13dcbc1a0249"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumUavUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a67d1f056fb8e5d9b380feb0cc50693bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a> Ogre::HlmsComputeJob::getProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>defaultVal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa16d873ee37f1e1c5df313205665a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a>&amp; Ogre::HlmsComputeJob::getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p>e.g. "default" "glsl" "hlsl". Creates if does not exist. </p>

</div>
</div>
<a class="anchor" id="a392b812c67d51f62dacdbe9aaba9fb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; Ogre::HlmsComputeJob::getTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a472d6ed769eaf5fbf592d2a69327901a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>* Ogre::HlmsComputeJob::getThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0861208dd3fa53624b7b091e601242fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8a54ce87e944e0070fcb9180aedf910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4c2ce2b2aa1407336edfb51b9163a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a394a0f270f938cd19d670f13d2da751c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::HlmsComputeJob::getUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa72c7311776fa9457d2f1e55ddadb6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; Ogre::HlmsComputeJob::getUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb21babd61f9615f4ccd589278437e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removePiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing piece. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#adcbb0de211ce8fd2ff8e0d9c869ecf90" title="Defines a piece, i.e. ">setPiece</a>. Does nothing if the piece didn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a8057044899733d9a73ce7ddfd24d2bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeTexUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a class="anchor" id="a086ffb8324b45010f16fcc6f5314dedd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeUavUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a class="anchor" id="a27bc9875aa0f3a2f23d7a8c8e3a6e469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>constBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a const/uniform bufferat the given slot ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>Slot to bind to. It's independent from the texture &amp; UAV ones. </td></tr>
    <tr><td class="paramname">constBuffer</td><td>Const buffer to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea1aec87cba9ef66ee4b82267de4fb84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setInformHlmsOfTextureData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInformHlms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values. </p>
<p>For example, you may want to unroll a loop based on the width of a texture for maximum performance. </p><dl class="section user"><dt></dt><dd>Enabling this feature informs the <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;. ">Hlms</a> to reparse the shader on any change to bound textures that could trigger a recompilation. If you don't need it, keep this feature disabled to prevent unnecessary recompilations. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bInformHlms</td><td>True to enable this feature, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0998857be120bb37963c7cb593f9bfdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumTexUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a class="anchor" id="a80c6b47d60cba7f70ba182d1fc8d9d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of groups of threads to dispatch. </p>
<p>Note the actual value may be changed by the shader template using the () function. These values are passed to the template as: num_thread_groups_x num_thread_groups_y num_thread_groups_z </p><dl class="section remark"><dt>Remarks</dt><dd>As an example, it's typical to do: numThreadGroupsX = ceil( threadsPerGroupX / image.width ); numThreadGroupsY = ceil( threadsPerGroupY / image.height ); </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad8078ce6528c5604e2a61bb516c000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroupsBasedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> resolution and the threads per group. </p>
<p>It is calculated as follows: scaledWidth = (textureWidth + divisorX - 1u) / divisorX; numThreadGroupsX = (scaledWidth + threadsPerGroupX - 1u) / threadsPerGroupX; </p><dl class="section remark"><dt>Remarks</dt><dd>Unless disabled, this will overwrite your setNumThreadGroups based on the texture bound at the time the job is dispatched. </dd></dl>
<dl class="section user"><dt></dt><dd>If no texture/uav is bound at the given slot (or no such slot exists), we will log a warning. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>What to use as source for the calculations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texSlot</td><td>Index of the texture/uav unit. </td></tr>
    <tr><td class="paramname">divisorX</td><td>divisorY divisorZ Often compute shaders operate on multiple pixels, thus you need less thread groups. For example if you operate on blocks of 2x2, then you want divisorX = 2 and divisorY = 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8697f4897980adba72a42619fe6a463b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumUavUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a class="anchor" id="adcbb0de211ce8fd2ff8e0d9c869ecf90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pieceContent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a piece, i.e. </p>
<p>the same as doing ( pieceName )pieceContent If the piece doesn't exist, it gets created. If the piece already exists, it gets overwritten. </p><dl class="section remark"><dt>Remarks</dt><dd>Because we need to efficiently track changes (to know when to recompile, when we can reuse a cached shader, etc), we store a property of the same name as pieceName with the hash of the piece's content as value. e.g. doing setPiece( pieceName, pieceContent ) implies calling setProperty( pieceName, hash( pieceContent ). Hence you should NOT manipulate mPieces directly, otherwise we won't see changes performed to it, or use shaders from a cache we shouldn't use. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieceName</td><td>Name of the piece. </td></tr>
    <tr><td class="paramname">pieceContent</td><td>The contents of the piece. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b558bb23efecb99c9976312caff06c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a1c37a43c04753c9ae0c17108c9e6c9d2">int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an arbitrary property to pass to the shader. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Will trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the property </td></tr>
    <tr><td class="paramname">value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708b1694992ac7ea73e3310fbb9b478b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock based on reference parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumTexUnits</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refParams</td><td>We'll create (or retrieve an existing) samplerblock based on the input parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86096d96501a364e040064a70143d763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_tex_buffer_packed.html">TexBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>texBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer slots are shared with setTexture's. Calling this function will remove the settings from previous setTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84" title="The Hlms has the ability to pass data to the shader source code via its syntax system to add hardcode...">setInformHlmsOfTextureData</a> is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Setting a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a> that could be used for writing is dangerous in explicit APIs (DX12, Vulkan). Use the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumTexUnits</a>. The slot index to bind this texture buffer In OpenGL, a few cards support between to 16-18 texture units, while most cards support up to 32 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texBuffer</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer to bind. </td></tr>
    <tr><td class="paramname">offset</td><td>0-based offset. It is possible to bind a region of the buffer. Offset needs to be aligned. You can query the RS capabilities for the alignment, however 256 bytes is the maximum allowed alignment per the OpenGL specification, making it a safe bet to hardcode. </td></tr>
    <tr><td class="paramname">sizeBytes</td><td>Size in bytes to bind the tex buffer. When zero, binds from offset until the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03270d403b5f24b482c46184a4d7c89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> slots are shared with setTexBuffer's. Calling this function will remove the settings from previous setTexBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>UAVs and Textures share the same slots in OpenGL, but don't in D3D11. For best compatibility, assume they're shared and put the UAVs in the first slots. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84" title="The Hlms has the ability to pass data to the shader source code via its syntax system to add hardcode...">setInformHlmsOfTextureData</a> is enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc" title="Creates &#39;numSlots&#39; number of slots before they can be set. ">setNumTexUnits</a>. The slot index to bind this texture In OpenGL, some cards support up to 16-18 texture units, while most cards support up to 32 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texBuffer</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> buffer to bind. </td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> to bind. </td></tr>
    <tr><td class="paramname">samplerblock</td><td>Optional. We'll create (or retrieve an existing) samplerblock based on the input parameters. When null, we leave the previously set samplerblock (if a texture is being set, and if no samplerblock was set, we'll create a default one) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b6c36a6b27927381afeea6965b148b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads per group. </p>
<p>Note the actual value may be changed by the shader template using the () function. These values are passed to the template as: threads_per_group_x threads_per_group_y threads_per_group_z </p><dl class="section remark"><dt>Remarks</dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae0a13b48d89c085d90419e793aa9c8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_ogre_1_1_hlms_compute.html">HlmsCompute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hlms_compute_job_8h.html">OgreHlmsComputeJob.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a></li>
    <li class="footer">Generated on Thu May 4 2017 22:21:40 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
