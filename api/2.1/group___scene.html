<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Scene<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_ogre_1_1v1"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_ogre_1_1v1.html">Ogre::v1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_ogre_1_1_visibility_flags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_ogre_1_1_visibility_flags.html">Ogre::VisibilityFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html">Ogre::AxisAlignedBoxSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialises the <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> class for querying within an axis aligned box.  <a href="class_ogre_1_1_axis_aligned_box_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_build_light_list_request.html">Ogre::BuildLightListRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_camera.html">Ogre::Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A viewpoint from which the scene will be rendered.  <a href="class_ogre_1_1_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_manager2.html">Ogre::CompositorManager2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main system for managing Render Targets through the use of nodes.  <a href="class_ogre_1_1_compositor_manager2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_pass_provider.html">Ogre::CompositorPassProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class that users can derive from in order to implement custom passes for the compositor.  <a href="class_ogre_1_1_compositor_pass_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_cull_frustum_request.html">Ogre::CullFrustumRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All variables are read-only for the worker threads.  <a href="struct_ogre_1_1_cull_frustum_request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_axis_aligned_box_scene_query.html">Ogre::DefaultAxisAlignedBoxSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <a class="el" href="class_ogre_1_1_axis_aligned_box_scene_query.html" title="Specialises the SceneQuery class for querying within an axis aligned box. ">AxisAlignedBoxSceneQuery</a>.  <a href="class_ogre_1_1_default_axis_aligned_box_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_intersection_scene_query.html">Ogre::DefaultIntersectionSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <a class="el" href="class_ogre_1_1_intersection_scene_query.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a>.  <a href="class_ogre_1_1_default_intersection_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_plane_bounded_volume_list_scene_query.html">Ogre::DefaultPlaneBoundedVolumeListSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume. ">PlaneBoundedVolumeListSceneQuery</a>.  <a href="class_ogre_1_1_default_plane_bounded_volume_list_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_ray_scene_query.html">Ogre::DefaultRaySceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <a class="el" href="class_ogre_1_1_ray_scene_query.html" title="Specialises the SceneQuery class for querying along a ray. ">RaySceneQuery</a>.  <a href="class_ogre_1_1_default_ray_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_scene_manager.html">Ogre::DefaultSceneManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default scene manager.  <a href="class_ogre_1_1_default_scene_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_scene_manager_factory.html">Ogre::DefaultSceneManagerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for default scene manager.  <a href="class_ogre_1_1_default_scene_manager_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_shadow_camera_setup.html">Ogre::DefaultShadowCameraSetup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements default shadow camera setup.  <a href="class_ogre_1_1_default_shadow_camera_setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_default_sphere_scene_query.html">Ogre::DefaultSphereSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <a class="el" href="class_ogre_1_1_sphere_scene_query.html" title="Specialises the SceneQuery class for querying within a sphere. ">SphereSceneQuery</a>.  <a href="class_ogre_1_1_default_sphere_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_focused_shadow_camera_setup.html">Ogre::FocusedShadowCameraSetup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the uniform shadow mapping algorithm in focused mode.  <a href="class_ogre_1_1_focused_shadow_camera_setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_instance_batch_cull_request.html">Ogre::InstanceBatchCullRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_intersection_scene_query.html">Ogre::IntersectionSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> class to query for pairs of objects which are possibly intersecting one another.  <a href="class_ogre_1_1_intersection_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_intersection_scene_query_listener.html">Ogre::IntersectionSceneQueryListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative listener class for dealing with <a class="el" href="class_ogre_1_1_intersection_scene_query.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a>.  <a href="class_ogre_1_1_intersection_scene_query_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_intersection_scene_query_result.html">Ogre::IntersectionSceneQueryResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the results of an intersection scene query (pair values).  <a href="struct_ogre_1_1_intersection_scene_query_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_item.html">Ogre::Item</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an instance of a discrete, movable object based on a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a>.  <a href="class_ogre_1_1_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_item_factory.html">Ogre::ItemFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FItemy object for creating <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a> instances.  <a href="class_ogre_1_1_item_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_light.html">Ogre::Light</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a dynamic light source in the scene.  <a href="class_ogre_1_1_light.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_light_factory.html">Ogre::LightFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory object for creating <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> instances.  <a href="class_ogre_1_1_light_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html">Ogre::MovableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class defining a movable object in a scene.  <a href="class_ogre_1_1_movable_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object_factory.html">Ogre::MovableObjectFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface definition for a factory class which produces a certain kind of <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>, and can be registered with <a class="el" href="class_ogre_1_1_root.html" title="The root class of the Ogre system. ">Root</a> in order to allow all clients to produce new instances of this object, integrated with the standard <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> processing.  <a href="class_ogre_1_1_movable_object_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_plane.html">Ogre::MovablePlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a <a class="el" href="class_ogre_1_1_plane.html" title="Defines a plane in 3D space. ">Plane</a> that may be attached to a node, and the derived details of it retrieved simply.  <a href="class_ogre_1_1_movable_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_node.html">Ogre::Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a general-purpose node an articulated scene graph.  <a href="class_ogre_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_null_entity.html">Ogre::NullEntity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html">Ogre::PlaneBoundedVolumeListSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialises the <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> class for querying within a plane-bounded volume.  <a href="class_ogre_1_1_plane_bounded_volume_list_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the plane optimal shadow camera algorithm.  <a href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html">Ogre::PSSMShadowCameraSetup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel Split Shadow Map (PSSM) shadow camera setup.  <a href="class_ogre_1_1_p_s_s_m_shadow_camera_setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ray_scene_query.html">Ogre::RaySceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialises the <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> class for querying along a ray.  <a href="class_ogre_1_1_ray_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ray_scene_query_listener.html">Ogre::RaySceneQueryListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative listener class for dealing with <a class="el" href="class_ogre_1_1_ray_scene_query.html" title="Specialises the SceneQuery class for querying along a ray. ">RaySceneQuery</a>.  <a href="class_ogre_1_1_ray_scene_query_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_ray_scene_query_result_entry.html">Ogre::RaySceneQueryResultEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct allows a single comparison of result data no matter what the type.  <a href="struct_ogre_1_1_ray_scene_query_result_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_region_scene_query.html">Ogre::RegionSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class defining a query which returns single results from a region.  <a href="class_ogre_1_1_region_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_renderable.html">Ogre::Renderable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class defining the interface all renderable objects must implement.  <a href="class_ogre_1_1_renderable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_renderable_animated.html">Ogre::RenderableAnimated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the organisation and rendering of a 'scene' i.e.  <a href="class_ogre_1_1_scene_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager_enumerator.html">Ogre::SceneManagerEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> classes available to applications.  <a href="class_ogre_1_1_scene_manager_enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_manager_factory.html">Ogre::SceneManagerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which will create instances of a given <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>.  <a href="class_ogre_1_1_scene_manager_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_manager_meta_data.html">Ogre::SceneManagerMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing information about a scene manager.  <a href="struct_ogre_1_1_scene_manager_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a node in the scene graph.  <a href="class_ogre_1_1_scene_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_query.html">Ogre::SceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for performing queries on a scene.  <a href="class_ogre_1_1_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_scene_query_listener.html">Ogre::SceneQueryListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This optional class allows you to receive per-result callbacks from <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> executions instead of a single set of consolidated results.  <a href="class_ogre_1_1_scene_query_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_scene_query_result.html">Ogre::SceneQueryResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the results of a scene query.  <a href="struct_ogre_1_1_scene_query_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_camera_setup.html">Ogre::ShadowCameraSetup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows you to plug in new ways to define the camera setup when rendering and projecting shadow textures.  <a href="class_ogre_1_1_shadow_camera_setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_shadow_texture_config.html">Ogre::ShadowTextureConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing the configuration for one shadow texture.  <a href="struct_ogre_1_1_shadow_texture_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_texture_manager.html">Ogre::ShadowTextureManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to manage the available shadow textures which may be shared between many <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> instances if formats agree.  <a href="class_ogre_1_1_shadow_texture_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_volume_extrude_program.html">Ogre::ShadowVolumeExtrudeProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class containing source for vertex programs for extruding shadow volumes.  <a href="class_ogre_1_1_shadow_volume_extrude_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_sphere_scene_query.html">Ogre::SphereSceneQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialises the <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> class for querying within a sphere.  <a href="class_ogre_1_1_sphere_scene_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_static_face_group.html">Ogre::StaticFaceGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a group of static i.e.  <a href="struct_ogre_1_1_static_face_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_sub_item.html">Ogre::SubItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class which defines the sub-parts of an <a class="el" href="class_ogre_1_1_item.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Item</a>.  <a href="class_ogre_1_1_sub_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_update_lod_request.html">Ogre::UpdateLodRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_update_transform_request.html">Ogre::UpdateTransformRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_user_object_bindings.html">Ogre::UserObjectBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides convenient interface to establish a linkage between custom user application objects and <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> core classes.  <a href="class_ogre_1_1_user_object_bindings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_base_instance_batch_v_t_f.html">Ogre::v1::BaseInstanceBatchVTF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instancing implementation using vertex texture through Vertex <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Fetch (VTF) This implementation has the following advantages: Supports huge amount of instances per batch Supports skinning even with huge ammounts of instances per batch Doesn't need shader constants registers.  <a href="class_ogre_1_1v1_1_1_base_instance_batch_v_t_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_entity.html">Ogre::v1::Entity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an instance of a discrete, movable object based on a <a class="el" href="class_ogre_1_1v1_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a>.  <a href="class_ogre_1_1v1_1_1_entity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_entity_factory.html">Ogre::v1::EntityFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory object for creating <a class="el" href="class_ogre_1_1v1_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> instances.  <a href="class_ogre_1_1v1_1_1_entity_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html">Ogre::v1::InstanceBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> forms part of the new Instancing system This is an abstract class that must be derived to implement different instancing techniques (.  <a href="class_ogre_1_1v1_1_1_instance_batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_h_w.html">Ogre::v1::InstanceBatchHW</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is technique requires true instancing hardware support.  <a href="class_ogre_1_1v1_1_1_instance_batch_h_w.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_h_w___v_t_f.html">Ogre::v1::InstanceBatchHW_VTF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instancing implementation using vertex texture through Vertex <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Fetch (VTF) and hardware instancing.  <a href="class_ogre_1_1v1_1_1_instance_batch_h_w___v_t_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_shader.html">Ogre::v1::InstanceBatchShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same technique the old "InstancedGeometry" implementation used (with improvements).  <a href="class_ogre_1_1v1_1_1_instance_batch_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_v_t_f.html">Ogre::v1::InstanceBatchVTF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">Ogre::v1::InstancedEntity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">Ogre::v1::InstanceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main starting point for the new instancing system.  <a href="class_ogre_1_1v1_1_1_instance_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1v1_1_1_instance_manager_cmp.html">Ogre::v1::InstanceManagerCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_manual_object.html">Ogre::v1::ManualObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing a much simplified interface to generating manual objects with custom geometry.  <a href="class_ogre_1_1v1_1_1_manual_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_manual_object_factory.html">Ogre::v1::ManualObjectFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory object for creating <a class="el" href="class_ogre_1_1v1_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a> instances.  <a href="class_ogre_1_1v1_1_1_manual_object_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_old_node.html">Ogre::v1::OldNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a general-purpose <a class="el" href="class_ogre_1_1v1_1_1_old_node.html" title="Class representing a general-purpose OldNode an articulated scene graph. ">OldNode</a> an articulated scene graph.  <a href="class_ogre_1_1v1_1_1_old_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_old_skeleton_instance.html">Ogre::v1::OldSkeletonInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_ogre_1_1v1_1_1_old_skeleton_instance.html" title="A OldSkeletonInstance is a single instance of a Skeleton used by a world object. ">OldSkeletonInstance</a> is a single instance of a <a class="el" href="class_ogre_1_1v1_1_1_skeleton.html" title="A collection of OldBone objects used to animate a skinned mesh. ">Skeleton</a> used by a world object.  <a href="class_ogre_1_1v1_1_1_old_skeleton_instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d.html">Ogre::v1::Rectangle2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the rendering of a simple 2D rectangle This class renders a simple 2D rectangle; this rectangle has no depth and therefore is best used with 'depth_write off' materials.  <a href="class_ogre_1_1v1_1_1_rectangle2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_rectangle2_d_factory.html">Ogre::v1::Rectangle2DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory object for creating <a class="el" href="class_ogre_1_1v1_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> instances.  <a href="class_ogre_1_1v1_1_1_rectangle2_d_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_simple_renderable.html">Ogre::v1::SimpleRenderable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> and <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> for single-part custom objects.  <a href="class_ogre_1_1v1_1_1_simple_renderable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_static_geometry.html">Ogre::v1::StaticGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-transforms and batches up meshes for efficient use as static geometry in a scene.  <a href="class_ogre_1_1v1_1_1_static_geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_sub_entity.html">Ogre::v1::SubEntity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class which defines the sub-parts of an <a class="el" href="class_ogre_1_1v1_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a>.  <a href="class_ogre_1_1v1_1_1_sub_entity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_wire_bounding_box.html">Ogre::v1::WireBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the rendering of a wireframe bounding box.  <a href="class_ogre_1_1v1_1_1_wire_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_view_point.html">Ogre::ViewPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for holding a position &amp; orientation pair.  <a href="struct_ogre_1_1_view_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga40acba93d9441f2bccfa096b641c887d"><td class="memItemLeft" align="right" valign="top">typedef ConstVectorIterator&lt; ShadowTextureConfigList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga40acba93d9441f2bccfa096b641c887d">Ogre::ConstShadowTextureConfigIterator</a></td></tr>
<tr class="separator:ga40acba93d9441f2bccfa096b641c887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa05da2bbcd7dd55f2b78e592b9d47e"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; Vector4 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2fa05da2bbcd7dd55f2b78e592b9d47e">Ogre::v1::InstanceBatch::CustomParamsVec</a></td></tr>
<tr class="separator:ga2fa05da2bbcd7dd55f2b78e592b9d47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e654731a11ddd85237cc4a129f4d2c9"><td class="memItemLeft" align="right" valign="top">typedef ConstVectorIterator&lt; InstanceBatchVec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga1e654731a11ddd85237cc4a129f4d2c9">Ogre::v1::InstanceManager::InstanceBatchIterator</a></td></tr>
<tr class="separator:ga1e654731a11ddd85237cc4a129f4d2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ee64c2bccdfd498b2c1cbf130da9b0"><td class="memItemLeft" align="right" valign="top">typedef ConstMapIterator&lt; InstanceBatchMap &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga19ee64c2bccdfd498b2c1cbf130da9b0">Ogre::v1::InstanceManager::InstanceBatchMapIterator</a></td></tr>
<tr class="separator:ga19ee64c2bccdfd498b2c1cbf130da9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89807ff7d5dc42c1a44a3a729e47cf51"><td class="memItemLeft" align="right" valign="top">typedef FastArray&lt; InstancedEntity * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga89807ff7d5dc42c1a44a3a729e47cf51">Ogre::v1::InstanceBatch::InstancedEntityArray</a></td></tr>
<tr class="separator:ga89807ff7d5dc42c1a44a3a729e47cf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ff13a5af164d4eaaa1ebbe40570c93"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; InstancedEntity * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga23ff13a5af164d4eaaa1ebbe40570c93">Ogre::v1::InstanceBatch::InstancedEntityVec</a></td></tr>
<tr class="separator:ga23ff13a5af164d4eaaa1ebbe40570c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0db569747448aeff27f36ecd717686"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; RaySceneQueryResultEntry &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga1d0db569747448aeff27f36ecd717686">Ogre::RaySceneQueryResult</a></td></tr>
<tr class="separator:ga1d0db569747448aeff27f36ecd717686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2456530a54d76fba2d659954fc243c9"><td class="memItemLeft" align="right" valign="top">typedef FastArray&lt; Renderable * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac2456530a54d76fba2d659954fc243c9">Ogre::RenderableArray</a></td></tr>
<tr class="separator:gac2456530a54d76fba2d659954fc243c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcc5a6779ee6a6bb82aeb5f42239a52"><td class="memItemLeft" align="right" valign="top">typedef list&lt; SceneQueryMovableObjectPair &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaddcc5a6779ee6a6bb82aeb5f42239a52">Ogre::SceneQueryMovableIntersectionList</a></td></tr>
<tr class="separator:gaddcc5a6779ee6a6bb82aeb5f42239a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ca4f17a1e8bb7381446ae6235869d8"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; MovableObject *, MovableObject * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa1ca4f17a1e8bb7381446ae6235869d8">Ogre::SceneQueryMovableObjectPair</a></td></tr>
<tr class="separator:gaa1ca4f17a1e8bb7381446ae6235869d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f394829e3a85cea6faa915ac391653"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; MovableObject *, SceneQuery::WorldFragment * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae8f394829e3a85cea6faa915ac391653">Ogre::SceneQueryMovableObjectWorldFragmentPair</a></td></tr>
<tr class="separator:gae8f394829e3a85cea6faa915ac391653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e63733116c49a9931a2989a2cfe1b51"><td class="memItemLeft" align="right" valign="top">typedef list&lt; SceneQueryMovableObjectWorldFragmentPair &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2e63733116c49a9931a2989a2cfe1b51">Ogre::SceneQueryMovableWorldFragmentIntersectionList</a></td></tr>
<tr class="separator:ga2e63733116c49a9931a2989a2cfe1b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79dcd1262d117ecf4d51a5f555d3071"><td class="memItemLeft" align="right" valign="top">typedef list&lt; MovableObject * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gad79dcd1262d117ecf4d51a5f555d3071">Ogre::SceneQueryResultMovableList</a></td></tr>
<tr class="separator:gad79dcd1262d117ecf4d51a5f555d3071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9005a54a736be79548ebcdf69dfd448"><td class="memItemLeft" align="right" valign="top">typedef list&lt; SceneQuery::WorldFragment * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gad9005a54a736be79548ebcdf69dfd448">Ogre::SceneQueryResultWorldFragmentList</a></td></tr>
<tr class="separator:gad9005a54a736be79548ebcdf69dfd448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b6dbd7bf722582a21fcc25d25f73ed"><td class="memItemLeft" align="right" valign="top">typedef uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa4b6dbd7bf722582a21fcc25d25f73ed">Ogre::SceneTypeMask</a></td></tr>
<tr class="memdesc:gaa4b6dbd7bf722582a21fcc25d25f73ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask containing scene types.  <a href="group___scene.html#gaa4b6dbd7bf722582a21fcc25d25f73ed">More...</a><br /></td></tr>
<tr class="separator:gaa4b6dbd7bf722582a21fcc25d25f73ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f71238039ee719563bf5202d80ff41a"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; ShadowTextureConfig &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga0f71238039ee719563bf5202d80ff41a">Ogre::ShadowTextureConfigList</a></td></tr>
<tr class="separator:ga0f71238039ee719563bf5202d80ff41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9befe4ef9c189ac3f2e016a63d560c67"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; TexturePtr &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9befe4ef9c189ac3f2e016a63d560c67">Ogre::ShadowTextureList</a></td></tr>
<tr class="separator:ga9befe4ef9c189ac3f2e016a63d560c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d6e53236b998db135989521a8ad3ba"><td class="memItemLeft" align="right" valign="top">typedef FastArray&lt; MovableObject::MovableObjectArray &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga06d6e53236b998db135989521a8ad3ba">Ogre::VisibleObjectsPerRq</a></td></tr>
<tr class="separator:ga06d6e53236b998db135989521a8ad3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ffab3c275854b773dcd9efeba9152c"><td class="memItemLeft" align="right" valign="top">typedef FastArray&lt; VisibleObjectsPerRq &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga21ffab3c275854b773dcd9efeba9152c">Ogre::VisibleObjectsPerThreadArray</a></td></tr>
<tr class="separator:ga21ffab3c275854b773dcd9efeba9152c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2967aa471d9b4bbba11ba6b6f4fc90d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2967aa471d9b4bbba11ba6b6f4fc90d7">Ogre::v1::InstanceManager::BatchSettingId</a> { <a class="el" href="group___scene.html#gga2967aa471d9b4bbba11ba6b6f4fc90d7a085acc2737e2f4480820ab5af1e95b84">Ogre::v1::InstanceManager::CAST_SHADOWS</a> = 0, 
<a class="el" href="group___scene.html#gga2967aa471d9b4bbba11ba6b6f4fc90d7a8bc207bbcf78bd642d321a11692d535c">Ogre::v1::InstanceManager::SHOW_BOUNDINGBOX</a>, 
<a class="el" href="group___scene.html#gga2967aa471d9b4bbba11ba6b6f4fc90d7a6c974a9d3981cc6c80771e80e53adee0">Ogre::v1::InstanceManager::NUM_SETTINGS</a>
 }<tr class="memdesc:ga2967aa471d9b4bbba11ba6b6f4fc90d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to be used in setSetting() &amp; BatchSettings::setting.  <a href="group___scene.html#ga2967aa471d9b4bbba11ba6b6f4fc90d7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga2967aa471d9b4bbba11ba6b6f4fc90d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c11c8a17d7bbfc5aab6f982fb0d7f38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga7c11c8a17d7bbfc5aab6f982fb0d7f38">Ogre::FaceGroupType</a> { <a class="el" href="group___scene.html#gga7c11c8a17d7bbfc5aab6f982fb0d7f38a06ae7e34bd024924db27d7a490c545e4">Ogre::FGT_FACE_LIST</a>, 
<a class="el" href="group___scene.html#gga7c11c8a17d7bbfc5aab6f982fb0d7f38ab0cfe6b33db8e2804a5f50ae51d59ff5">Ogre::FGT_PATCH</a>, 
<a class="el" href="group___scene.html#gga7c11c8a17d7bbfc5aab6f982fb0d7f38a8d46b5184ac4f071e0f287f89e1b253b">Ogre::FGT_UNKNOWN</a>
 }<tr class="memdesc:ga7c11c8a17d7bbfc5aab6f982fb0d7f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of face group, i.e.  <a href="group___scene.html#ga7c11c8a17d7bbfc5aab6f982fb0d7f38">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7c11c8a17d7bbfc5aab6f982fb0d7f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdc1f95714df3401447297dd6385e9c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">Ogre::v1::InstanceManager::InstancingTechnique</a> { <br />
&#160;&#160;<a class="el" href="group___scene.html#gga7fdc1f95714df3401447297dd6385e9cadfb4aa0d4d7162235a1937f515bbf5fc">Ogre::v1::InstanceManager::ShaderBased</a>, 
<a class="el" href="group___scene.html#gga7fdc1f95714df3401447297dd6385e9ca2d7dd23d906f7239d9d6efda7bdba0a4">Ogre::v1::InstanceManager::TextureVTF</a>, 
<a class="el" href="group___scene.html#gga7fdc1f95714df3401447297dd6385e9ca39d441de5b145d1dcb81d70d508364aa">Ogre::v1::InstanceManager::HWInstancingBasic</a>, 
<a class="el" href="group___scene.html#gga7fdc1f95714df3401447297dd6385e9ca2f6a94740a2286151bd6d7796fd3059c">Ogre::v1::InstanceManager::HWInstancingVTF</a>, 
<br />
&#160;&#160;<a class="el" href="group___scene.html#gga7fdc1f95714df3401447297dd6385e9ca4735c060474d8473f924f9f08e57a9cd">Ogre::v1::InstanceManager::InstancingTechniquesCount</a>
<br />
 }</td></tr>
<tr class="separator:ga7fdc1f95714df3401447297dd6385e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd170d87744deec0ca8dd1730797be7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">Ogre::InstancingThreadedCullingMethod</a> { <a class="el" href="group___scene.html#ggafdd170d87744deec0ca8dd1730797be7ada21a76062e79007f34578a11c6be140">Ogre::INSTANCING_CULLING_SINGLETHREAD</a>, 
<a class="el" href="group___scene.html#ggafdd170d87744deec0ca8dd1730797be7a2af3eec2c36adea6197588fe5b768361">Ogre::INSTANCING_CULLING_THREADED</a>
 }<tr class="memdesc:gafdd170d87744deec0ca8dd1730797be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are two Instancing techniques that perform culling of their own: HW Basic HW VTF Frustum culling is highly parallelizable &amp; scalable.  <a href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gafdd170d87744deec0ca8dd1730797be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7383602bd480d43b80c626969b9af914"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga7383602bd480d43b80c626969b9af914">Ogre::SceneType</a> { <br />
&#160;&#160;<a class="el" href="group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">Ogre::ST_GENERIC</a> = 1, 
<a class="el" href="group___scene.html#gga7383602bd480d43b80c626969b9af914ae83ae1c9a6e4816184441db4a140e70a">Ogre::ST_EXTERIOR_CLOSE</a> = 2, 
<a class="el" href="group___scene.html#gga7383602bd480d43b80c626969b9af914a8bf5864d5ab311e0512ed153c95f1d13">Ogre::ST_EXTERIOR_FAR</a> = 4, 
<a class="el" href="group___scene.html#gga7383602bd480d43b80c626969b9af914a7eecd7057b3487616075032560582ec1">Ogre::ST_EXTERIOR_REAL_FAR</a> = 8, 
<br />
&#160;&#160;<a class="el" href="group___scene.html#gga7383602bd480d43b80c626969b9af914a93f2170ad3a8132f29264dc3642a2dcf">Ogre::ST_INTERIOR</a> = 16
<br />
 }<tr class="memdesc:ga7383602bd480d43b80c626969b9af914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classification of a scene to allow a decision of what type of SceenManager to provide back to the application.  <a href="group___scene.html#ga7383602bd480d43b80c626969b9af914">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7383602bd480d43b80c626969b9af914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6f72945f07940bb090ba9d5d83d2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga1e6f72945f07940bb090ba9d5d83d2b7">Ogre::v1::InstanceBatch::SkeletalAnimationMode</a> { <a class="el" href="group___scene.html#gga1e6f72945f07940bb090ba9d5d83d2b7a9d5463190ddccc578f823e327238f0a0">Ogre::v1::InstanceBatch::SKELETONS_NOT_SUPPORTED</a>, 
<a class="el" href="group___scene.html#gga1e6f72945f07940bb090ba9d5d83d2b7a37e606fe5cf67a5985affda126b55bd7">Ogre::v1::InstanceBatch::SKELETONS_SUPPORTED</a>, 
<a class="el" href="group___scene.html#gga1e6f72945f07940bb090ba9d5d83d2b7a15429254436d351993ba886f5013f650">Ogre::v1::InstanceBatch::SKELETONS_LUT</a>
 }</td></tr>
<tr class="separator:ga1e6f72945f07940bb090ba9d5d83d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae2d9033e976a32ee3899ff54444656b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae2d9033e976a32ee3899ff54444656b3">Ogre::v1::BaseInstanceBatchVTF::BaseInstanceBatchVTF</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:gae2d9033e976a32ee3899ff54444656b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48ac197cb6a78a50d14092531252cf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf48ac197cb6a78a50d14092531252cf0">Ogre::v1::InstanceManager::BatchSettings::BatchSettings</a> ()</td></tr>
<tr class="separator:gaf48ac197cb6a78a50d14092531252cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3bd6578fdeb109bde90d2a903ed29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac9d3bd6578fdeb109bde90d2a903ed29">Ogre::v1::InstanceBatch::InstanceBatch</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:gac9d3bd6578fdeb109bde90d2a903ed29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e6b45e3c344b00394c15922e3b8978"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga88e6b45e3c344b00394c15922e3b8978">Ogre::v1::InstanceBatchHW::InstanceBatchHW</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:ga88e6b45e3c344b00394c15922e3b8978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b498351c48df149cac9442d3c01effb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4b498351c48df149cac9442d3c01effb">Ogre::v1::InstanceBatchHW_VTF::InstanceBatchHW_VTF</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:ga4b498351c48df149cac9442d3c01effb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26ce339cab52285adf0f73570ccdda1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae26ce339cab52285adf0f73570ccdda1">Ogre::v1::InstanceBatchShader::InstanceBatchShader</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:gae26ce339cab52285adf0f73570ccdda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa374617a651fa3affce8112d788e2005"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa374617a651fa3affce8112d788e2005">Ogre::v1::InstanceBatchVTF::InstanceBatchVTF</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceManager *creator, MeshPtr &amp;meshReference, const MaterialPtr &amp;material, size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap)</td></tr>
<tr class="separator:gaa374617a651fa3affce8112d788e2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79f2646082998289090e03579eeeb32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac79f2646082998289090e03579eeeb32">Ogre::v1::InstancedEntity::InstancedEntity</a> (IdType id, ObjectMemoryManager *objectMemoryManager, InstanceBatch *batchOwner, uint32 instanceID, BoneMemoryManager *boneMemoryManager, InstancedEntity *sharedTransformEntity=NULL)</td></tr>
<tr class="separator:gac79f2646082998289090e03579eeeb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43758a4af382127188ea182fd0bb80f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gab43758a4af382127188ea182fd0bb80f">Ogre::v1::InstanceManager::InstanceManager</a> (IdString customName, SceneManager *sceneManager, const String &amp;meshName, const String &amp;groupName, InstancingTechnique instancingTechnique, uint16 instancingFlags, size_t instancesPerBatch, unsigned short subMeshIdx, bool useBoneMatrixLookup=false)</td></tr>
<tr class="separator:gab43758a4af382127188ea182fd0bb80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5054c355d42f7f4dd743ecdc0f0b3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabb5054c355d42f7f4dd743ecdc0f0b3b">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::SendAllAnimatedTransformsToTexture</a> (float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> dstPtr, size_t floatsPerEntity, size_t entitiesPerPadding, size_t widthFloatsPadding, const Mesh::IndexMap *indexMap)</td></tr>
<tr class="separator:gabb5054c355d42f7f4dd743ecdc0f0b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63db4ef82b66e9c55dc4b9d803606a78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga63db4ef82b66e9c55dc4b9d803606a78">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::SendAllDualQuatTexture</a> (float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> dstPtr, size_t floatsPerEntity, size_t entitiesPerPadding, size_t widthFloatsPadding, const Mesh::IndexMap *indexMap)</td></tr>
<tr class="separator:ga63db4ef82b66e9c55dc4b9d803606a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571974cd58809b8c5ce63620fc86c3c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga571974cd58809b8c5ce63620fc86c3c1">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::SendAllLUTToTexture</a> (float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> dstPtr, size_t floatsPerEntity, size_t entitiesPerPadding, size_t widthFloatsPadding, const Mesh::IndexMap *indexMap, size_t numLutEntries)</td></tr>
<tr class="separator:ga571974cd58809b8c5ce63620fc86c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf783b19d3492b761e1c0b650a66027b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf783b19d3492b761e1c0b650a66027b8">Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::SendAllSingleTransformsToTexture</a> (float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> dstPtr, size_t floatsPerEntity, size_t entitiesPerPadding, size_t widthFloatsPadding)</td></tr>
<tr class="separator:gaf783b19d3492b761e1c0b650a66027b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc28239efa3546b077d1e0fe1d3e12d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gacc28239efa3546b077d1e0fe1d3e12d7">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::TransformsToTexture</a> (float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> dstPtr, size_t floatsPerEntity, size_t entitiesPerPadding, size_t widthFloatsPadding)</td></tr>
<tr class="separator:gacc28239efa3546b077d1e0fe1d3e12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2fe649857ef718be82eb64b346c1885"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae2fe649857ef718be82eb64b346c1885">Ogre::v1::BaseInstanceBatchVTF::~BaseInstanceBatchVTF</a> ()</td></tr>
<tr class="separator:gae2fe649857ef718be82eb64b346c1885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8681105efed6245a09f6198214a38363"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8681105efed6245a09f6198214a38363">Ogre::v1::InstanceBatch::~InstanceBatch</a> ()</td></tr>
<tr class="separator:ga8681105efed6245a09f6198214a38363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737709f41ca7a4d81756ba055172c680"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga737709f41ca7a4d81756ba055172c680">Ogre::v1::InstanceBatchHW::~InstanceBatchHW</a> ()</td></tr>
<tr class="separator:ga737709f41ca7a4d81756ba055172c680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc173a3772c6a3906167383bc84d48a7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gadc173a3772c6a3906167383bc84d48a7">Ogre::v1::InstanceBatchHW_VTF::~InstanceBatchHW_VTF</a> ()</td></tr>
<tr class="separator:gadc173a3772c6a3906167383bc84d48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacb8a6ee03c316412937adf6f5318fd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabacb8a6ee03c316412937adf6f5318fd">Ogre::v1::InstanceBatchShader::~InstanceBatchShader</a> ()</td></tr>
<tr class="separator:gabacb8a6ee03c316412937adf6f5318fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ec0b0516a94eba081c81c246057356"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga60ec0b0516a94eba081c81c246057356">Ogre::v1::InstanceBatchVTF::~InstanceBatchVTF</a> ()</td></tr>
<tr class="separator:ga60ec0b0516a94eba081c81c246057356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc8266bb3f7ad80da6def68c9d30b17"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabdc8266bb3f7ad80da6def68c9d30b17">Ogre::v1::InstancedEntity::~InstancedEntity</a> ()</td></tr>
<tr class="separator:gabdc8266bb3f7ad80da6def68c9d30b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db6075c0163ce6ec14e64938c6d174f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2db6075c0163ce6ec14e64938c6d174f">Ogre::v1::InstanceManager::~InstanceManager</a> ()</td></tr>
<tr class="separator:ga2db6075c0163ce6ec14e64938c6d174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f241cd9a3e9b1ee1622163c7d0829a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2f241cd9a3e9b1ee1622163c7d0829a2">Ogre::v1::InstanceManager::_addDirtyStaticBatch</a> (InstanceBatch *dirtyBatch)</td></tr>
<tr class="memdesc:ga2f241cd9a3e9b1ee1622163c7d0829a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by an <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> when it requests their bounds to be updated for proper culling.  <a href="#ga2f241cd9a3e9b1ee1622163c7d0829a2">More...</a><br /></td></tr>
<tr class="separator:ga2f241cd9a3e9b1ee1622163c7d0829a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2bd7d7a5bc859c802e111fba414f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gacc2bd7d7a5bc859c802e111fba414f90">Ogre::v1::InstanceManager::_addToDynamicBatchList</a> (InstanceBatch *dynamicBatch)</td></tr>
<tr class="memdesc:gacc2bd7d7a5bc859c802e111fba414f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kees the batch in the dynamic batch list so that it gets updated every frame.  <a href="#gacc2bd7d7a5bc859c802e111fba414f90">More...</a><br /></td></tr>
<tr class="separator:gacc2bd7d7a5bc859c802e111fba414f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb48419449394b820485f54c5febf67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9eb48419449394b820485f54c5febf67">Ogre::v1::InstanceBatchHW_VTF::_boundsDirty</a> (void)</td></tr>
<tr class="separator:ga9eb48419449394b820485f54c5febf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1604a1c98bad54429249d45d6f94e10b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga1604a1c98bad54429249d45d6f94e10b">Ogre::v1::InstanceBatch::_defragmentBatch</a> (bool optimizeCulling, InstancedEntityVec &amp;usedEntities, CustomParamsVec &amp;usedParams)</td></tr>
<tr class="separator:ga1604a1c98bad54429249d45d6f94e10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ecf9a4eb3688cafb89e70a1ac20676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga56ecf9a4eb3688cafb89e70a1ac20676">Ogre::v1::InstanceBatch::_defragmentBatchDiscard</a> (void)</td></tr>
<tr class="separator:ga56ecf9a4eb3688cafb89e70a1ac20676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4c1808d81ef3723cefc4207a469ee7"><td class="memItemLeft" align="right" valign="top">const Vector4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaba4c1808d81ef3723cefc4207a469ee7">Ogre::v1::InstanceBatch::_getCustomParam</a> (InstancedEntity *instancedEntity, unsigned char idx)</td></tr>
<tr class="separator:gaba4c1808d81ef3723cefc4207a469ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2771c64b4fa90c0c076ea0144452203"><td class="memItemLeft" align="right" valign="top">const Mesh::IndexMap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae2771c64b4fa90c0c076ea0144452203">Ogre::v1::InstanceBatch::_getIndexToBoneMap</a> () const </td></tr>
<tr class="separator:gae2771c64b4fa90c0c076ea0144452203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338ae51c463d14322ba84e80be98f622"><td class="memItemLeft" align="right" valign="top">MeshPtr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga338ae51c463d14322ba84e80be98f622">Ogre::v1::InstanceBatch::_getMeshRef</a> ()</td></tr>
<tr class="separator:ga338ae51c463d14322ba84e80be98f622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43254f8c9fae9547a90b72d983b8af1d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">Ogre::v1::MeshPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga43254f8c9fae9547a90b72d983b8af1d">Ogre::v1::InstanceBatch::_getMeshReference</a> (void) const </td></tr>
<tr class="separator:ga43254f8c9fae9547a90b72d983b8af1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5464503278d3c32dcd2dddd489ec0b"><td class="memItemLeft" align="right" valign="top">InstanceBatch *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9b5464503278d3c32dcd2dddd489ec0b">Ogre::v1::InstancedEntity::_getOwner</a> () const </td></tr>
<tr class="separator:ga9b5464503278d3c32dcd2dddd489ec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cddd2ae271b01ffdd8bc3b4296ea62c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga0cddd2ae271b01ffdd8bc3b4296ea62c">Ogre::v1::InstanceBatch::_markTransformSharingDirty</a> ()</td></tr>
<tr class="memdesc:ga0cddd2ae271b01ffdd8bc3b4296ea62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells that the list of entity instances with shared transforms has changed.  <a href="#ga0cddd2ae271b01ffdd8bc3b4296ea62c">More...</a><br /></td></tr>
<tr class="separator:ga0cddd2ae271b01ffdd8bc3b4296ea62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bc4b3d95e53b1d5a0a772b60413a13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga35bc4b3d95e53b1d5a0a772b60413a13">Ogre::v1::InstancedEntity::_notifyAttached</a> (Node *parent)</td></tr>
<tr class="memdesc:ga35bc4b3d95e53b1d5a0a772b60413a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded so we can register ourselves for updating our animations.  <a href="#ga35bc4b3d95e53b1d5a0a772b60413a13">More...</a><br /></td></tr>
<tr class="separator:ga35bc4b3d95e53b1d5a0a772b60413a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1657152e8926a2608ccf7bd7f649f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga6b1657152e8926a2608ccf7bd7f649f7">Ogre::v1::InstancedEntity::_notifyParentNodeMemoryChanged</a> (void)</td></tr>
<tr class="memdesc:ga6b1657152e8926a2608ccf7bd7f649f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_node.html#ae97b41e6bade0e8cfad1706de1a4bd30" title="Internal use, notifies all attached objects that our memory pointers (i.e. ">Node::_callMemoryChangeListeners</a>  <a href="#ga6b1657152e8926a2608ccf7bd7f649f7">More...</a><br /></td></tr>
<tr class="separator:ga6b1657152e8926a2608ccf7bd7f649f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b21e13e879efa74e83b2a5ffe46ea7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8b21e13e879efa74e83b2a5ffe46ea7b">Ogre::v1::InstancedEntity::_notifyStaticDirty</a> (void) const </td></tr>
<tr class="memdesc:ga8b21e13e879efa74e83b2a5ffe46ea7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> when it is telling we're a static <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> being dirty Don't call this directly.  <a href="#ga8b21e13e879efa74e83b2a5ffe46ea7b">More...</a><br /></td></tr>
<tr class="separator:ga8b21e13e879efa74e83b2a5ffe46ea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca1dcbabc3ef0f0806965619ab481ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gadca1dcbabc3ef0f0806965619ab481ca">Ogre::v1::InstanceBatch::_notifyStaticDirty</a> (void)</td></tr>
<tr class="memdesc:gadca1dcbabc3ef0f0806965619ab481ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by InstancedEntity(s) or directly to tell us we need to update the bounds Should only useful if this batch is static.  <a href="#gadca1dcbabc3ef0f0806965619ab481ca">More...</a><br /></td></tr>
<tr class="separator:gadca1dcbabc3ef0f0806965619ab481ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf92f1d5af0805b1b27b098c0efd30e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaaaf92f1d5af0805b1b27b098c0efd30e">Ogre::v1::InstanceManager::_removeFromDynamicBatchList</a> (InstanceBatch *batch)</td></tr>
<tr class="memdesc:gaaaf92f1d5af0805b1b27b098c0efd30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a previously dynamic <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> went static (.  <a href="#gaaaf92f1d5af0805b1b27b098c0efd30e">More...</a><br /></td></tr>
<tr class="separator:gaaaf92f1d5af0805b1b27b098c0efd30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb433f47c29b8528d65676363f417c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaffb433f47c29b8528d65676363f417c8">Ogre::v1::InstanceBatch::_setCustomParam</a> (InstancedEntity *instancedEntity, unsigned char idx, const Vector4 &amp;newParam)</td></tr>
<tr class="separator:gaffb433f47c29b8528d65676363f417c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6572c1ea019faaa4786d99bc95e599f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae6572c1ea019faaa4786d99bc95e599f">Ogre::v1::InstanceBatch::_setInstancesPerBatch</a> (size_t instancesPerBatch)</td></tr>
<tr class="memdesc:gae6572c1ea019faaa4786d99bc95e599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an exception if trying to change it after being built.  <a href="#gae6572c1ea019faaa4786d99bc95e599f">More...</a><br /></td></tr>
<tr class="separator:gae6572c1ea019faaa4786d99bc95e599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97607c568ffc6cc1a7f29e9093c9cf9"><td class="memItemLeft" align="right" valign="top">SkeletalAnimationMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gab97607c568ffc6cc1a7f29e9093c9cf9">Ogre::v1::InstanceBatch::_supportsSkeletalAnimation</a> () const </td></tr>
<tr class="memdesc:gab97607c568ffc6cc1a7f29e9093c9cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this technique supports skeletal animation.  <a href="#gab97607c568ffc6cc1a7f29e9093c9cf9">More...</a><br /></td></tr>
<tr class="separator:gab97607c568ffc6cc1a7f29e9093c9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f3da48d2d3351e1e5a426e32509a59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae7f3da48d2d3351e1e5a426e32509a59">Ogre::v1::InstanceBatch::_updateBounds</a> (void)</td></tr>
<tr class="separator:gae7f3da48d2d3351e1e5a426e32509a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabddf3bd81e0eb9ae8f3ea474c5a12a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabddf3bd81e0eb9ae8f3ea474c5a12a0b">Ogre::v1::InstanceManager::_updateDirtyBatches</a> (void)</td></tr>
<tr class="memdesc:gabddf3bd81e0eb9ae8f3ea474c5a12a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> every frame.  <a href="#gabddf3bd81e0eb9ae8f3ea474c5a12a0b">More...</a><br /></td></tr>
<tr class="separator:gabddf3bd81e0eb9ae8f3ea474c5a12a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6bfacbaa6a995d286f898819d57d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gade6bfacbaa6a995d286f898819d57d79">Ogre::v1::InstanceManager::_updateDirtyBatchesThread</a> (size_t threadIdx)</td></tr>
<tr class="memdesc:gade6bfacbaa6a995d286f898819d57d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> every frame from multiple threads.  <a href="#gade6bfacbaa6a995d286f898819d57d79">More...</a><br /></td></tr>
<tr class="separator:gade6bfacbaa6a995d286f898819d57d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c954cc8e98b198a8da492f981b3564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga59c954cc8e98b198a8da492f981b3564">Ogre::v1::InstanceBatch::_updateEntitiesBoundsThread</a> (size_t threadIdx)</td></tr>
<tr class="memdesc:ga59c954cc8e98b198a8da492f981b3564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the bounds of only our entities from multiple threads.  <a href="#ga59c954cc8e98b198a8da492f981b3564">More...</a><br /></td></tr>
<tr class="separator:ga59c954cc8e98b198a8da492f981b3564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d95d4f1c7d56d4751306dde6e88e81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga63d95d4f1c7d56d4751306dde6e88e81">Ogre::v1::InstanceBatchHW::_updateRenderQueue</a> (RenderQueue *queue, Camera *camera, const Camera *lodCamera)</td></tr>
<tr class="memdesc:ga63d95d4f1c7d56d4751306dde6e88e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to avoid updating skeletons (which we don't support), check visibility on a per unit basis and finally updated the vertex buffer.  <a href="#ga63d95d4f1c7d56d4751306dde6e88e81">More...</a><br /></td></tr>
<tr class="separator:ga63d95d4f1c7d56d4751306dde6e88e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee70165ca97043ab99526665e99a642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2ee70165ca97043ab99526665e99a642">Ogre::v1::BaseInstanceBatchVTF::_updateRenderQueue</a> (RenderQueue *queue, Camera *camera, const Camera *lodCamera)</td></tr>
<tr class="memdesc:ga2ee70165ca97043ab99526665e99a642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to be able to updated the vertex texture.  <a href="#ga2ee70165ca97043ab99526665e99a642">More...</a><br /></td></tr>
<tr class="separator:ga2ee70165ca97043ab99526665e99a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa276a15b9a16258804347389a4420128"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa276a15b9a16258804347389a4420128">Ogre::v1::InstanceBatchHW_VTF::_updateRenderQueue</a> (RenderQueue *queue, Camera *camera, const Camera *lodCamera)</td></tr>
<tr class="memdesc:gaa276a15b9a16258804347389a4420128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to visibility on a per unit basis and finally updated the vertex texture.  <a href="#gaa276a15b9a16258804347389a4420128">More...</a><br /></td></tr>
<tr class="separator:gaa276a15b9a16258804347389a4420128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788ca8ce312622ee926e9ee658c84714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga788ca8ce312622ee926e9ee658c84714">Ogre::v1::InstancedEntity::_updateRenderQueue</a> (RenderQueue *queue, Camera *camera, const Camera *lodCamera)</td></tr>
<tr class="memdesc:ga788ca8ce312622ee926e9ee658c84714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do nothing, <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> takes care of this.  <a href="#ga788ca8ce312622ee926e9ee658c84714">More...</a><br /></td></tr>
<tr class="separator:ga788ca8ce312622ee926e9ee658c84714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94f0fb565e774568423fb4b672199dd"><td class="memItemLeft" align="right" valign="top">virtual RenderOperation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gad94f0fb565e774568423fb4b672199dd">Ogre::v1::InstanceBatch::build</a> (const SubMesh *baseSubMesh)</td></tr>
<tr class="memdesc:gad94f0fb565e774568423fb4b672199dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs all the data needed to use this batch, as well as the InstanceEntities.  <a href="#gad94f0fb565e774568423fb4b672199dd">More...</a><br /></td></tr>
<tr class="separator:gad94f0fb565e774568423fb4b672199dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc06e2c28ef2a112a5a3c11ed41495b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2bc06e2c28ef2a112a5a3c11ed41495b">Ogre::v1::InstanceBatchHW::buildFrom</a> (const SubMesh *baseSubMesh, const RenderOperation &amp;renderOperation)</td></tr>
<tr class="separator:ga2bc06e2c28ef2a112a5a3c11ed41495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f8f57285afe00bec42581a8cd38985c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9f8f57285afe00bec42581a8cd38985c">Ogre::v1::InstanceBatchShader::buildFrom</a> (const SubMesh *baseSubMesh, const RenderOperation &amp;renderOperation)</td></tr>
<tr class="separator:ga9f8f57285afe00bec42581a8cd38985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2673248dd7fa17a0bb5cab08fae634fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2673248dd7fa17a0bb5cab08fae634fd">Ogre::v1::BaseInstanceBatchVTF::buildFrom</a> (const SubMesh *baseSubMesh, const RenderOperation &amp;renderOperation)</td></tr>
<tr class="separator:ga2673248dd7fa17a0bb5cab08fae634fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca7d393795939891a51ef7af4655563"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563">Ogre::v1::InstanceBatch::buildFrom</a> (const SubMesh *baseSubMesh, const RenderOperation &amp;renderOperation)</td></tr>
<tr class="memdesc:ga4ca7d393795939891a51ef7af4655563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instancing consumes significantly more GPU memory than regular rendering methods.  <a href="#ga4ca7d393795939891a51ef7af4655563">More...</a><br /></td></tr>
<tr class="separator:ga4ca7d393795939891a51ef7af4655563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70290b6be49beef910c800481f8688f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac70290b6be49beef910c800481f8688f">Ogre::v1::InstanceBatchHW::calculateMaxNumInstances</a> (const SubMesh *baseSubMesh, uint16 flags) const </td></tr>
<tr class="separator:gac70290b6be49beef910c800481f8688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ce9a2de8bfa4b2b6167e4920a78f3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga92ce9a2de8bfa4b2b6167e4920a78f3f">Ogre::v1::InstanceBatchShader::calculateMaxNumInstances</a> (const SubMesh *baseSubMesh, uint16 flags) const </td></tr>
<tr class="separator:ga92ce9a2de8bfa4b2b6167e4920a78f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b2dddde59ed9e85524c027caf1abd3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac0b2dddde59ed9e85524c027caf1abd3">Ogre::v1::InstanceBatchHW_VTF::calculateMaxNumInstances</a> (const SubMesh *baseSubMesh, uint16 flags) const </td></tr>
<tr class="separator:gac0b2dddde59ed9e85524c027caf1abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e5c2f1e6b1216d302214fb2b5e2cf6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga89e5c2f1e6b1216d302214fb2b5e2cf6">Ogre::v1::InstanceBatchVTF::calculateMaxNumInstances</a> (const SubMesh *baseSubMesh, uint16 flags) const </td></tr>
<tr class="separator:ga89e5c2f1e6b1216d302214fb2b5e2cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ee7fe4258d4cdb4a8a726dc237c62a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a">Ogre::v1::InstanceBatch::calculateMaxNumInstances</a> (const SubMesh *baseSubMesh, uint16 flags) const =0</td></tr>
<tr class="memdesc:gae1ee7fe4258d4cdb4a8a726dc237c62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some techniques have a limit on how many instances can be done.  <a href="#gae1ee7fe4258d4cdb4a8a726dc237c62a">More...</a><br /></td></tr>
<tr class="separator:gae1ee7fe4258d4cdb4a8a726dc237c62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2661aaa9b593cb48ed6747c39cf31c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae2661aaa9b593cb48ed6747c39cf31c2">Ogre::v1::InstanceManager::cleanupEmptyBatches</a> (void)</td></tr>
<tr class="memdesc:gae2661aaa9b593cb48ed6747c39cf31c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be useful to improve CPU speed after having too many instances created, which where now removed, thus freeing many batches with zero used Instanced Entities However the batches aren't automatically removed from memory until the <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a> is destroyed, or this function is called.  <a href="#gae2661aaa9b593cb48ed6747c39cf31c2">More...</a><br /></td></tr>
<tr class="separator:gae2661aaa9b593cb48ed6747c39cf31c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace718a49f7de1da71d6800e9763f7232"><td class="memItemLeft" align="right" valign="top">InstancedEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gace718a49f7de1da71d6800e9763f7232">Ogre::v1::InstanceManager::createInstancedEntity</a> (const String &amp;materialName, SceneMemoryMgrTypes sceneType=SCENE_DYNAMIC)</td></tr>
<tr class="memdesc:gace718a49f7de1da71d6800e9763f7232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> based on an existing <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a> (.  <a href="#gace718a49f7de1da71d6800e9763f7232">More...</a><br /></td></tr>
<tr class="separator:gace718a49f7de1da71d6800e9763f7232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc7807ede1d9d5e90bd5b087ac83055"><td class="memItemLeft" align="right" valign="top">InstancedEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8fc7807ede1d9d5e90bd5b087ac83055">Ogre::v1::InstanceBatch::createInstancedEntity</a> ()</td></tr>
<tr class="memdesc:ga8fc7807ede1d9d5e90bd5b087ac83055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a new <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> ready to use Note it's actually preallocated, so no memory allocation happens at this point.  <a href="#ga8fc7807ede1d9d5e90bd5b087ac83055">More...</a><br /></td></tr>
<tr class="separator:ga8fc7807ede1d9d5e90bd5b087ac83055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82dd3354bca4ae42fba0903d46b973a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga82dd3354bca4ae42fba0903d46b973a0">Ogre::v1::InstanceManager::defragmentBatches</a> (bool optimizeCulling)</td></tr>
<tr class="memdesc:ga82dd3354bca4ae42fba0903d46b973a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">After creating many entities (which turns in many batches) and then removing entities that are in the middle of these batches, there might be many batches with many free entities.  <a href="#ga82dd3354bca4ae42fba0903d46b973a0">More...</a><br /></td></tr>
<tr class="separator:ga82dd3354bca4ae42fba0903d46b973a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02c2053d34cfc4d0cee0d0d02051820"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gad02c2053d34cfc4d0cee0d0d02051820">Ogre::v1::BaseInstanceBatchVTF::forceOneWeight</a> () const </td></tr>
<tr class="separator:gad02c2053d34cfc4d0cee0d0d02051820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2856e90afc3bb50e3cea9a706cc970"><td class="memItemLeft" align="right" valign="top">const AxisAlignedBox &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gacf2856e90afc3bb50e3cea9a706cc970">Ogre::v1::InstancedEntity::getBoundingBox</a> (void) const </td></tr>
<tr class="separator:gacf2856e90afc3bb50e3cea9a706cc970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adac0fdfd48776967e527ddc479b597"><td class="memItemLeft" align="right" valign="top">const Vector4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2adac0fdfd48776967e527ddc479b597">Ogre::v1::InstancedEntity::getCustomParam</a> (unsigned char idx)</td></tr>
<tr class="separator:ga2adac0fdfd48776967e527ddc479b597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84baa4ab3ddad426a1ac58cb4a1f0b7"><td class="memItemLeft" align="right" valign="top">InstanceBatchIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa84baa4ab3ddad426a1ac58cb4a1f0b7">Ogre::v1::InstanceManager::getInstanceBatchIterator</a> (const String &amp;materialName, SceneMemoryMgrTypes sceneType) const </td></tr>
<tr class="memdesc:gaa84baa4ab3ddad426a1ac58cb4a1f0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get non-updateable iterator over instance batches for given material.  <a href="#gaa84baa4ab3ddad426a1ac58cb4a1f0b7">More...</a><br /></td></tr>
<tr class="separator:gaa84baa4ab3ddad426a1ac58cb4a1f0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b16c8e81bb412c98a4a7a579e706ed0"><td class="memItemLeft" align="right" valign="top">InstanceBatchMapIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9b16c8e81bb412c98a4a7a579e706ed0">Ogre::v1::InstanceManager::getInstanceBatchMapIterator</a> (void) const </td></tr>
<tr class="memdesc:ga9b16c8e81bb412c98a4a7a579e706ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get non-updateable iterator over instance batches per material.  <a href="#ga9b16c8e81bb412c98a4a7a579e706ed0">More...</a><br /></td></tr>
<tr class="separator:ga9b16c8e81bb412c98a4a7a579e706ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63aa708650fcfc247774920597f8b723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga63aa708650fcfc247774920597f8b723">Ogre::v1::InstanceBatch::getInstancedEntitiesInUse</a> (InstancedEntityVec &amp;outEntities, CustomParamsVec &amp;outParams)</td></tr>
<tr class="memdesc:ga63aa708650fcfc247774920597f8b723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the input vector with the instances that are currently being used or were requested.  <a href="#ga63aa708650fcfc247774920597f8b723">More...</a><br /></td></tr>
<tr class="separator:ga63aa708650fcfc247774920597f8b723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ea0799e97d4187beb022939fea75af"><td class="memItemLeft" align="right" valign="top">InstancingTechnique&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga58ea0799e97d4187beb022939fea75af">Ogre::v1::InstanceManager::getInstancingTechnique</a> () const </td></tr>
<tr class="separator:ga58ea0799e97d4187beb022939fea75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4d6fc6f75f00611436436b95a24bd3"><td class="memItemLeft" align="right" valign="top">const LightList &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabf4d6fc6f75f00611436436b95a24bd3">Ogre::v1::InstanceBatch::getLights</a> (void) const </td></tr>
<tr class="separator:gabf4d6fc6f75f00611436436b95a24bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da4a4ded6d10e780318602f7044ffff"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga5da4a4ded6d10e780318602f7044ffff">Ogre::v1::BaseInstanceBatchVTF::getMaxLookupTableInstances</a> () const </td></tr>
<tr class="separator:ga5da4a4ded6d10e780318602f7044ffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32f22bcf1fe561b0435a1909c71996b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa32f22bcf1fe561b0435a1909c71996b">Ogre::v1::InstanceManager::getMaxOrBestNumInstancesPerBatch</a> (const String &amp;materialName, size_t suggestedSize, uint16 flags)</td></tr>
<tr class="memdesc:gaa32f22bcf1fe561b0435a1909c71996b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum (or the best amount, depending on flags) of instances per batch given the suggested size for the technique this manager was created for.  <a href="#gaa32f22bcf1fe561b0435a1909c71996b">More...</a><br /></td></tr>
<tr class="separator:gaa32f22bcf1fe561b0435a1909c71996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68b97dbef7ac32396eedc828124c8a9"><td class="memItemLeft" align="right" valign="top">const String &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae68b97dbef7ac32396eedc828124c8a9">Ogre::v1::InstancedEntity::getMovableType</a> (void) const </td></tr>
<tr class="memdesc:gae68b97dbef7ac32396eedc828124c8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of this object.  <a href="#gae68b97dbef7ac32396eedc828124c8a9">More...</a><br /></td></tr>
<tr class="separator:gae68b97dbef7ac32396eedc828124c8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd3c7cff9b2e5e31b193d1788b120a4"><td class="memItemLeft" align="right" valign="top">const String &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gacfd3c7cff9b2e5e31b193d1788b120a4">Ogre::v1::InstanceBatch::getMovableType</a> (void) const </td></tr>
<tr class="separator:gacfd3c7cff9b2e5e31b193d1788b120a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa9ae18340f16ddc801008afa9301a1"><td class="memItemLeft" align="right" valign="top">const IdString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaaaa9ae18340f16ddc801008afa9301a1">Ogre::v1::InstanceManager::getName</a> () const </td></tr>
<tr class="separator:gaaaa9ae18340f16ddc801008afa9301a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0783e779778622450ead2519f5c178"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga5c0783e779778622450ead2519f5c178">Ogre::v1::InstanceManager::getNumCustomParams</a> () const </td></tr>
<tr class="separator:ga5c0783e779778622450ead2519f5c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96af2b426ba6bc6e3cbf6e881bd66a5c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga96af2b426ba6bc6e3cbf6e881bd66a5c">Ogre::v1::InstanceBatchHW::getNumWorldTransforms</a> (void) const </td></tr>
<tr class="memdesc:ga96af2b426ba6bc6e3cbf6e881bd66a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of world transform matrices this renderable requires.  <a href="#ga96af2b426ba6bc6e3cbf6e881bd66a5c">More...</a><br /></td></tr>
<tr class="separator:ga96af2b426ba6bc6e3cbf6e881bd66a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e2fe59584a51c9992f88bbe4562bc3"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga89e2fe59584a51c9992f88bbe4562bc3">Ogre::v1::InstanceBatchShader::getNumWorldTransforms</a> (void) const </td></tr>
<tr class="memdesc:ga89e2fe59584a51c9992f88bbe4562bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of world transform matrices this renderable requires.  <a href="#ga89e2fe59584a51c9992f88bbe4562bc3">More...</a><br /></td></tr>
<tr class="separator:ga89e2fe59584a51c9992f88bbe4562bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56f3ae1a20df026e775b786278405f9"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac56f3ae1a20df026e775b786278405f9">Ogre::v1::BaseInstanceBatchVTF::getNumWorldTransforms</a> (void) const </td></tr>
<tr class="memdesc:gac56f3ae1a20df026e775b786278405f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of world transform matrices this renderable requires.  <a href="#gac56f3ae1a20df026e775b786278405f9">More...</a><br /></td></tr>
<tr class="separator:gac56f3ae1a20df026e775b786278405f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be2c03c8ce89d333d51cffabf564731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4be2c03c8ce89d333d51cffabf564731">Ogre::v1::InstanceBatch::getRenderOperation</a> (RenderOperation &amp;op, bool casterPass)</td></tr>
<tr class="separator:ga4be2c03c8ce89d333d51cffabf564731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8865e0b63fe7b4135ec78c12b6e0ed"><td class="memItemLeft" align="right" valign="top">SceneManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabb8865e0b63fe7b4135ec78c12b6e0ed">Ogre::v1::InstanceManager::getSceneManager</a> () const </td></tr>
<tr class="separator:gabb8865e0b63fe7b4135ec78c12b6e0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd8b9be7c00403a8b757daeb746a4f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9fd8b9be7c00403a8b757daeb746a4f8">Ogre::v1::InstanceManager::getSetting</a> (BatchSettingId id, IdString materialName) const </td></tr>
<tr class="memdesc:ga9fd8b9be7c00403a8b757daeb746a4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If settings for the given material didn't exist, default value is returned.  <a href="#ga9fd8b9be7c00403a8b757daeb746a4f8">More...</a><br /></td></tr>
<tr class="separator:ga9fd8b9be7c00403a8b757daeb746a4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed691673f02b6abfc1a219e4a5ce1d2"><td class="memItemLeft" align="right" valign="top">SkeletonInstance *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga6ed691673f02b6abfc1a219e4a5ce1d2">Ogre::v1::InstancedEntity::getSkeleton</a> (void) const </td></tr>
<tr class="separator:ga6ed691673f02b6abfc1a219e4a5ce1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8ce449ec85a71faa838062b9dba855"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabd8ce449ec85a71faa838062b9dba855">Ogre::v1::InstancedEntity::getSquaredViewDepth</a> (const Camera *cam) const </td></tr>
<tr class="memdesc:gabd8ce449ec85a71faa838062b9dba855"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used by our batch owner to get the closest entity's depth, returns infinity when not attached to a scene node.  <a href="#gabd8ce449ec85a71faa838062b9dba855">More...</a><br /></td></tr>
<tr class="separator:gabd8ce449ec85a71faa838062b9dba855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac927a4be745cd1670fe88f5492c7bf00"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac927a4be745cd1670fe88f5492c7bf00">Ogre::v1::InstanceBatch::getSquaredViewDepth</a> (const Camera *cam) const </td></tr>
<tr class="separator:gac927a4be745cd1670fe88f5492c7bf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3173dd5f9506e12f492dca47f2fc3c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga3173dd5f9506e12f492dca47f2fc3c3d">Ogre::v1::InstanceBatchHW::getWorldTransforms</a> (Matrix4 *xform) const </td></tr>
<tr class="memdesc:ga3173dd5f9506e12f492dca47f2fc3c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world transform matrix / matrices for this renderable object.  <a href="#ga3173dd5f9506e12f492dca47f2fc3c3d">More...</a><br /></td></tr>
<tr class="separator:ga3173dd5f9506e12f492dca47f2fc3c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70ec657e803b2142af17623249287fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa70ec657e803b2142af17623249287fc">Ogre::v1::InstanceBatchShader::getWorldTransforms</a> (Matrix4 *xform) const </td></tr>
<tr class="memdesc:gaa70ec657e803b2142af17623249287fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world transform matrix / matrices for this renderable object.  <a href="#gaa70ec657e803b2142af17623249287fc">More...</a><br /></td></tr>
<tr class="separator:gaa70ec657e803b2142af17623249287fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0ac112786d1b9da547f4c41f68fd21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8c0ac112786d1b9da547f4c41f68fd21">Ogre::v1::BaseInstanceBatchVTF::getWorldTransforms</a> (Matrix4 *xform) const </td></tr>
<tr class="memdesc:ga8c0ac112786d1b9da547f4c41f68fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the world transform matrix / matrices for this renderable object.  <a href="#ga8c0ac112786d1b9da547f4c41f68fd21">More...</a><br /></td></tr>
<tr class="separator:ga8c0ac112786d1b9da547f4c41f68fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34379422b0e5ac8430da22c348e9a915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga34379422b0e5ac8430da22c348e9a915">Ogre::v1::InstanceManager::hasSettings</a> (IdString materialName) const </td></tr>
<tr class="memdesc:ga34379422b0e5ac8430da22c348e9a915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if settings were already created for the given material name.  <a href="#ga34379422b0e5ac8430da22c348e9a915">More...</a><br /></td></tr>
<tr class="separator:ga34379422b0e5ac8430da22c348e9a915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d66794c3764e2f74007e34e168691ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8d66794c3764e2f74007e34e168691ac">Ogre::v1::InstancedEntity::hasSkeleton</a> (void) const </td></tr>
<tr class="separator:ga8d66794c3764e2f74007e34e168691ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fe1984342ba4a66d5e95d6727928d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga48fe1984342ba4a66d5e95d6727928d9">Ogre::v1::InstanceBatchHW::instanceBatchCullFrustumThreaded</a> (const Camera *frustum, const Camera *lodCamera, uint32 combinedVisibilityFlags)</td></tr>
<tr class="separator:ga48fe1984342ba4a66d5e95d6727928d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee23e09e0a741053a91dc2068c0de084"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaee23e09e0a741053a91dc2068c0de084">Ogre::v1::InstanceBatchHW_VTF::instanceBatchCullFrustumThreaded</a> (const Camera *frustum, const Camera *lodCamera, uint32 combinedVisibilityFlags)</td></tr>
<tr class="separator:gaee23e09e0a741053a91dc2068c0de084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7bd285b2cf16d7a188527a5e76d6e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4b7bd285b2cf16d7a188527a5e76d6e7">Ogre::v1::InstanceBatch::isBatchFull</a> (void) const </td></tr>
<tr class="separator:ga4b7bd285b2cf16d7a188527a5e76d6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eac682480c677ad60e574b4e3d48a2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2eac682480c677ad60e574b4e3d48a2c">Ogre::v1::InstanceBatch::isBatchUnused</a> (void) const </td></tr>
<tr class="memdesc:ga2eac682480c677ad60e574b4e3d48a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if it no instanced entity has been requested or all of them have been removed.  <a href="#ga2eac682480c677ad60e574b4e3d48a2c">More...</a><br /></td></tr>
<tr class="separator:ga2eac682480c677ad60e574b4e3d48a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d93f4d2967505016fc525565ae71e0f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4d93f4d2967505016fc525565ae71e0f">Ogre::v1::InstancedEntity::isInScene</a> (void) const </td></tr>
<tr class="separator:ga4d93f4d2967505016fc525565ae71e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75efec3af388b7879094a7a3c551299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa75efec3af388b7879094a7a3c551299">Ogre::v1::InstancedEntity::isInUse</a> () const </td></tr>
<tr class="memdesc:gaa75efec3af388b7879094a7a3c551299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the entity is in use.  <a href="#gaa75efec3af388b7879094a7a3c551299">More...</a><br /></td></tr>
<tr class="separator:gaa75efec3af388b7879094a7a3c551299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8174300d9fd7b766d727c85e11a20f"><td class="memItemLeft" align="right" valign="top">_OgreExport bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9d8174300d9fd7b766d727c85e11a20f">Ogre::operator!=</a> (const ShadowTextureConfig &amp;lhs, const ShadowTextureConfig &amp;rhs)</td></tr>
<tr class="separator:ga9d8174300d9fd7b766d727c85e11a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ad57afec4a689c118c5a61bb3a72e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaa4ad57afec4a689c118c5a61bb3a72e4">Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::operator()</a> (const MovableObject *mo)</td></tr>
<tr class="separator:gaa4ad57afec4a689c118c5a61bb3a72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50eb7990483aa544ee7d70fbe40f03f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga50eb7990483aa544ee7d70fbe40f03f9">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::operator()</a> (const MovableObject *mo)</td></tr>
<tr class="separator:ga50eb7990483aa544ee7d70fbe40f03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ab906e4ed2d67f9c4eb24cff862388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga13ab906e4ed2d67f9c4eb24cff862388">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::operator()</a> (const MovableObject *mo)</td></tr>
<tr class="separator:ga13ab906e4ed2d67f9c4eb24cff862388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706d4b6aa41612ff68fb08b90a0a5a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga706d4b6aa41612ff68fb08b90a0a5a19">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::operator()</a> (const MovableObject *mo)</td></tr>
<tr class="separator:ga706d4b6aa41612ff68fb08b90a0a5a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb3ccae22fafe48529509bb0b565f4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gadeb3ccae22fafe48529509bb0b565f4e">Ogre::v1::InstanceManagerCmp::operator()</a> (const InstanceManager *a, const InstanceManager *b) const </td></tr>
<tr class="separator:gadeb3ccae22fafe48529509bb0b565f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed507a902be142d166cca7755774cc47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaed507a902be142d166cca7755774cc47">Ogre::v1::InstanceManagerCmp::operator()</a> (const InstanceManager *a, IdString name) const </td></tr>
<tr class="separator:gaed507a902be142d166cca7755774cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c1adadd3106188ef91759c4cd1a848"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf2c1adadd3106188ef91759c4cd1a848">Ogre::v1::InstanceManagerCmp::operator()</a> (IdString name, const InstanceManager *a) const </td></tr>
<tr class="separator:gaf2c1adadd3106188ef91759c4cd1a848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab426b0250db523190d60f4bfe0414499"><td class="memItemLeft" align="right" valign="top">_OgreExport bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gab426b0250db523190d60f4bfe0414499">Ogre::operator==</a> (const ShadowTextureConfig &amp;lhs, const ShadowTextureConfig &amp;rhs)</td></tr>
<tr class="separator:gab426b0250db523190d60f4bfe0414499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ca971a27b832f845c400c2fb703ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf0ca971a27b832f845c400c2fb703ab6">Ogre::v1::InstanceBatch::removeInstancedEntity</a> (InstancedEntity *instancedEntity)</td></tr>
<tr class="memdesc:gaf0ca971a27b832f845c400c2fb703ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> from the scene retrieved with getNewInstancedEntity, putting back into a queue.  <a href="#gaf0ca971a27b832f845c400c2fb703ab6">More...</a><br /></td></tr>
<tr class="separator:gaf0ca971a27b832f845c400c2fb703ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ea1d192952ed23c66cf3eaa19342e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga71ea1d192952ed23c66cf3eaa19342e5">Ogre::v1::InstanceManager::setBatchesAsStatic</a> (bool bStatic)</td></tr>
<tr class="memdesc:ga71ea1d192952ed23c66cf3eaa19342e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells this batch to stop updating animations, positions, rotations, and display all it's active instances.  <a href="#ga71ea1d192952ed23c66cf3eaa19342e5">More...</a><br /></td></tr>
<tr class="separator:ga71ea1d192952ed23c66cf3eaa19342e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106b017a71c558d5d6b26585b91cc7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga106b017a71c558d5d6b26585b91cc7d0">Ogre::v1::BaseInstanceBatchVTF::setBoneDualQuaternions</a> (bool enable)</td></tr>
<tr class="separator:ga106b017a71c558d5d6b26585b91cc7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8bb77feada5b5ea649187781c19ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4f8bb77feada5b5ea649187781c19ade">Ogre::v1::BaseInstanceBatchVTF::setBoneMatrixLookup</a> (bool enable, size_t maxLookupTableInstances)</td></tr>
<tr class="memdesc:ga4f8bb77feada5b5ea649187781c19ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of the usage of bone matrix lookup.  <a href="#ga4f8bb77feada5b5ea649187781c19ade">More...</a><br /></td></tr>
<tr class="separator:ga4f8bb77feada5b5ea649187781c19ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf5778fa812b312621ea968ad01fe41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaccf5778fa812b312621ea968ad01fe41">Ogre::v1::InstancedEntity::setCustomParam</a> (unsigned char idx, const Vector4 &amp;newParam)</td></tr>
<tr class="memdesc:gaccf5778fa812b312621ea968ad01fe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the custom parameter for this instance.  <a href="#gaccf5778fa812b312621ea968ad01fe41">More...</a><br /></td></tr>
<tr class="separator:gaccf5778fa812b312621ea968ad01fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57b941b0f9b4f7b21c894b497893309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gac57b941b0f9b4f7b21c894b497893309">Ogre::v1::BaseInstanceBatchVTF::setForceOneWeight</a> (bool enable)</td></tr>
<tr class="separator:gac57b941b0f9b4f7b21c894b497893309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba57b4e048df3463879990a3b017786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gacba57b4e048df3463879990a3b017786">Ogre::v1::InstanceManager::setInstancesPerBatch</a> (size_t instancesPerBatch)</td></tr>
<tr class="memdesc:gacba57b4e048df3463879990a3b017786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an exception if trying to change it after creating the first <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a>.  <a href="#gacba57b4e048df3463879990a3b017786">More...</a><br /></td></tr>
<tr class="separator:gacba57b4e048df3463879990a3b017786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad114bb59090ecd3e9d9f187281d0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaaad114bb59090ecd3e9d9f187281d0e0">Ogre::v1::InstanceManager::setMaxLookupTableInstances</a> (size_t maxLookupTableInstances)</td></tr>
<tr class="memdesc:gaaad114bb59090ecd3e9d9f187281d0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the lookup table for techniques supporting bone lookup table.  <a href="#gaaad114bb59090ecd3e9d9f187281d0e0">More...</a><br /></td></tr>
<tr class="separator:gaaad114bb59090ecd3e9d9f187281d0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83716fab444f001c458c42ebaaec81aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga83716fab444f001c458c42ebaaec81aa">Ogre::v1::InstanceManager::setNumCustomParams</a> (unsigned char numCustomParams)</td></tr>
<tr class="memdesc:ga83716fab444f001c458c42ebaaec81aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of custom parameters per instance.  <a href="#ga83716fab444f001c458c42ebaaec81aa">More...</a><br /></td></tr>
<tr class="separator:ga83716fab444f001c458c42ebaaec81aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcba48afeb829895876e34b5e355df20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gafcba48afeb829895876e34b5e355df20">Ogre::v1::InstanceManager::setSetting</a> (BatchSettingId id, bool enabled, IdString materialName=IdString())</td></tr>
<tr class="memdesc:gafcba48afeb829895876e34b5e355df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a setting for all batches using the same material_ existing ones and those that will be created in the future.  <a href="#gafcba48afeb829895876e34b5e355df20">More...</a><br /></td></tr>
<tr class="separator:gafcba48afeb829895876e34b5e355df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929594ecadcefcca65b1cc24794c47bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga929594ecadcefcca65b1cc24794c47bf">Ogre::v1::InstanceBatch::setStatic</a> (bool bStatic)</td></tr>
<tr class="memdesc:ga929594ecadcefcca65b1cc24794c47bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells this batch to stop updating animations, positions, rotations, and display all it's active instances.  <a href="#ga929594ecadcefcca65b1cc24794c47bf">More...</a><br /></td></tr>
<tr class="separator:ga929594ecadcefcca65b1cc24794c47bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dac364674912ef03373e229b7b30ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga85dac364674912ef03373e229b7b30ae">Ogre::v1::InstancedEntity::setTransformLookupNumber</a> (uint16 num)</td></tr>
<tr class="memdesc:ga85dac364674912ef03373e229b7b30ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transformation look up number.  <a href="#ga85dac364674912ef03373e229b7b30ae">More...</a><br /></td></tr>
<tr class="separator:ga85dac364674912ef03373e229b7b30ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7365adfb71eba4f29b80bbb715e0e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae7365adfb71eba4f29b80bbb715e0e3d">Ogre::v1::BaseInstanceBatchVTF::setUseOneWeight</a> (bool enable)</td></tr>
<tr class="separator:gae7365adfb71eba4f29b80bbb715e0e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2b594b3d213fa98136d444c3260f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaac2b594b3d213fa98136d444c3260f00">Ogre::v1::InstancedEntity::shareTransformWith</a> (InstancedEntity *slave)</td></tr>
<tr class="memdesc:gaac2b594b3d213fa98136d444c3260f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares the entire transformation with another <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a>.  <a href="#gaac2b594b3d213fa98136d444c3260f00">More...</a><br /></td></tr>
<tr class="separator:gaac2b594b3d213fa98136d444c3260f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e4b89e573430e54d73d4e2ead68c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gab9e4b89e573430e54d73d4e2ead68c21">Ogre::v1::InstancedEntity::stopSharingTransform</a> ()</td></tr>
<tr class="separator:gab9e4b89e573430e54d73d4e2ead68c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c80068652d0ed7d22382eb17edfbc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gae1c80068652d0ed7d22382eb17edfbc6">Ogre::v1::BaseInstanceBatchVTF::useBoneDualQuaternions</a> () const </td></tr>
<tr class="separator:gae1c80068652d0ed7d22382eb17edfbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8a62bb549dc220c1622f4f6611c0e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gadd8a62bb549dc220c1622f4f6611c0e5">Ogre::v1::BaseInstanceBatchVTF::useBoneMatrixLookup</a> () const </td></tr>
<tr class="memdesc:gadd8a62bb549dc220c1622f4f6611c0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether to use bone matrix lookup.  <a href="#gadd8a62bb549dc220c1622f4f6611c0e5">More...</a><br /></td></tr>
<tr class="separator:gadd8a62bb549dc220c1622f4f6611c0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c2410a68737fab576c54dc88b910d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf4c2410a68737fab576c54dc88b910d0">Ogre::v1::BaseInstanceBatchVTF::useOneWeight</a> () const </td></tr>
<tr class="separator:gaf4c2410a68737fab576c54dc88b910d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad4d3c5cdc5cc4e37e20b71f3ac530a19"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gad4d3c5cdc5cc4e37e20b71f3ac530a19">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::boneIdxEnd</a></td></tr>
<tr class="separator:gad4d3c5cdc5cc4e37e20b71f3ac530a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec16dbb787ab245793ff967d8286920"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga5ec16dbb787ab245793ff967d8286920">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::boneIdxEnd</a></td></tr>
<tr class="separator:ga5ec16dbb787ab245793ff967d8286920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3885247e28d9be98020e8f93436afc"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga4e3885247e28d9be98020e8f93436afc">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::boneIdxEnd</a></td></tr>
<tr class="separator:ga4e3885247e28d9be98020e8f93436afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1aab4dd5ba2fdd5397a9b1d5fa29842"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf1aab4dd5ba2fdd5397a9b1d5fa29842">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::boneIdxStart</a></td></tr>
<tr class="separator:gaf1aab4dd5ba2fdd5397a9b1d5fa29842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bef86e4765714dbeabf14b000a714fa"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga8bef86e4765714dbeabf14b000a714fa">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::boneIdxStart</a></td></tr>
<tr class="separator:ga8bef86e4765714dbeabf14b000a714fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac827bc395039b3ab33243ffba820bc"><td class="memItemLeft" align="right" valign="top">Mesh::IndexMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gadac827bc395039b3ab33243ffba820bc">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::boneIdxStart</a></td></tr>
<tr class="separator:gadac827bc395039b3ab33243ffba820bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e74097af8a052c92b4f3993d6dd55c0"><td class="memItemLeft" align="right" valign="top">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga3e74097af8a052c92b4f3993d6dd55c0">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mDest</a></td></tr>
<tr class="separator:ga3e74097af8a052c92b4f3993d6dd55c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba497c1283d910384b53e1061f0617d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaba497c1283d910384b53e1061f0617d1">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mEntitiesPerPadding</a></td></tr>
<tr class="separator:gaba497c1283d910384b53e1061f0617d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc151cd49376bdd7de5570770c2f0781"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gabc151cd49376bdd7de5570770c2f0781">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mFloatsPerEntity</a></td></tr>
<tr class="separator:gabc151cd49376bdd7de5570770c2f0781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d321df7b753c8c218ae453b57b1e295"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga2d321df7b753c8c218ae453b57b1e295">Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::mInstancesWritten</a></td></tr>
<tr class="separator:ga2d321df7b753c8c218ae453b57b1e295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318ff608d7d1a3bb970131d37961c05d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga318ff608d7d1a3bb970131d37961c05d">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::mInstancesWritten</a></td></tr>
<tr class="separator:ga318ff608d7d1a3bb970131d37961c05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201a73735cdbc245585a30c6d2f7465e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga201a73735cdbc245585a30c6d2f7465e">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::mInstancesWritten</a></td></tr>
<tr class="separator:ga201a73735cdbc245585a30c6d2f7465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c4b731d5d25c2077b9448276c23c36"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga05c4b731d5d25c2077b9448276c23c36">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mWidthFloatsPadding</a></td></tr>
<tr class="separator:ga05c4b731d5d25c2077b9448276c23c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70957102db852f95b46596112ec28433"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga70957102db852f95b46596112ec28433">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::mWrittenPositions</a></td></tr>
<tr class="separator:ga70957102db852f95b46596112ec28433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa8a219500a7ecfca2e725822603d53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga0fa8a219500a7ecfca2e725822603d53">Ogre::v1::InstanceManager::BatchSettings::setting</a> [NUM_SETTINGS]</td></tr>
<tr class="separator:ga0fa8a219500a7ecfca2e725822603d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga41ffb53da525c94819e85211fc48449c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga41ffb53da525c94819e85211fc48449c">Ogre::v1::InstancedEntity::BaseInstanceBatchVTF</a></td></tr>
<tr class="separator:ga41ffb53da525c94819e85211fc48449c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ddd6acb1bcb90f4ac672b7ba7569b0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gab0ddd6acb1bcb90f4ac672b7ba7569b0">Ogre::v1::InstancedEntity::InstanceBatch</a></td></tr>
<tr class="separator:gab0ddd6acb1bcb90f4ac672b7ba7569b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204d0aed3320790edf10711c32f3db73"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga204d0aed3320790edf10711c32f3db73">Ogre::v1::InstancedEntity::InstanceBatchHW</a></td></tr>
<tr class="separator:ga204d0aed3320790edf10711c32f3db73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534bbd3a2646322b2767289cb9c972c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#ga9534bbd3a2646322b2767289cb9c972c">Ogre::v1::InstancedEntity::InstanceBatchHW_VTF</a></td></tr>
<tr class="separator:ga9534bbd3a2646322b2767289cb9c972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05a8273f12bc11f025607a06b3b3e2a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scene.html#gaf05a8273f12bc11f025607a06b3b3e2a">Ogre::v1::InstancedEntity::InstanceBatchShader</a></td></tr>
<tr class="separator:gaf05a8273f12bc11f025607a06b3b3e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga40acba93d9441f2bccfa096b641c887d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstVectorIterator&lt;ShadowTextureConfigList&gt; <a class="el" href="group___scene.html#ga40acba93d9441f2bccfa096b641c887d">Ogre::ConstShadowTextureConfigIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2fa05da2bbcd7dd55f2b78e592b9d47e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;Vector4&gt;::type <a class="el" href="group___scene.html#ga2fa05da2bbcd7dd55f2b78e592b9d47e">Ogre::v1::InstanceBatch::CustomParamsVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e654731a11ddd85237cc4a129f4d2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstVectorIterator&lt;InstanceBatchVec&gt; <a class="el" href="group___scene.html#ga1e654731a11ddd85237cc4a129f4d2c9">Ogre::v1::InstanceManager::InstanceBatchIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga19ee64c2bccdfd498b2c1cbf130da9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstMapIterator&lt;InstanceBatchMap&gt; <a class="el" href="group___scene.html#ga19ee64c2bccdfd498b2c1cbf130da9b0">Ogre::v1::InstanceManager::InstanceBatchMapIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga89807ff7d5dc42c1a44a3a729e47cf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FastArray&lt;InstancedEntity*&gt; <a class="el" href="group___scene.html#ga89807ff7d5dc42c1a44a3a729e47cf51">Ogre::v1::InstanceBatch::InstancedEntityArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga23ff13a5af164d4eaaa1ebbe40570c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;InstancedEntity*&gt;::type <a class="el" href="group___scene.html#ga23ff13a5af164d4eaaa1ebbe40570c93">Ogre::v1::InstanceBatch::InstancedEntityVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1d0db569747448aeff27f36ecd717686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;RaySceneQueryResultEntry&gt;::type <a class="el" href="group___scene.html#ga1d0db569747448aeff27f36ecd717686">Ogre::RaySceneQueryResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac2456530a54d76fba2d659954fc243c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FastArray&lt; Renderable * &gt; <a class="el" href="group___scene.html#gac2456530a54d76fba2d659954fc243c9">Ogre::RenderableArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaddcc5a6779ee6a6bb82aeb5f42239a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;SceneQueryMovableObjectPair&gt;::type <a class="el" href="group___scene.html#gaddcc5a6779ee6a6bb82aeb5f42239a52">Ogre::SceneQueryMovableIntersectionList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa1ca4f17a1e8bb7381446ae6235869d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;MovableObject*, MovableObject*&gt; <a class="el" href="group___scene.html#gaa1ca4f17a1e8bb7381446ae6235869d8">Ogre::SceneQueryMovableObjectPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae8f394829e3a85cea6faa915ac391653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;MovableObject*, SceneQuery::WorldFragment*&gt; <a class="el" href="group___scene.html#gae8f394829e3a85cea6faa915ac391653">Ogre::SceneQueryMovableObjectWorldFragmentPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2e63733116c49a9931a2989a2cfe1b51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;SceneQueryMovableObjectWorldFragmentPair&gt;::type <a class="el" href="group___scene.html#ga2e63733116c49a9931a2989a2cfe1b51">Ogre::SceneQueryMovableWorldFragmentIntersectionList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad79dcd1262d117ecf4d51a5f555d3071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;MovableObject*&gt;::type <a class="el" href="group___scene.html#gad79dcd1262d117ecf4d51a5f555d3071">Ogre::SceneQueryResultMovableList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad9005a54a736be79548ebcdf69dfd448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;SceneQuery::WorldFragment*&gt;::type <a class="el" href="group___scene.html#gad9005a54a736be79548ebcdf69dfd448">Ogre::SceneQueryResultWorldFragmentList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa4b6dbd7bf722582a21fcc25d25f73ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16 <a class="el" href="group___scene.html#gaa4b6dbd7bf722582a21fcc25d25f73ed">Ogre::SceneTypeMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitmask containing scene types. </p>

</div>
</div>
<a class="anchor" id="ga0f71238039ee719563bf5202d80ff41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;ShadowTextureConfig&gt;::type <a class="el" href="group___scene.html#ga0f71238039ee719563bf5202d80ff41a">Ogre::ShadowTextureConfigList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9befe4ef9c189ac3f2e016a63d560c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;TexturePtr&gt;::type <a class="el" href="group___scene.html#ga9befe4ef9c189ac3f2e016a63d560c67">Ogre::ShadowTextureList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga06d6e53236b998db135989521a8ad3ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FastArray&lt;MovableObject::MovableObjectArray&gt; <a class="el" href="group___scene.html#ga06d6e53236b998db135989521a8ad3ba">Ogre::VisibleObjectsPerRq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga21ffab3c275854b773dcd9efeba9152c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FastArray&lt;VisibleObjectsPerRq&gt; <a class="el" href="group___scene.html#ga21ffab3c275854b773dcd9efeba9152c">Ogre::VisibleObjectsPerThreadArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2967aa471d9b4bbba11ba6b6f4fc90d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#ga2967aa471d9b4bbba11ba6b6f4fc90d7">Ogre::v1::InstanceManager::BatchSettingId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values to be used in <a class="el" href="group___scene.html#gafcba48afeb829895876e34b5e355df20" title="Applies a setting for all batches using the same material_ existing ones and those that will be creat...">setSetting()</a> &amp; BatchSettings::setting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2967aa471d9b4bbba11ba6b6f4fc90d7a085acc2737e2f4480820ab5af1e95b84"></a>CAST_SHADOWS&#160;</td><td class="fielddoc">
<p>Makes all batches from same material cast shadows. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2967aa471d9b4bbba11ba6b6f4fc90d7a8bc207bbcf78bd642d321a11692d535c"></a>SHOW_BOUNDINGBOX&#160;</td><td class="fielddoc">
<p>Makes each batch to display it's bounding box. Useful for debugging or profiling. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2967aa471d9b4bbba11ba6b6f4fc90d7a6c974a9d3981cc6c80771e80e53adee0"></a>NUM_SETTINGS&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7c11c8a17d7bbfc5aab6f982fb0d7f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#ga7c11c8a17d7bbfc5aab6f982fb0d7f38">Ogre::FaceGroupType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type of face group, i.e. </p>
<p>face list of procedural etc </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7c11c8a17d7bbfc5aab6f982fb0d7f38a06ae7e34bd024924db27d7a490c545e4"></a>FGT_FACE_LIST&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c11c8a17d7bbfc5aab6f982fb0d7f38ab0cfe6b33db8e2804a5f50ae51d59ff5"></a>FGT_PATCH&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c11c8a17d7bbfc5aab6f982fb0d7f38a8d46b5184ac4f071e0f287f89e1b253b"></a>FGT_UNKNOWN&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7fdc1f95714df3401447297dd6385e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">Ogre::v1::InstanceManager::InstancingTechnique</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7fdc1f95714df3401447297dd6385e9cadfb4aa0d4d7162235a1937f515bbf5fc"></a>ShaderBased&#160;</td><td class="fielddoc">
<p><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type. ">Any</a> SM 2.0+. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_shader.html" title="This is the same technique the old &quot;InstancedGeometry&quot; implementation used (with improvements). ">InstanceBatchShader</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7fdc1f95714df3401447297dd6385e9ca2d7dd23d906f7239d9d6efda7bdba0a4"></a>TextureVTF&#160;</td><td class="fielddoc">
<p>Needs Vertex <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource. ">Texture</a> Fetch &amp; SM 3.0+. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_v_t_f.html">InstanceBatchVTF</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7fdc1f95714df3401447297dd6385e9ca39d441de5b145d1dcb81d70d508364aa"></a>HWInstancingBasic&#160;</td><td class="fielddoc">
<p>Needs SM 3.0+ and HW instancing support. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_h_w.html" title="This is technique requires true instancing hardware support. ">InstanceBatchHW</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7fdc1f95714df3401447297dd6385e9ca2f6a94740a2286151bd6d7796fd3059c"></a>HWInstancingVTF&#160;</td><td class="fielddoc">
<p>Needs SM 3.0+, HW instancing support &amp; VTF. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_instance_batch_h_w___v_t_f.html" title="Instancing implementation using vertex texture through Vertex Texture Fetch (VTF) and hardware instan...">InstanceBatchHW_VTF</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7fdc1f95714df3401447297dd6385e9ca4735c060474d8473f924f9f08e57a9cd"></a>InstancingTechniquesCount&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gafdd170d87744deec0ca8dd1730797be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#gafdd170d87744deec0ca8dd1730797be7">Ogre::InstancingThreadedCullingMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>There are two Instancing techniques that perform culling of their own: HW Basic HW VTF <a class="el" href="class_ogre_1_1_frustum.html" title="A frustum represents a pyramid, capped at the near and far end which is used to represent either a vi...">Frustum</a> culling is highly parallelizable &amp; scalable. </p>
<p>However, we first cull InstanceBatches &amp; regular entities, then ask the culled InstanceBatches to perform their culling to the InstancedEntities they own. This results performance boost for skipping large amounts of instanced entities when the whole batch isn't visible. However, this also means threading frustum culling of instanced entities got harder. </p><dl class="section user"><dt></dt><dd>There are four approaches: Ask all existing batches to frustum cull. Then use only the ones we want. Sheer brute force. Scales very well with cores, but sacrifices performance unnecessary when only a few batches are visible. This approach is not taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</dd></dl>
<p>Sync every time an InstanceBatchHW or InstanceBatchHW_VTF tries to frustum cull to delegate the job on worker threads. Considering there could be hundreds of InstanceBatches, this would cause a huge amount of thread synchronization overhead &amp; context switches. This approach is not taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</p>
<p>Each thread after having culled all InstancedBatches &amp; Entities, will parse the culled list to ask all MovableObjects to perform culling of their own. Entities will ignore this call (however they add to a small overhead for traversing them and calling a virtual function) while InstanceBatchHW &amp; InstanceBatchHW_VTF will perform their own culling from within the multiple threads. This approach scales well with cores and only visible batches. However load balancing may be an issue for certain scenes: eg. an InstanceBatch with 5000 InstancedEntities in one thread, while the other three threads get one InstanceBatch each with 50 InstancedEntities. The first thread will have considerably more work to do than the other three. This approach is a good balance when compared to the first two. This is the approach taken by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> when INSTANCING_CULLING_THREADED is on</p>
<p>Don't multithread instanced entitites' frustum culling. Only the InstanceBatch &amp; Entity's frustum culling will be threaded. This is what happens when INSTANCING_CULLING_SINGLE is on.</p>
<p>Whether INSTANCING_CULLING_THREADED improves or degrades performance depends highly on your scene. </p><dl class="section user"><dt></dt><dd><b>When to use INSTANCING_CULLING_SINGLETHREAD?</b> If your scene doesn't use HW Basic or HW VTF instancing techniques, or you have very few Instanced entities compared to the amount of regular Entities. Turning threading on, you'll be wasting your time traversing the list from multiple threads in search of InstanceBatchHW &amp; InstanceBatchHW_VTF</dd></dl>
<p><b>When to use INSTANCING_CULLING_THREADED?</b> If your scene makes intensive use of HW Basic and/or HW VTF instancing techniques. Note that threaded culling is performed in SCENE_STATIC instances too. The most advantage is seen when the instances per batch is very high and when doing many PASS_SCENE, which require frustum culling multiple times per frame (eg. pssm shadows, multiple light sources with shadows, very advanced compositing, etc)</p>
<p>Note that you can switch between methods at any time at runtime. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggafdd170d87744deec0ca8dd1730797be7ada21a76062e79007f34578a11c6be140"></a>INSTANCING_CULLING_SINGLETHREAD&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafdd170d87744deec0ca8dd1730797be7a2af3eec2c36adea6197588fe5b768361"></a>INSTANCING_CULLING_THREADED&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7383602bd480d43b80c626969b9af914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#ga7383602bd480d43b80c626969b9af914">Ogre::SceneType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classification of a scene to allow a decision of what type of SceenManager to provide back to the application. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd"></a>ST_GENERIC&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7383602bd480d43b80c626969b9af914ae83ae1c9a6e4816184441db4a140e70a"></a>ST_EXTERIOR_CLOSE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7383602bd480d43b80c626969b9af914a8bf5864d5ab311e0512ed153c95f1d13"></a>ST_EXTERIOR_FAR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7383602bd480d43b80c626969b9af914a7eecd7057b3487616075032560582ec1"></a>ST_EXTERIOR_REAL_FAR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7383602bd480d43b80c626969b9af914a93f2170ad3a8132f29264dc3642a2dcf"></a>ST_INTERIOR&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1e6f72945f07940bb090ba9d5d83d2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___scene.html#ga1e6f72945f07940bb090ba9d5d83d2b7">Ogre::v1::InstanceBatch::SkeletalAnimationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1e6f72945f07940bb090ba9d5d83d2b7a9d5463190ddccc578f823e327238f0a0"></a>SKELETONS_NOT_SUPPORTED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1e6f72945f07940bb090ba9d5d83d2b7a37e606fe5cf67a5985affda126b55bd7"></a>SKELETONS_SUPPORTED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1e6f72945f07940bb090ba9d5d83d2b7a15429254436d351993ba886f5013f650"></a>SKELETONS_LUT&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae2d9033e976a32ee3899ff54444656b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::BaseInstanceBatchVTF::BaseInstanceBatchVTF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf48ac197cb6a78a50d14092531252cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceManager::BatchSettings::BatchSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac9d3bd6578fdeb109bde90d2a903ed29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatch::InstanceBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga88e6b45e3c344b00394c15922e3b8978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW::InstanceBatchHW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4b498351c48df149cac9442d3c01effb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::InstanceBatchHW_VTF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae26ce339cab52285adf0f73570ccdda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchShader::InstanceBatchShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa374617a651fa3affce8112d788e2005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchVTF::InstanceBatchVTF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">MeshPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>meshReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexToBoneMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac79f2646082998289090e03579eeeb32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstancedEntity::InstancedEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_object_memory_manager.html">ObjectMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>objectMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html">InstanceBatch</a> *&#160;</td>
          <td class="paramname"><em>batchOwner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>instanceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_bone_memory_manager.html">BoneMemoryManager</a> *&#160;</td>
          <td class="paramname"><em>boneMemoryManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>sharedTransformEntity</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab43758a4af382127188ea182fd0bb80f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceManager::InstanceManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>customName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga7fdc1f95714df3401447297dd6385e9c">InstancingTechnique</a>&#160;</td>
          <td class="paramname"><em>instancingTechnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>instancingFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>subMeshIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBoneMatrixLookup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabb5054c355d42f7f4dd743ecdc0f0b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::SendAllAnimatedTransformsToTexture </td>
          <td>(</td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>floatsPerEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entitiesPerPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>widthFloatsPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a>.</p>

</div>
</div>
<a class="anchor" id="ga63db4ef82b66e9c55dc4b9d803606a78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::SendAllDualQuatTexture </td>
          <td>(</td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>floatsPerEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entitiesPerPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>widthFloatsPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a>.</p>

</div>
</div>
<a class="anchor" id="ga571974cd58809b8c5ce63620fc86c3c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::SendAllLUTToTexture </td>
          <td>(</td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>floatsPerEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entitiesPerPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>widthFloatsPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_mesh.html#a7afe3adfb675f484e7237eeaf3661987">Mesh::IndexMap</a> *&#160;</td>
          <td class="paramname"><em>indexMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numLutEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a>.</p>

</div>
</div>
<a class="anchor" id="gaf783b19d3492b761e1c0b650a66027b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::SendAllSingleTransformsToTexture </td>
          <td>(</td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>floatsPerEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entitiesPerPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>widthFloatsPadding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a>.</p>

</div>
</div>
<a class="anchor" id="gacc28239efa3546b077d1e0fe1d3e12d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::TransformsToTexture </td>
          <td>(</td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>floatsPerEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entitiesPerPadding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>widthFloatsPadding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae2fe649857ef718be82eb64b346c1885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::BaseInstanceBatchVTF::~BaseInstanceBatchVTF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8681105efed6245a09f6198214a38363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceBatch::~InstanceBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga737709f41ca7a4d81756ba055172c680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceBatchHW::~InstanceBatchHW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadc173a3772c6a3906167383bc84d48a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceBatchHW_VTF::~InstanceBatchHW_VTF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabacb8a6ee03c316412937adf6f5318fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceBatchShader::~InstanceBatchShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga60ec0b0516a94eba081c81c246057356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceBatchVTF::~InstanceBatchVTF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabdc8266bb3f7ad80da6def68c9d30b17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstancedEntity::~InstancedEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2db6075c0163ce6ec14e64938c6d174f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::v1::InstanceManager::~InstanceManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f241cd9a3e9b1ee1622163c7d0829a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::_addDirtyStaticBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html">InstanceBatch</a> *&#160;</td>
          <td class="paramname"><em>dirtyBatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by an <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> when it requests their bounds to be updated for proper culling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirtyBatch</td><td>The batch which is dirty, usually same as caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc2bd7d7a5bc859c802e111fba414f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::_addToDynamicBatchList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html">InstanceBatch</a> *&#160;</td>
          <td class="paramname"><em>dynamicBatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kees the batch in the dynamic batch list so that it gets updated every frame. </p>
<p>_removeFromDynamicBatchList </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamicBatch</td><td>The batch which is now static or unused, usually same as caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9eb48419449394b820485f54c5febf67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatchHW_VTF::_boundsDirty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ga1604a1c98bad54429249d45d6f94e10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_defragmentBatch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimizeCulling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga23ff13a5af164d4eaaa1ebbe40570c93">InstancedEntityVec</a> &amp;&#160;</td>
          <td class="paramname"><em>usedEntities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga2fa05da2bbcd7dd55f2b78e592b9d47e">CustomParamsVec</a> &amp;&#160;</td>
          <td class="paramname"><em>usedParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>InstanceManager::defragmentBatches This function takes InstancedEntities and pushes back all entities it can fit here Extra entities in mUnusedEntities are destroyed (so that used + unused = mInstancedEntities.size()) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimizeCulling</td><td>true will call the DoCull version, false the NoCull </td></tr>
    <tr><td class="paramname">usedEntities</td><td>Array of InstancedEntities to parent with this batch. Those reparented are removed from this input vector </td></tr>
    <tr><td class="paramname">usedParams</td><td>Array of Custom parameters correlated with the InstancedEntities in usedEntities. They follow the fate of the entities in that vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>: This function assumes caller holds data to mInstancedEntities! Otherwise you can get memory leaks. Don't call this directly if you don't know what you're doing! </dd></dl>

</div>
</div>
<a class="anchor" id="ga56ecf9a4eb3688cafb89e70a1ac20676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_defragmentBatchDiscard </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>InstanceManager::_defragmentBatchDiscard Destroys unused entities and clears the mInstancedEntity container which avoids leaving dangling pointers from reparented InstancedEntities Usually called before deleting this pointer. Don't call directly! </dd></dl>

</div>
</div>
<a class="anchor" id="gaba4c1808d81ef3723cefc4207a469ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector4&amp; Ogre::v1::InstanceBatch::_getCustomParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>instancedEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga2adac0fdfd48776967e527ddc479b597">InstancedEntity::getCustomParam</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae2771c64b4fa90c0c076ea0144452203"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Mesh::IndexMap* Ogre::v1::InstanceBatch::_getIndexToBoneMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga338ae51c463d14322ba84e80be98f622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MeshPtr&amp; Ogre::v1::InstanceBatch::_getMeshRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga43254f8c9fae9547a90b72d983b8af1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre_1_1v1.html#a500ac3b30068793f1dda3f0627c5cf67">Ogre::v1::MeshPtr</a>&amp; Ogre::v1::InstanceBatch::_getMeshReference </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9b5464503278d3c32dcd2dddd489ec0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InstanceBatch* Ogre::v1::InstancedEntity::_getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0cddd2ae271b01ffdd8bc3b4296ea62c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_markTransformSharingDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells that the list of entity instances with shared transforms has changed. </p>

</div>
</div>
<a class="anchor" id="ga35bc4b3d95e53b1d5a0a772b60413a13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstancedEntity::_notifyAttached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded so we can register ourselves for updating our animations. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a4c29a048d9254c17c43a9fa313df0a6b">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b1657152e8926a2608ccf7bd7f649f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstancedEntity::_notifyParentNodeMemoryChanged </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_node.html#ae97b41e6bade0e8cfad1706de1a4bd30" title="Internal use, notifies all attached objects that our memory pointers (i.e. ">Node::_callMemoryChangeListeners</a> </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#ae47c1fe914431bbbd47d5d2a3ba258d0">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b21e13e879efa74e83b2a5ffe46ea7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstancedEntity::_notifyStaticDirty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> when it is telling we're a static <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> being dirty Don't call this directly. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a464c4d6f1f2761d8d3b715df0591b96a" title="Notifies that the given Node is dirty (i.e. ">SceneManager::notifyStaticDirty</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a715a7c5baae3fe19450321d5da42149c">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="gadca1dcbabc3ef0f0806965619ab481ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatch::_notifyStaticDirty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by InstancedEntity(s) or directly to tell us we need to update the bounds Should only useful if this batch is static. </p>

</div>
</div>
<a class="anchor" id="gaaaf92f1d5af0805b1b27b098c0efd30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::_removeFromDynamicBatchList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html">InstanceBatch</a> *&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a previously dynamic <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> went static (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga929594ecadcefcca65b1cc24794c47bf" title="Tells this batch to stop updating animations, positions, rotations, and display all it&#39;s active insta...">InstanceBatch::setStatic</a>) or a dynamic batch has no <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> in use </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The batch which is now static or unused, usually same as caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaffb433f47c29b8528d65676363f417c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_setCustomParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>instancedEntity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>newParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gaccf5778fa812b312621ea968ad01fe41" title="Sets the custom parameter for this instance. ">InstancedEntity::setCustomParam</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae6572c1ea019faaa4786d99bc95e599f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_setInstancesPerBatch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises an exception if trying to change it after being built. </p>

</div>
</div>
<a class="anchor" id="gab97607c568ffc6cc1a7f29e9093c9cf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkeletalAnimationMode Ogre::v1::InstanceBatch::_supportsSkeletalAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this technique supports skeletal animation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A virtual function could have been used, but using a simple variable overridden by the derived class is faster than virtual call overhead. And both are clean ways of implementing it. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7f3da48d2d3351e1e5a426e32509a59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_updateBounds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>InstanceManager::updateDirtyBatches </dd></dl>

</div>
</div>
<a class="anchor" id="gabddf3bd81e0eb9ae8f3ea474c5a12a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::_updateDirtyBatches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> every frame. </p>

</div>
</div>
<a class="anchor" id="gade6bfacbaa6a995d286f898819d57d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::_updateDirtyBatchesThread </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> every frame from multiple threads. </p>

</div>
</div>
<a class="anchor" id="ga59c954cc8e98b198a8da492f981b3564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::_updateEntitiesBoundsThread </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the bounds of only our entities from multiple threads. </p>
<p>To be called before _updateBounds (which is single threaded). </p><dl class="section see"><dt>See also</dt><dd>InstanceManager::updateDirtyBatches </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadIdx</td><td>The index of this thread, must be unique for each thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63d95d4f1c7d56d4751306dde6e88e81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatchHW::_updateRenderQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded to avoid updating skeletons (which we don't support), check visibility on a per unit basis and finally updated the vertex buffer. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a8561b8de767cf64740c37eb1aeddd529">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ee70165ca97043ab99526665e99a642"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::_updateRenderQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded to be able to updated the vertex texture. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a8561b8de767cf64740c37eb1aeddd529">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="gaa276a15b9a16258804347389a4420128"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatchHW_VTF::_updateRenderQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded to visibility on a per unit basis and finally updated the vertex texture. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a8561b8de767cf64740c37eb1aeddd529">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ga788ca8ce312622ee926e9ee658c84714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstancedEntity::_updateRenderQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do nothing, <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> takes care of this. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a8561b8de767cf64740c37eb1aeddd529">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="gad94f0fb565e774568423fb4b672199dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RenderOperation Ogre::v1::InstanceBatch::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs all the data needed to use this batch, as well as the InstanceEntities. </p>
<p>Placed here because in the constructor virtual tables may not have been yet filled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseSubMesh</td><td>A sub mesh which the instances will be based upon from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Call this only ONCE. This is done automatically by Ogre::InstanceManager Caller is responsable for freeing buffers in this <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html" title="&#39;New&#39; rendering operation using vertex buffers. ">RenderOperation</a> Buffers inside the RenderOp may be null if the built failed. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A render operation which is very useful to pass to other InstanceBatches (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563" title="Instancing consumes significantly more GPU memory than regular rendering methods. ...">buildFrom</a>) so that they share the same vertex buffers and indices, when possible </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bc06e2c28ef2a112a5a3c11ed41495b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatchHW::buildFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html">RenderOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>renderOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563" title="Instancing consumes significantly more GPU memory than regular rendering methods. ...">InstanceBatch::buildFrom</a> </dd></dl>

<p>Reimplemented from <a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f8f57285afe00bec42581a8cd38985c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatchShader::buildFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html">RenderOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>renderOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563" title="Instancing consumes significantly more GPU memory than regular rendering methods. ...">InstanceBatch::buildFrom</a> </dd></dl>

<p>Reimplemented from <a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="ga2673248dd7fa17a0bb5cab08fae634fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::buildFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html">RenderOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>renderOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563" title="Instancing consumes significantly more GPU memory than regular rendering methods. ...">InstanceBatch::buildFrom</a> </dd></dl>

<p>Reimplemented from <a class="el" href="group___scene.html#ga4ca7d393795939891a51ef7af4655563">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ca7d393795939891a51ef7af4655563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatch::buildFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_render_operation.html">RenderOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>renderOperation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instancing consumes significantly more GPU memory than regular rendering methods. </p>
<p>However, multiple batches can share most, if not all, of the vertex &amp; index buffers to save memory. Derived classes are free to overload this method to manipulate what to reference from Render Op. For example, Hardware based instancing uses it's own vertex buffer for the last source binding, but shares the other sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderOperation</td><td>The RenderOp to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caller is responsable for freeing buffers passed as input arguments This function replaces the need to call <a class="el" href="group___scene.html#gad94f0fb565e774568423fb4b672199dd" title="Constructs all the data needed to use this batch, as well as the InstanceEntities. ">build()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="group___scene.html#ga2673248dd7fa17a0bb5cab08fae634fd">Ogre::v1::BaseInstanceBatchVTF</a>, <a class="el" href="group___scene.html#ga9f8f57285afe00bec42581a8cd38985c">Ogre::v1::InstanceBatchShader</a>, and <a class="el" href="group___scene.html#ga2bc06e2c28ef2a112a5a3c11ed41495b">Ogre::v1::InstanceBatchHW</a>.</p>

</div>
</div>
<a class="anchor" id="gac70290b6be49beef910c800481f8688f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW::calculateMaxNumInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a" title="Some techniques have a limit on how many instances can be done. ">InstanceBatch::calculateMaxNumInstances</a> </dd></dl>

<p>Implements <a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="ga92ce9a2de8bfa4b2b6167e4920a78f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchShader::calculateMaxNumInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a" title="Some techniques have a limit on how many instances can be done. ">InstanceBatch::calculateMaxNumInstances</a> </dd></dl>

<p>Implements <a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="gac0b2dddde59ed9e85524c027caf1abd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::calculateMaxNumInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a" title="Some techniques have a limit on how many instances can be done. ">InstanceBatch::calculateMaxNumInstances</a> </dd></dl>

<p>Implements <a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="ga89e5c2f1e6b1216d302214fb2b5e2cf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchVTF::calculateMaxNumInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a" title="Some techniques have a limit on how many instances can be done. ">InstanceBatch::calculateMaxNumInstances</a> </dd></dl>

<p>Implements <a class="el" href="group___scene.html#gae1ee7fe4258d4cdb4a8a726dc237c62a">Ogre::v1::InstanceBatch</a>.</p>

</div>
</div>
<a class="anchor" id="gae1ee7fe4258d4cdb4a8a726dc237c62a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::v1::InstanceBatch::calculateMaxNumInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_sub_mesh.html">SubMesh</a> *&#160;</td>
          <td class="paramname"><em>baseSubMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some techniques have a limit on how many instances can be done. </p>
<p>Sometimes even depends on the material being used. </p><dl class="section user"><dt></dt><dd>Note this is a helper function, as such it takes a submesh base to compute the parameters, instead of using the object's own. This allows querying for a technique without requiering to actually build it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseSubMesh</td><td>The base submesh that will be using to build it. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___general.html#ga4921efc65b347efe08a6d4992af069e2" title="Flags for the Instance Manager when calculating ideal number of instances per batch. ">InstanceManagerFlags</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The max instances limit </dd></dl>

<p>Implemented in <a class="el" href="group___scene.html#ga89e5c2f1e6b1216d302214fb2b5e2cf6">Ogre::v1::InstanceBatchVTF</a>, <a class="el" href="group___scene.html#gac0b2dddde59ed9e85524c027caf1abd3">Ogre::v1::InstanceBatchHW_VTF</a>, <a class="el" href="group___scene.html#ga92ce9a2de8bfa4b2b6167e4920a78f3f">Ogre::v1::InstanceBatchShader</a>, and <a class="el" href="group___scene.html#gac70290b6be49beef910c800481f8688f">Ogre::v1::InstanceBatchHW</a>.</p>

</div>
</div>
<a class="anchor" id="gae2661aaa9b593cb48ed6747c39cf31c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::cleanupEmptyBatches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can be useful to improve CPU speed after having too many instances created, which where now removed, thus freeing many batches with zero used Instanced Entities However the batches aren't automatically removed from memory until the <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a> is destroyed, or this function is called. </p>
<p>This function removes those batches which are completely unused (only wasting memory). </p>

</div>
</div>
<a class="anchor" id="gace718a49f7de1da71d6800e9763f7232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InstancedEntity* Ogre::v1::InstanceManager::createInstancedEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em> = <code><a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">SCENE_DYNAMIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> based on an existing <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a> (. </p>
<dl class="section see"><dt>See also</dt><dd>createInstanceManager) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Return value may be null if the InstanceManger technique isn't supported Try to keep the number of entities with different materials <b>to a minimum</b> For more information </dd></dl>
<dl class="section see"><dt>See also</dt><dd>InstancedManager </dd>
<dd>
InstancedBatch, </dd>
<dd>
<a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> Alternatively you can call InstancedManager::createInstanceEntity using the returned pointer from createInstanceManager </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td><a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> name </td></tr>
    <tr><td class="paramname">managerName</td><td>Name of the instance manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> ready to be attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fc7807ede1d9d5e90bd5b087ac83055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InstancedEntity* Ogre::v1::InstanceBatch::createInstancedEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a new <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> ready to use Note it's actually preallocated, so no memory allocation happens at this point. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns NULL if all instances are being used </dd></dl>

</div>
</div>
<a class="anchor" id="ga82dd3354bca4ae42fba0903d46b973a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::defragmentBatches </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimizeCulling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After creating many entities (which turns in many batches) and then removing entities that are in the middle of these batches, there might be many batches with many free entities. </p>
<p>Worst case scenario, there could be left one batch per entity. Imagine there can be 80 entities per batch, there are 80 batches, making a total of 6400 entities. Then 6320 of those entities are removed in a very specific way, which leads to having 80 batches, 80 entities, and GPU vertex shader still needs to process 6400! This is called fragmentation. This function reparents the InstancedEntities to fewer batches, in this case leaving only one batch with 80 entities</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function takes time. Make sure to call this only when you're sure there's too much of fragmentation and you won't be creating more InstancedEntities soon Also in many cases <a class="el" href="group___scene.html#gae2661aaa9b593cb48ed6747c39cf31c2" title="This function can be useful to improve CPU speed after having too many instances created, which where now removed, thus freeing many batches with zero used Instanced Entities However the batches aren&#39;t automatically removed from memory until the InstanceManager is destroyed, or this function is called. ">cleanupEmptyBatches()</a> ought to be enough Defragmentation is done per material Static batches won't be defragmented. If you want to degragment them, set them to dynamic again, and switch back to static after calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimizeCulling</td><td>When true, entities close together will be reorganized in the same batch for more efficient CPU culling. This can take more CPU time. You want this to be false if you now you're entities are moving very randomly which tends them to get separated and spread all over the scene (which nullifies any CPU culling) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad02c2053d34cfc4d0cee0d0d02051820"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::BaseInstanceBatchVTF::forceOneWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gacf2856e90afc3bb50e3cea9a706cc970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AxisAlignedBox&amp; Ogre::v1::InstancedEntity::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2adac0fdfd48776967e527ddc479b597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector4&amp; Ogre::v1::InstancedEntity::getCustomParam </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa84baa4ab3ddad426a1ac58cb4a1f0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InstanceBatchIterator Ogre::v1::InstanceManager::getInstanceBatchIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga635aa2486e7e05c17c1fdec1913094a6">SceneMemoryMgrTypes</a>&#160;</td>
          <td class="paramname"><em>sceneType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get non-updateable iterator over instance batches for given material. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Each <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> pointer may be modified for low level usage (i.e. setCustomParameter), but there's no synchronization mechanism when multithreading or creating more instances, that's up to the user. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b16c8e81bb412c98a4a7a579e706ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InstanceBatchMapIterator Ogre::v1::InstanceManager::getInstanceBatchMapIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get non-updateable iterator over instance batches per material. </p>

</div>
</div>
<a class="anchor" id="ga63aa708650fcfc247774920597f8b723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::getInstancedEntitiesInUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga23ff13a5af164d4eaaa1ebbe40570c93">InstancedEntityVec</a> &amp;&#160;</td>
          <td class="paramname"><em>outEntities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga2fa05da2bbcd7dd55f2b78e592b9d47e">CustomParamsVec</a> &amp;&#160;</td>
          <td class="paramname"><em>outParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the input vector with the instances that are currently being used or were requested. </p>
<p>Used for defragmentation, </p><dl class="section see"><dt>See also</dt><dd>InstanceManager::defragmentBatches </dd></dl>

</div>
</div>
<a class="anchor" id="ga58ea0799e97d4187beb022939fea75af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InstancingTechnique Ogre::v1::InstanceManager::getInstancingTechnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Instancing technique this manager was created for. Can't be changed after creation </dd></dl>

<p>References <a class="el" href="group___general.html#gga635aa2486e7e05c17c1fdec1913094a6a1ea35787f06b0a63e0dd130cce754204">Ogre::SCENE_DYNAMIC</a>.</p>

</div>
</div>
<a class="anchor" id="gabf4d6fc6f75f00611436436b95a24bd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const LightList&amp; Ogre::v1::InstanceBatch::getLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p>Implements <a class="el" href="class_ogre_1_1_renderable.html#a91a5cc5e517b7c79fa510b9fdcc98691">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="ga5da4a4ded6d10e780318602f7044ffff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::v1::BaseInstanceBatchVTF::getMaxLookupTableInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum amount of shared transform entities when using lookup table </dd></dl>

</div>
</div>
<a class="anchor" id="gaa32f22bcf1fe561b0435a1909c71996b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceManager::getMaxOrBestNumInstancesPerBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>suggestedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the maximum (or the best amount, depending on flags) of instances per batch given the suggested size for the technique this manager was created for. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is done automatically when creating an instanced entity, but this function in conjunction with </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gacba57b4e048df3463879990a3b017786" title="Raises an exception if trying to change it after creating the first InstancedEntity. ">setInstancesPerBatch</a> allows more flexible control over the amount of instances per batch </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td>Name of the material to base on </td></tr>
    <tr><td class="paramname">suggestedSize</td><td>Suggested amount of instances per batch </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html" title="This is the main starting point for the new instancing system. ">InstanceManager</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___general.html#ga4921efc65b347efe08a6d4992af069e2" title="Flags for the Instance Manager when calculating ideal number of instances per batch. ">InstanceManagerFlags</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The max/best amount of instances per batch given the suggested size and flags </dd></dl>

</div>
</div>
<a class="anchor" id="gae68b97dbef7ac32396eedc828124c8a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const String&amp; Ogre::v1::InstancedEntity::getMovableType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type name of this object. </p>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#a7391beac8beb20e3e3d650173d33a3ff">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="gacfd3c7cff9b2e5e31b193d1788b120a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const String&amp; Ogre::v1::InstanceBatch::getMovableType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#a7391beac8beb20e3e3d650173d33a3ff">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="gaaaa9ae18340f16ddc801008afa9301a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IdString Ogre::v1::InstanceManager::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group___scene.html#gadeb3ccae22fafe48529509bb0b565f4e">Ogre::v1::InstanceManagerCmp::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c0783e779778622450ead2519f5c178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Ogre::v1::InstanceManager::getNumCustomParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga96af2b426ba6bc6e3cbf6e881bd66a5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::v1::InstanceBatchHW::getNumWorldTransforms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of world transform matrices this renderable requires. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When a renderable uses vertex blending, it uses multiple world matrices instead of a single one. Each vertex sent to the pipeline can reference one or more matrices in this list with given weights. If a renderable does not use vertex blending this method returns 1, which is the default for simplicity. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_renderable.html#ab6ecba3943f56182cddf3b3540afc760">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="ga89e2fe59584a51c9992f88bbe4562bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::v1::InstanceBatchShader::getNumWorldTransforms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of world transform matrices this renderable requires. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When a renderable uses vertex blending, it uses multiple world matrices instead of a single one. Each vertex sent to the pipeline can reference one or more matrices in this list with given weights. If a renderable does not use vertex blending this method returns 1, which is the default for simplicity. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_renderable.html#ab6ecba3943f56182cddf3b3540afc760">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="gac56f3ae1a20df026e775b786278405f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::v1::BaseInstanceBatchVTF::getNumWorldTransforms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of world transform matrices this renderable requires. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When a renderable uses vertex blending, it uses multiple world matrices instead of a single one. Each vertex sent to the pipeline can reference one or more matrices in this list with given weights. If a renderable does not use vertex blending this method returns 1, which is the default for simplicity. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_renderable.html#ab6ecba3943f56182cddf3b3540afc760">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="ga4be2c03c8ce89d333d51cffabf564731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::getRenderOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_render_operation.html">RenderOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>casterPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p>Implements <a class="el" href="class_ogre_1_1_renderable.html#a6e213f626f87e4754325ee6686fac246">Ogre::Renderable</a>.</p>

<p>References <a class="el" href="class_ogre_1_1_renderable.html#a2722a80d76f52dcefc0f05c72ce11daa">Ogre::Renderable::getUserAny()</a>, and <a class="el" href="class_ogre_1_1_renderable.html#a8f18715b01c0851631eb9cccd1a05552">Ogre::Renderable::setUserAny()</a>.</p>

</div>
</div>
<a class="anchor" id="gabb8865e0b63fe7b4135ec78c12b6e0ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SceneManager* Ogre::v1::InstanceManager::getSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fd8b9be7c00403a8b757daeb746a4f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManager::getSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga2967aa471d9b4bbba11ba6b6f4fc90d7">BatchSettingId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>materialName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If settings for the given material didn't exist, default value is returned. </p>

</div>
</div>
<a class="anchor" id="ga6ed691673f02b6abfc1a219e4a5ce1d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkeletonInstance* Ogre::v1::InstancedEntity::getSkeleton </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabd8ce449ec85a71faa838062b9dba855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real Ogre::v1::InstancedEntity::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used by our batch owner to get the closest entity's depth, returns infinity when not attached to a scene node. </p>

</div>
</div>
<a class="anchor" id="gac927a4be745cd1670fe88f5492c7bf00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real Ogre::v1::InstanceBatch::getSquaredViewDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ga3173dd5f9506e12f492dca47f2fc3c3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatchHW::getWorldTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world transform matrix / matrices for this renderable object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the object has any derived transforms, these are expected to be up to date as long as all the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> structures have been updated before this is called. </dd></dl>
<dl class="section user"><dt></dt><dd>This method will populate transform with 1 matrix if it does not use vertex blending. If it does use vertex blending it will fill the passed in pointer with an array of matrices, the length being the value returned from getNumWorldTransforms. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internal <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> never supports non-affine matrix for world transform matrix/matrices, the behavior is undefined if returns non-affine matrix here. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_matrix4.html#a582b20b912ed7d7f8f179505dfbe7a4e" title="Check whether or not the matrix is affine matrix. ">Matrix4::isAffine</a>. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_renderable.html#a897d64f73a5e6ccc45d52a88e86392e1">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="gaa70ec657e803b2142af17623249287fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatchShader::getWorldTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world transform matrix / matrices for this renderable object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the object has any derived transforms, these are expected to be up to date as long as all the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> structures have been updated before this is called. </dd></dl>
<dl class="section user"><dt></dt><dd>This method will populate transform with 1 matrix if it does not use vertex blending. If it does use vertex blending it will fill the passed in pointer with an array of matrices, the length being the value returned from getNumWorldTransforms. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internal <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> never supports non-affine matrix for world transform matrix/matrices, the behavior is undefined if returns non-affine matrix here. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_matrix4.html#a582b20b912ed7d7f8f179505dfbe7a4e" title="Check whether or not the matrix is affine matrix. ">Matrix4::isAffine</a>. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_renderable.html#a897d64f73a5e6ccc45d52a88e86392e1">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c0ac112786d1b9da547f4c41f68fd21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::getWorldTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the world transform matrix / matrices for this renderable object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the object has any derived transforms, these are expected to be up to date as long as all the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> structures have been updated before this is called. </dd></dl>
<dl class="section user"><dt></dt><dd>This method will populate transform with 1 matrix if it does not use vertex blending. If it does use vertex blending it will fill the passed in pointer with an array of matrices, the length being the value returned from getNumWorldTransforms. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internal <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> never supports non-affine matrix for world transform matrix/matrices, the behavior is undefined if returns non-affine matrix here. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_matrix4.html#a582b20b912ed7d7f8f179505dfbe7a4e" title="Check whether or not the matrix is affine matrix. ">Matrix4::isAffine</a>. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_renderable.html#a897d64f73a5e6ccc45d52a88e86392e1">Ogre::Renderable</a>.</p>

</div>
</div>
<a class="anchor" id="ga34379422b0e5ac8430da22c348e9a915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManager::hasSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>materialName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if settings were already created for the given material name. </p>
<p>If false is returned, it means getSetting will return default settings. </p>

</div>
</div>
<a class="anchor" id="ga8d66794c3764e2f74007e34e168691ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstancedEntity::hasSkeleton </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1v1_1_1_entity.html#a9bb21a81e228381bbd53a2d107c1b7ab" title="Returns whether or not this entity is skeletally animated. ">Entity::hasSkeleton</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga48fe1984342ba4a66d5e95d6727928d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatchHW::instanceBatchCullFrustumThreaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>combinedVisibilityFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaee23e09e0a741053a91dc2068c0de084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::v1::InstanceBatchHW_VTF::instanceBatchCullFrustumThreaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>combinedVisibilityFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4b7bd285b2cf16d7a188527a5e76d6e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceBatch::isBatchFull </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if it can not create more InstancedEntities (Num InstancedEntities == mInstancesPerBatch) </dd></dl>

</div>
</div>
<a class="anchor" id="ga2eac682480c677ad60e574b4e3d48a2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceBatch::isBatchUnused </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if it no instanced entity has been requested or all of them have been removed. </p>

</div>
</div>
<a class="anchor" id="ga4d93f4d2967505016fc525565ae71e0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::v1::InstancedEntity::isInScene </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="gaa75efec3af388b7879094a7a3c551299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstancedEntity::isInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the entity is in use. </p>

</div>
</div>
<a class="anchor" id="ga9d8174300d9fd7b766d727c85e11a20f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OgreExport bool Ogre::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_shadow_texture_config.html">ShadowTextureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_shadow_texture_config.html">ShadowTextureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa4ad57afec4a689c118c5a61bb3a72e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga50eb7990483aa544ee7d70fbe40f03f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga13ab906e4ed2d67f9c4eb24cff862388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga706d4b6aa41612ff68fb08b90a0a5a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_ogre_platform_8h.html#a724fb9f82013c782db5c3c12ea36aac8">FORCEINLINE</a> void Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadeb3ccae22fafe48529509bb0b565f4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManagerCmp::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="group___scene.html#gaaaa9ae18340f16ddc801008afa9301a1">Ogre::v1::InstanceManager::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed507a902be142d166cca7755774cc47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManagerCmp::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="group___scene.html#gaaaa9ae18340f16ddc801008afa9301a1">Ogre::v1::InstanceManager::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2c1adadd3106188ef91759c4cd1a848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManagerCmp::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1v1_1_1_instance_manager.html">InstanceManager</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="group___scene.html#gaaaa9ae18340f16ddc801008afa9301a1">Ogre::v1::InstanceManager::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="gab426b0250db523190d60f4bfe0414499"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OgreExport bool Ogre::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_shadow_texture_config.html">ShadowTextureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_shadow_texture_config.html">ShadowTextureConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf0ca971a27b832f845c400c2fb703ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceBatch::removeInstancedEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>instancedEntity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> from the scene retrieved with getNewInstancedEntity, putting back into a queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Throws an exception if the instanced entity wasn't created by this batch Removed instanced entities save little CPU time, but <em>not</em> GPU </dd></dl>

</div>
</div>
<a class="anchor" id="ga71ea1d192952ed23c66cf3eaa19342e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::setBatchesAsStatic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStatic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells this batch to stop updating animations, positions, rotations, and display all it's active instances. </p>
<p>Some implementations allow to keep culling individual instances while others may not. This option makes the batch behave pretty much like Static Geometry, plust the GPU RAM memory advantages (less VRAM, less bandwidth) but no LOD support. Very useful for billboards of trees, repeating vegetation, modular buildings, etc. </p><dl class="section remark"><dt>Remarks</dt><dd>When individual culling is disabled (or not supported) This function moves a lot of processing time from the CPU to the GPU. If the GPU is already a bottleneck, you may see a decrease in performance instead!  updateStaticDirty if you've made a change to an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> and wish that change to take effect. Be sure to call this after you've set all your instances and not once per change. </dd></dl>

</div>
</div>
<a class="anchor" id="ga106b017a71c558d5d6b26585b91cc7d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::setBoneDualQuaternions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4f8bb77feada5b5ea649187781c19ade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::setBoneMatrixLookup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLookupTableInstances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state of the usage of bone matrix lookup. </p>
<p>Under default condition each instance entity is assigned a specific area in the vertex texture for bone matrix data. When turned on the amount of area in the vertex texture assigned for bone matrix data will be relative to the amount of unique animation states. Instanced entities sharing the same animation state will share the same area in the matrix. The specific position of each entity is placed in the vertex data and added in a second phase in the shader.</p>
<p>Note this feature only works in VTF_HW for now. This value needs to be set before adding any instanced entities </p>

</div>
</div>
<a class="anchor" id="gaccf5778fa812b312621ea968ad01fe41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstancedEntity::setCustomParam </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>newParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the custom parameter for this instance. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga83716fab444f001c458c42ebaaec81aa" title="Sets the number of custom parameters per instance. ">InstanceManager::setNumCustomParams</a> Because not all techniques support custom params, and some users may not need it while using millions of InstancedEntities, the params have been detached from <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> and stored in it's <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> instead, to reduce memory overhead. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If this function is never called, all instances default to <a class="el" href="class_ogre_1_1_vector4.html#a6094638aa9e67551258f70f113d805d9">Vector4::ZERO</a>. Watch out! If you destroy an instanced entity and then create it again (remember! Instanced entities are pre-allocated) it's custom param will contain the old value when it was destroyed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>of the param. In the range [0; <a class="el" href="group___scene.html#ga5c0783e779778622450ead2519f5c178">InstanceManager::getNumCustomParams()</a>) </td></tr>
    <tr><td class="paramname">newParam</td><td>New parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac57b941b0f9b4f7b21c894b497893309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::setForceOneWeight </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gacba57b4e048df3463879990a3b017786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::setInstancesPerBatch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instancesPerBatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises an exception if trying to change it after creating the first <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The actual value may be less if the technique doesn't support having so much </dd></dl>
<dl class="section see"><dt>See also</dt><dd>getMaxOrBestNumInstancesPerBatches for the usefulness of this function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instancesPerBatch</td><td>New instances per batch number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaad114bb59090ecd3e9d9f187281d0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::setMaxLookupTableInstances </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLookupTableInstances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the lookup table for techniques supporting bone lookup table. </p>
<p>Raises an exception if trying to change it after creating the first <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a>. Setting this value below the number of unique (non-sharing) entity instance animations will produce a crash during runtime. Setting this value above will increase memory consumption and reduce framerate. </p><dl class="section remark"><dt>Remarks</dt><dd>The value should be as close but not below the actual value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLookupTableInstances</td><td>New size of the lookup table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83716fab444f001c458c42ebaaec81aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::setNumCustomParams </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>numCustomParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of custom parameters per instance. </p>
<p>Some techniques (i.e. HWInstancingBasic) support this, but not all of them. They also may have limitations to the max number. All instancing implementations assume each instance param is a <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Vector4</a> (4 floats). </p><dl class="section remark"><dt>Remarks</dt><dd>This function cannot be called after the first batch has been created. Otherwise it will raise an exception. If the technique doesn't support custom params, it will raise an exception at the time of building the first <a class="el" href="class_ogre_1_1v1_1_1_instance_batch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a>.</dd></dl>
<p>HWInstancingBasic: Each custom params adds an additional float4 TEXCOORD. HWInstancingVTF: Not implemented. (Recommendation: Implement this as an additional float4 VTF fetch) TextureVTF: Not implemented. (see HWInstancingVTF's recommendation) ShaderBased: Not supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCustomParams</td><td>Number of custom parameters each instance will have. Default: 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafcba48afeb829895876e34b5e355df20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstanceManager::setSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___scene.html#ga2967aa471d9b4bbba11ba6b6f4fc90d7">BatchSettingId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>materialName</em> = <code><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a setting for all batches using the same material_ existing ones and those that will be created in the future. </p>
<dl class="section user"><dt></dt><dd>For example setSetting( BatchSetting::CAST_SHADOWS, false ) disables shadow casting for all instanced entities (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>MovableObject::setCastShadow) </dd></dl>
<dl class="section user"><dt></dt><dd>For example setSetting( BatchSetting::SHOW_BOUNDINGBOX, true, "MyMat" ) will display the bounding box of the batch (not individual InstancedEntities) from all batches using material "MyMat" </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the material name hasn't been used, the settings are still stored This allows setting up batches before they get even created. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Setting <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() ) ">Id</a> to setup, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>BatchSettings::BatchSettingId </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Boolean value. It's meaning depends on the id. </td></tr>
    <tr><td class="paramname">materialName</td><td>When Blank, the setting is applied to all existing materials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga929594ecadcefcca65b1cc24794c47bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceBatch::setStatic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStatic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells this batch to stop updating animations, positions, rotations, and display all it's active instances. </p>
<p>Some implementations allow to keep culling individual instances while others may not. This option makes the batch behave pretty much like Static Geometry, plust the GPU RAM memory advantages (less VRAM, less bandwidth) but no LOD support. Very useful for billboards of trees, repeating vegetation, modular buildings, etc. </p><dl class="section remark"><dt>Remarks</dt><dd>When individual culling is disabled (or not supported) This function moves a lot of processing time from the CPU to the GPU. If the GPU is already a bottleneck, you may see a decrease in performance instead!  updateStaticDirty if you've made a change to an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> and wish that change to take effect. Be sure to call this after you've set all your instances and not once per change. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dac364674912ef03373e229b7b30ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstancedEntity::setTransformLookupNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a>&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the transformation look up number. </p>

</div>
</div>
<a class="anchor" id="gae7365adfb71eba4f29b80bbb715e0e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::BaseInstanceBatchVTF::setUseOneWeight </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaac2b594b3d213fa98136d444c3260f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstancedEntity::shareTransformWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> *&#160;</td>
          <td class="paramname"><em>slave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shares the entire transformation with another <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a>. </p>
<p>This is useful when a mesh has more than one submeshes, therefore creating multiple InstanceManagers (one for each submesh). With this function, sharing makes the skeleton to be shared (less memory) and updated once (performance optimization). Note that one <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> (i.e. submesh 0) must be chosen as "master" which will share with the other instanced entities (i.e. submeshes 1-N) which are called "slaves" </p><dl class="section user"><dt></dt><dd>Requirements to share trasnformations: Both InstancedEntities must have use the same skeleton An <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> can't be both "master" and "slave" at the same time </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Sharing does nothing if the original mesh doesn't have a skeleton When an <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> is removed (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gaf0ca971a27b832f845c400c2fb703ab6" title="Removes an InstancedEntity from the scene retrieved with getNewInstancedEntity, putting back into a q...">InstanceBatch::removeInstancedEntity</a>), it stops sharing the transform. If the instanced entity was the master one, all it's slaves stop sharing and start having their own transform too. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave</td><td>The <a class="el" href="class_ogre_1_1v1_1_1_instanced_entity.html">InstancedEntity</a> that should share with us and become our slave </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully shared (may fail if they aren't skeletally animated) </dd></dl>

</div>
</div>
<a class="anchor" id="gab9e4b89e573430e54d73d4e2ead68c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::v1::InstancedEntity::stopSharingTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#gaac2b594b3d213fa98136d444c3260f00" title="Shares the entire transformation with another InstancedEntity. ">shareTransformWith</a> Stops sharing the transform if this is a slave, and notifies the master we're no longer a slave. If this is a master, tells all it's slave to stop sharing </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is automatically called in <a class="el" href="group___scene.html#gaf0ca971a27b832f845c400c2fb703ab6" title="Removes an InstancedEntity from the scene retrieved with getNewInstancedEntity, putting back into a q...">InstanceBatch::removeInstancedEntity</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae1c80068652d0ed7d22382eb17edfbc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::BaseInstanceBatchVTF::useBoneDualQuaternions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadd8a62bb549dc220c1622f4f6611c0e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::BaseInstanceBatchVTF::useBoneMatrixLookup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether to use bone matrix lookup. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___scene.html#ga4f8bb77feada5b5ea649187781c19ade" title="Sets the state of the usage of bone matrix lookup. ">setBoneMatrixLookup()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4c2410a68737fab576c54dc88b910d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::BaseInstanceBatchVTF::useOneWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gad4d3c5cdc5cc4e37e20b71f3ac530a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::boneIdxEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5ec16dbb787ab245793ff967d8286920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::boneIdxEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4e3885247e28d9be98020e8f93436afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::boneIdxEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf1aab4dd5ba2fdd5397a9b1d5fa29842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::boneIdxStart</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8bef86e4765714dbeabf14b000a714fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::boneIdxStart</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadac827bc395039b3ab33243ffba820bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::IndexMap::const_iterator Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::boneIdxStart</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3e74097af8a052c92b4f3993d6dd55c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* <a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mDest</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaba497c1283d910384b53e1061f0617d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mEntitiesPerPadding</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabc151cd49376bdd7de5570770c2f0781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mFloatsPerEntity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2d321df7b753c8c218ae453b57b1e295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::SendAllSingleTransformsToTexture::mInstancesWritten</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga318ff608d7d1a3bb970131d37961c05d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::SendAllAnimatedTransformsToTexture::mInstancesWritten</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga201a73735cdbc245585a30c6d2f7465e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::SendAllDualQuatTexture::mInstancesWritten</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga05c4b731d5d25c2077b9448276c23c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::v1::InstanceBatchHW_VTF::TransformsToTexture::mWidthFloatsPadding</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga70957102db852f95b46596112ec28433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt;::type Ogre::v1::InstanceBatchHW_VTF::SendAllLUTToTexture::mWrittenPositions</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0fa8a219500a7ecfca2e725822603d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::v1::InstanceManager::BatchSettings::setting[NUM_SETTINGS]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a class="anchor" id="ga41ffb53da525c94819e85211fc48449c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class BaseInstanceBatchVTF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab0ddd6acb1bcb90f4ac672b7ba7569b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class InstanceBatch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga204d0aed3320790edf10711c32f3db73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class InstanceBatchHW</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9534bbd3a2646322b2767289cb9c972c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class InstanceBatchHW_VTF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf05a8273f12bc11f025607a06b3b3e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class InstanceBatchShader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 4 2017 22:21:36 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
