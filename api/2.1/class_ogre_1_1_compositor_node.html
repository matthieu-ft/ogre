<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::CompositorNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">2.1.0unstable</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_compositor_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_compositor_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::CompositorNode Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___effects.html">Effects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Compositor nodes are the core subject of compositing.  
 <a href="class_ogre_1_1_compositor_node.html#details">More...</a></p>

<p><code>#include &lt;OgreCompositorNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::CompositorNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_compositor_node__inherit__graph.svg" width="283" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a231234c69e7643bd191e15900f606dc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a231234c69e7643bd191e15900f606dc9">CompositorNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *definition, <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSys, const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *finalTarget)</td></tr>
<tr class="memdesc:a231234c69e7643bd191e15900f606dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() ) ">Id</a> must be unique across all engine so we can create unique named textures.  <a href="#a231234c69e7643bd191e15900f606dc9">More...</a><br /></td></tr>
<tr class="separator:a231234c69e7643bd191e15900f606dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958b95a5fd93b1fbbf93e68795590274"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a958b95a5fd93b1fbbf93e68795590274">~CompositorNode</a> ()</td></tr>
<tr class="separator:a958b95a5fd93b1fbbf93e68795590274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c528a4e46ce30458a57ee8a275b1d1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a2c528a4e46ce30458a57ee8a275b1d1b">_getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName) const </td></tr>
<tr class="separator:a2c528a4e46ce30458a57ee8a275b1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab092917f1f520d9a70e1ce862a9606b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ab092917f1f520d9a70e1ce862a9606b2">_getPasses</a> () const </td></tr>
<tr class="separator:ab092917f1f520d9a70e1ce862a9606b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9042470e9bdae1869d9c4adbe6605cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9042470e9bdae1869d9c4adbe6605cb9">_notifyCleared</a> (void)</td></tr>
<tr class="memdesc:a9042470e9bdae1869d9c4adbe6605cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Use.  <a href="#a9042470e9bdae1869d9c4adbe6605cb9">More...</a><br /></td></tr>
<tr class="separator:a9042470e9bdae1869d9c4adbe6605cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9eb4f664cb4048c4ff035b705b9adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeb9eb4f664cb4048c4ff035b705b9adb">_placeBarriersAndEmulateUavExecution</a> (<a class="el" href="struct_ogre_1_1_bound_uav.html">BoundUav</a> boundUavs[64], <a class="el" href="group___resources.html#gaf3069e13b1cf5ad9102ad2c90eefcb04">ResourceAccessMap</a> &amp;uavsAccess, <a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;resourcesLayout)</td></tr>
<tr class="separator:aeb9eb4f664cb4048c4ff035b705b9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158173d3bd07eb2a591fbf0410ad5f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a158173d3bd07eb2a591fbf0410ad5f52">_removeAllBarriers</a> (void)</td></tr>
<tr class="separator:a158173d3bd07eb2a591fbf0410ad5f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab515beadc41042109d2bddac504b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abab515beadc41042109d2bddac504b1c">_setFinalTargetAsRenderTarget</a> (ResourceLayoutMap::iterator finalTargetCurrentLayout)</td></tr>
<tr class="memdesc:abab515beadc41042109d2bddac504b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a resource transition in our last pass to the given <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a>.  <a href="#abab515beadc41042109d2bddac504b1c">More...</a><br /></td></tr>
<tr class="separator:abab515beadc41042109d2bddac504b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e112618b5ed2936391b2bfc45d224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aad4e112618b5ed2936391b2bfc45d224">_update</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:aad4e112618b5ed2936391b2bfc45d224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function every frame will cause us to execute all our passes (ie.  <a href="#aad4e112618b5ed2936391b2bfc45d224">More...</a><br /></td></tr>
<tr class="separator:aad4e112618b5ed2936391b2bfc45d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd438c31fd1320364b50029a4f03ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a2fd438c31fd1320364b50029a4f03ec6">areAllInputsConnected</a> () const </td></tr>
<tr class="separator:a2fd438c31fd1320364b50029a4f03ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2960e9ca1de509c9c3ff36d847997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5dd2960e9ca1de509c9c3ff36d847997">connectBufferTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a5dd2960e9ca1de509c9c3ff36d847997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version)  <a href="#a5dd2960e9ca1de509c9c3ff36d847997">More...</a><br /></td></tr>
<tr class="separator:a5dd2960e9ca1de509c9c3ff36d847997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeed3172d72e30cbd79ef663c8c1adfd7">connectExternalBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer, size_t inChannelA)</td></tr>
<tr class="memdesc:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external buffer into the given channel.  <a href="#aeed3172d72e30cbd79ef663c8c1adfd7">More...</a><br /></td></tr>
<tr class="separator:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1815e2b15c8860d9e726e5e884a5569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ac1815e2b15c8860d9e726e5e884a5569">connectExternalRT</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;externalTexture, size_t inChannelA)</td></tr>
<tr class="memdesc:ac1815e2b15c8860d9e726e5e884a5569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external RT into the given channel.  <a href="#ac1815e2b15c8860d9e726e5e884a5569">More...</a><br /></td></tr>
<tr class="separator:ac1815e2b15c8860d9e726e5e884a5569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd8041dbce265afd92ac9c11769fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb">connectTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a0bfd8041dbce265afd92ac9c11769fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version)  <a href="#a0bfd8041dbce265afd92ac9c11769fbb">More...</a><br /></td></tr>
<tr class="separator:a0bfd8041dbce265afd92ac9c11769fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae0d443c369fb5e9d26ec20300c85aaf7">createPasses</a> (void)</td></tr>
<tr class="memdesc:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all passes based on our definition.  <a href="#ae0d443c369fb5e9d26ec20300c85aaf7">More...</a><br /></td></tr>
<tr class="separator:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bde2d2a53ca30e7bbc3bd3c9c4b569d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a8bde2d2a53ca30e7bbc3bd3c9c4b569d">finalTargetResized</a> (const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *finalTarget)</td></tr>
<tr class="memdesc:a8bde2d2a53ca30e7bbc3bd3c9c4b569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes. ">CompositorManager2</a> when (i.e.) the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a> was resized, thus our RTs that depend on their resolution need to be recreated.  <a href="#a8bde2d2a53ca30e7bbc3bd3c9c4b569d">More...</a><br /></td></tr>
<tr class="separator:a8bde2d2a53ca30e7bbc3bd3c9c4b569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38d654e6392a75db3874bc629d2238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abb38d654e6392a75db3874bc629d2238">getDefinedBuffer</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const </td></tr>
<tr class="memdesc:abb38d654e6392a75db3874bc629d2238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pointer of a buffer based on it's name.  <a href="#abb38d654e6392a75db3874bc629d2238">More...</a><br /></td></tr>
<tr class="separator:abb38d654e6392a75db3874bc629d2238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0faaa17e9f12b2857cea356f8a6c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a1c0faaa17e9f12b2857cea356f8a6c5b">getDefinedBufferNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const </td></tr>
<tr class="separator:a1c0faaa17e9f12b2857cea356f8a6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adc25abf95847957accdef16dad6f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6adc25abf95847957accdef16dad6f63">getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName, size_t mrtIndex) const </td></tr>
<tr class="memdesc:a6adc25abf95847957accdef16dad6f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture pointer of a texture based on it's name &amp; mrt index.  <a href="#a6adc25abf95847957accdef16dad6f63">More...</a><br /></td></tr>
<tr class="separator:a6adc25abf95847957accdef16dad6f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65043035a27d8e304aea76c44d96e1c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a65043035a27d8e304aea76c44d96e1c0">getDefinition</a> () const </td></tr>
<tr class="separator:a65043035a27d8e304aea76c44d96e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6022c387e763c0457c2f903e6f1dc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aca6022c387e763c0457c2f903e6f1dc1">getEnabled</a> (void) const </td></tr>
<tr class="memdesc:aca6022c387e763c0457c2f903e6f1dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this instance is enabled.  setEnabled.  <a href="#aca6022c387e763c0457c2f903e6f1dc1">More...</a><br /></td></tr>
<tr class="separator:aca6022c387e763c0457c2f903e6f1dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6ca4d958ad185fffa29c8524b1934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a91a6ca4d958ad185fffa29c8524b1934">getId</a> () const </td></tr>
<tr class="memdesc:a91a6ca4d958ad185fffa29c8524b1934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <a href="#a91a6ca4d958ad185fffa29c8524b1934">More...</a><br /></td></tr>
<tr class="separator:a91a6ca4d958ad185fffa29c8524b1934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052b98fbc5531ca879ffe020299c0b97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a052b98fbc5531ca879ffe020299c0b97">getInputChannel</a> () const </td></tr>
<tr class="separator:a052b98fbc5531ca879ffe020299c0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d939ba6e22b059ec6c990f2f5b16c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae6d939ba6e22b059ec6c990f2f5b16c4">getLocalTextures</a> () const </td></tr>
<tr class="separator:ae6d939ba6e22b059ec6c990f2f5b16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90dec64f084c6963bced189994f7bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#af90dec64f084c6963bced189994f7bbc">getName</a> (void) const </td></tr>
<tr class="separator:af90dec64f084c6963bced189994f7bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1264537bdc0ed5fe7200eb34727ad9df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a1264537bdc0ed5fe7200eb34727ad9df">getPassNumber</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) const </td></tr>
<tr class="separator:a1264537bdc0ed5fe7200eb34727ad9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca139f7e1c8bc844c7782c887b9649cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aca139f7e1c8bc844c7782c887b9649cc">getRenderSystem</a> (void) const </td></tr>
<tr class="separator:aca139f7e1c8bc844c7782c887b9649cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a3ffe9f2a0e8fd48f57d3e2693fb181be">getWorkspace</a> (void)</td></tr>
<tr class="memdesc:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <a href="#a3ffe9f2a0e8fd48f57d3e2693fb181be">More...</a><br /></td></tr>
<tr class="separator:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1225a409a553dc78582ff54179e356dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a1225a409a553dc78582ff54179e356dc">getWorkspace</a> (void) const </td></tr>
<tr class="memdesc:a1225a409a553dc78582ff54179e356dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <a href="#a1225a409a553dc78582ff54179e356dc">More...</a><br /></td></tr>
<tr class="separator:a1225a409a553dc78582ff54179e356dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a95aaefe91c3d2d7bb040e2e3e74f9408">notifyDestroyed</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;channel)</td></tr>
<tr class="memdesc:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when caller has destroyed a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a> in which the callee may have a reference to that pointer, so that we can clean it up.  <a href="#a95aaefe91c3d2d7bb040e2e3e74f9408">More...</a><br /></td></tr>
<tr class="separator:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9edc7379e9c8759de9abb0baaf2135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e9edc7379e9c8759de9abb0baaf2135">notifyDestroyed</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer)</td></tr>
<tr class="separator:a6e9edc7379e9c8759de9abb0baaf2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081b18ad77e67e1d5e561ceb61933bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a081b18ad77e67e1d5e561ceb61933bbf">notifyRecreated</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;oldChannel, const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;newChannel)</td></tr>
<tr class="memdesc:a081b18ad77e67e1d5e561ceb61933bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you're replacing the textures from oldChannel with the ones in newChannel.  <a href="#a081b18ad77e67e1d5e561ceb61933bbf">More...</a><br /></td></tr>
<tr class="separator:a081b18ad77e67e1d5e561ceb61933bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e7c49813462a88761ff73f514d7ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a01e7c49813462a88761ff73f514d7ce8">notifyRecreated</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *oldBuffer, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *newBuffer)</td></tr>
<tr class="separator:a01e7c49813462a88761ff73f514d7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693eac3a7af913adfbb28ba49935842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae693eac3a7af913adfbb28ba49935842">resetAllNumPassesLeft</a> (void)</td></tr>
<tr class="memdesc:ae693eac3a7af913adfbb28ba49935842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of passes left for every pass (.  <a href="#ae693eac3a7af913adfbb28ba49935842">More...</a><br /></td></tr>
<tr class="separator:ae693eac3a7af913adfbb28ba49935842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817bc10dbf5427a77912ab3bcd391f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69">setEnabled</a> (bool bEnabled)</td></tr>
<tr class="memdesc:a817bc10dbf5427a77912ab3bcd391f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables all instances of this node.  <a href="#a817bc10dbf5427a77912ab3bcd391f69">More...</a><br /></td></tr>
<tr class="separator:a817bc10dbf5427a77912ab3bcd391f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ad2eb91ac8d2a01147d9623ce9e0a8020">fillResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;compositorChannels, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides a resource with the given layout if it's already in outResourcesLayout.  <a href="#ad2eb91ac8d2a01147d9623ce9e0a8020">More...</a><br /></td></tr>
<tr class="separator:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd13076afe5697f54967d82db43403"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a7fdd13076afe5697f54967d82db43403">initResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;compositorChannels, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:a7fdd13076afe5697f54967d82db43403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only inits a resource with the given layout if it wasn't already in outResourcesLayout.  <a href="#a7fdd13076afe5697f54967d82db43403">More...</a><br /></td></tr>
<tr class="separator:a7fdd13076afe5697f54967d82db43403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc51f87af9846e88b03c932dc79ac0af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#adc51f87af9846e88b03c932dc79ac0af">initResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#gabe54b22d0cf0eb77a49fed877816fe2d">CompositorNamedBufferVec</a> &amp;buffers, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:adc51f87af9846e88b03c932dc79ac0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only inits a resource with the given layout if it wasn't already in outResourcesLayout.  <a href="#adc51f87af9846e88b03c932dc79ac0af">More...</a><br /></td></tr>
<tr class="separator:adc51f87af9846e88b03c932dc79ac0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compositor nodes are the core subject of compositing. </p>
<p>This is an instantiation. All const, shared parameters are in the definition (<a class="el" href="class_ogre_1_1_compositor_node_def.html" title="Compositor nodes are the core subject of compositing. ">CompositorNodeDef</a>) and we assume they don't change throughout the lifetime of our instance. </p><dl class="section user"><dt></dt><dd>The textures in mLocalTextures are managed by us and we're responsible for freeing them when they're no longer needed. </dd></dl>
<dl class="section user"><dt></dt><dd>Before nodes can be used, they have to be connected between each other, followed by a call to routeOutputs() Connections must be done in a very specific order, so let the manager take care of solving the dependencies. Basically the problem is that if the chain is like this: A -&gt; B -&gt; C; if we connect node B to C first, then there's a chance of giving null pointers to C instead of the valid ones that belong to A. </dd></dl>
<dl class="section user"><dt></dt><dd>To solve this problem, we first start with nodes that have no input, and then continue with those who have all of their input set; then repeat until there are no nodes to be processed. If there's still nodes with input left open; then those nodes can't be activated and the workspace is invalid. </dd></dl>
<dl class="section user"><dt></dt><dd>No <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> can be valid if it has disconnected input channels left. Nodes can have no input because they either use passes that don't need it (eg. scene pass) or use global textures as means for sharing their work Similarly, Nodes may have no output because they use global textures. </dd></dl>
<dl class="section user"><dt></dt><dd>Nodes with feedback loops are not supported and may or may not work. A feedback loop is when A's output is used in B, B to C, then C is plugged back into A. </dd></dl>
<dl class="section user"><dt></dt><dd>It's possible to assign the same output to two different input channels, though it could work very unintuitively... (because two textures that may be intended to be hard copies are actually sharing the same memory) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>We own the local textures, so it's our job to destroy them </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matias N. Goldberg </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a231234c69e7643bd191e15900f606dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::CompositorNode::CompositorNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a> *&#160;</td>
          <td class="paramname"><em>definition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_ogre_1_1_id.html" title="Usage: OGRE_NEW SceneNode( Id::generateNewId&lt; Node &gt;() ) ">Id</a> must be unique across all engine so we can create unique named textures. </p>
<p>The name is only unique across the workspace </p>

</div>
</div>
<a class="anchor" id="a958b95a5fd93b1fbbf93e68795590274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::CompositorNode::~CompositorNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2c528a4e46ce30458a57ee8a275b1d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a>* Ogre::CompositorNode::_getDefinedTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>textureName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab092917f1f520d9a70e1ce862a9606b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a>&amp; Ogre::CompositorNode::_getPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9042470e9bdae1869d9c4adbe6605cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_notifyCleared </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Use. </p>
<p>Called when connections are all being zero'ed. We rely our caller is doing this to all nodes, hence we do not notify our  nodes. Failing to clear them too may leave dangling pointers or graphical glitches </p><dl class="section remark"><dt>Remarks</dt><dd>Destroys all of our passes. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb9eb4f664cb4048c4ff035b705b9adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_placeBarriersAndEmulateUavExecution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_bound_uav.html">BoundUav</a>&#160;</td>
          <td class="paramname"><em>boundUavs</em>[64], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#gaf3069e13b1cf5ad9102ad2c90eefcb04">ResourceAccessMap</a> &amp;&#160;</td>
          <td class="paramname"><em>uavsAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>resourcesLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass.html#ad75735f2516fb15f48a875d078cbc505" title="Emulates the execution of a UAV to understand memory dependencies, and adds a memory barrier / resour...">CompositorPass::_placeBarriersAndEmulateUavExecution</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a158173d3bd07eb2a591fbf0410ad5f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_removeAllBarriers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass.html#a57ce009ce1f8c325d12c522210127d58">CompositorPass::_removeAllBarriers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abab515beadc41042109d2bddac504b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_setFinalTargetAsRenderTarget </td>
          <td>(</td>
          <td class="paramtype">ResourceLayoutMap::iterator&#160;</td>
          <td class="paramname"><em>finalTargetCurrentLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a resource transition in our last pass to the given <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a>. </p>
<p>Usually needed to ensure the final '<a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a>' is still a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a> after the workspace is finished. </p>

</div>
</div>
<a class="anchor" id="aad4e112618b5ed2936391b2bfc45d224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this function every frame will cause us to execute all our passes (ie. </p>
<p>render) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodCamera</td><td>LOD <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Camera</a> to be used by our passes. Pointer can be null, and note however passes can ignore this hint and use their own camera pointer for LOD (this parameter is mostly used for syncing shadow mapping). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fd438c31fd1320364b50029a4f03ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::areAllInputsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5dd2960e9ca1de509c9c3ff36d847997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectBufferTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeed3172d72e30cbd79ef663c8c1adfd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects (injects) an external buffer into the given channel. </p>
<p>Usually used for the 'connect_buffer_external' directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1815e2b15c8860d9e726e5e884a5569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalRT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>externalTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects (injects) an external RT into the given channel. </p>
<p>Usually used for the "connect_output" / "connect_external" directive for the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a>. </td></tr>
    <tr><td class="paramname">textures</td><td>The Textures associated with the RT. Can be empty (eg. <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a>) but could cause crashes/exceptions if tried to use in PASS_QUAD passes. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bfd8041dbce265afd92ac9c11769fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0d443c369fb5e9d26ec20300c85aaf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::createPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates all passes based on our definition. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function after connecting all channels (at least our input) otherwise we may bind null pointer RTs to the passes (and then crash)  connectTo and </dd></dl>
<dl class="section see"><dt>See also</dt><dd>connectFinalRT </dd></dl>

</div>
</div>
<a class="anchor" id="ad2eb91ac8d2a01147d9623ce9e0a8020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::fillResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td>
          <td class="paramname"><em>compositorChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides a resource with the given layout if it's already in outResourcesLayout. </p>

</div>
</div>
<a class="anchor" id="a8bde2d2a53ca30e7bbc3bd3c9c4b569d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorNode::finalTargetResized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes. ">CompositorManager2</a> when (i.e.) the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a> was resized, thus our RTs that depend on their resolution need to be recreated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>We inform all connected nodes and passes related to us of RenderTargets/Textures that may have been recreated (pointers could become danlging otherwise). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalTarget</td><td>The Final Target (i.e. <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">RenderWindow</a>) from which we'll base our local textures' resolution. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a7958822429b172906dbe491456313e0b">Ogre::CompositorShadowNode</a>.</p>

</div>
</div>
<a class="anchor" id="abb38d654e6392a75db3874bc629d2238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::CompositorNode::getDefinedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pointer of a buffer based on it's name. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer may come from a local buffer, an input buffer, or global (workspace). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferName</td><td>The name of the buffer. This name may only be valid at node scope. It can refer to an input buffer, a local buffer, or a global one. If a local or input buffer has the same name as a global one, the global one is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Regular: The buffer. Throws if buffer wasn't found. No throw version: Null if not found. The buffer otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1c0faaa17e9f12b2857cea356f8a6c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::CompositorNode::getDefinedBufferNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6adc25abf95847957accdef16dad6f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> Ogre::CompositorNode::getDefinedTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mrtIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture pointer of a texture based on it's name &amp; mrt index. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The texture name must have been registered with <a class="el" href="class_ogre_1_1_texture_definition_base.html#a02ec073273bf07eb78122ddb2a4606f1" title="Adds a texture name, whether a real one or an alias, and where to grab it from. ">CompositorNodeDef::addTextureSourceName</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The name of the texture. This name may only be valid at node scope. It can refer to an input texture, a local texture, or a global one. If the global texture wasn't registered with addTextureSourceName, it will fail. </td></tr>
    <tr><td class="paramname">mrtIndex</td><td>The MRT (Multiple Render Target) index. If the texture isn't MRT or has less RTs than the index, it returns the highest valid index found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null if not found (or global texture not registered). The texture otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a65043035a27d8e304aea76c44d96e1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_node_def.html">CompositorNodeDef</a>* Ogre::CompositorNode::getDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca6022c387e763c0457c2f903e6f1dc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::getEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this instance is enabled.  setEnabled. </p>

</div>
</div>
<a class="anchor" id="a91a6ca4d958ad185fffa29c8524b1934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> Ogre::IdObject::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique id of this object. </p>

</div>
</div>
<a class="anchor" id="a052b98fbc5531ca879ffe020299c0b97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a>&amp; Ogre::CompositorNode::getInputChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6d939ba6e22b059ec6c990f2f5b16c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a>&amp; Ogre::CompositorNode::getLocalTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af90dec64f084c6963bced189994f7bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::CompositorNode::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1264537bdc0ed5fe7200eb34727ad9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::CompositorNode::getPassNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aca139f7e1c8bc844c7782c887b9649cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a>* Ogre::CompositorNode::getRenderSystem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ffe9f2a0e8fd48f57d3e2693fb181be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a>* Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a class="anchor" id="a1225a409a553dc78582ff54179e356dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a>* Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a class="anchor" id="a7fdd13076afe5697f54967d82db43403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::initResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td>
          <td class="paramname"><em>compositorChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only inits a resource with the given layout if it wasn't already in outResourcesLayout. </p>

</div>
</div>
<a class="anchor" id="adc51f87af9846e88b03c932dc79ac0af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::initResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gabe54b22d0cf0eb77a49fed877816fe2d">CompositorNamedBufferVec</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only inits a resource with the given layout if it wasn't already in outResourcesLayout. </p>

</div>
</div>
<a class="anchor" id="a95aaefe91c3d2d7bb040e2e3e74f9408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when caller has destroyed a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation. ">RenderTarget</a> in which the callee may have a reference to that pointer, so that we can clean it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel containing the pointer about to be destroyed (must still be valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e9edc7379e9c8759de9abb0baaf2135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a081b18ad77e67e1d5e561ceb61933bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>oldChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>newChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when you're replacing the textures from oldChannel with the ones in newChannel. </p>
<p>Useful when recreating textures (i.e. resolution changed) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldChannel</td><td>The old textures that are going to be removed. Pointers in it must be still valid </td></tr>
    <tr><td class="paramname">newChannel</td><td>The new replacement textures </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01e7c49813462a88761ff73f514d7ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>oldBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>newBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ae22596b5bd2a3faf2958ab3d109d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a57e0523432c6e5133ff4fc251111a60e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae693eac3a7af913adfbb28ba49935842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::resetAllNumPassesLeft </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the number of passes left for every pass (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass_def.html#a70ba2384e061021d6eceb5dd20b66d47" title="Number of times to perform the pass before stopping. -1 to never stop. ">CompositorPassDef::mNumInitialPasses</a>) Useful when you have a few starting 'initialization' passes and you want to reset them. </dd></dl>

</div>
</div>
<a class="anchor" id="a817bc10dbf5427a77912ab3bcd391f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::setEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables all instances of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that we just won't execute our passes. It's your job to change the channel connections accordingly if you have to. A disabled node won't complain when its connections are incomplete in a workspace. </dd></dl>
<dl class="section user"><dt></dt><dd>This function is useful frequently toggling a compositor effect without having to recreate any API resource (which often would involve stalls). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_compositor_node_8h.html">OgreCompositorNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a></li>
    <li class="footer">Generated on Thu May 4 2017 22:21:37 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
